<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Discrete Events System framework (multiagents based) ver. 3. Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 05-Dec-2020</releaseinfo>

	<abstract>
	    <simpara>This document collects software desing for Discrete Events System (DES) framework ver 3.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>05-Mar-2020</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>

	<biblioentry id="ref_incr_mut"> <abbrev>INCR_MUT</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_incr_syst_creation/index.html "/></productname>
	    <title>Y.Borisov. Using incremental mutation process for systems modeling</title> </biblioentry>

	<biblioentry id="ref_rfc_3986"> <abbrev>RFC_3986_URI</abbrev>
	    <productname><ulink url="httpss://www.ietf.org/rfc/rfc3986.txt"/></productname>
	    <title>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</title> </biblioentry>

	<biblioentry id="ref_ss_cof"> <abbrev>SS_COF</abbrev>
	    <productname>Local copy <ulink url="files://home/yborisov/Documents/Compilators/Konstruirovanie_Kompilyatorov.pdf"/></productname>
	    <title>Sergey Swerdlov. Creating of compilators.</title> </biblioentry>
    </bibliolist>

    <glossary> <title>Glossary</title> 

	<glossentry id="gls_adp"><glossterm>ADP</glossterm> <acronym>ADP</acronym>
	    <glossdef> <para>
		Agents DES adaPtorThe agent dedicated to adapt target agent interfaces to DES. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_dmm_adp"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_asr"><glossterm>ASR</glossterm> <acronym>ASR</acronym>
	    <glossdef> <para>
		DES. Activation on system reconfiguration. The feature where DES is activated on the structure
			reconfiguration. Ref
		    <xref linkend="ds_asr"/> </para></glossdef>
	</glossentry>


	<glossentry id="gls_ascl"><glossterm>ASCL</glossterm>
	    <glossdef> <para>
		Agents specific chromo languge. The approach that allows specific mutations and even chromo syntax for some agents. Ref
		    <xref linkend="ds_ascl"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_cac"><glossterm>CAC</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Chromo but not mutation.  Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cam"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cam"><glossterm>CAM</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Mutation but not chromo. Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cac"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point. Element that is used as endpoint of connections between systems. </para></glossdef>
	</glossentry>

	<glossentry id="gls_chromo2"><glossterm>CHROMO2</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Enhanced version of chromo language. Uses specific syntac instead of xml-based in the initial version. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_chr2"/> for details. </para></glossdef>
	</glossentry>

	<glossentry id="gls_daa"><glossterm>DAA</glossterm> <acronym>DAA</acronym>
	    <glossdef> <para>
		Distributed Agents Approach.  Approach of multi-agent system that assumes that the modes is distributed among several environments that 
			can be running on undependent executable enviromnents. Ref
		    <xref linkend="ds_daa"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_dce"><glossterm>DCE</glossterm> <acronym>DCE</acronym>
	    <glossdef> <para>
			Dedicated Content Element of native hier.  Approach of content support based on dedicated elements of native hier. Ref
		    <xref linkend="ds_dce"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_dcs"><glossterm>DCS</glossterm> <acronym>DCS</acronym>
	    <glossdef> <para>
			DES Control of System, the mechanism of managing some subsystem by DES. 
		    <xref linkend="ds_dcs"/> for desing details </para></glossdef>
	</glossentry>


	<glossentry id="gls_ssp"><glossterm>SSP</glossterm>
	    <glossdef><para>
		DES Service Point. Mechanism the system provides to the "client" to update clents state depending on system context.
		    <xref linkend="ds_ssp"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_deds"><glossterm>DEDS</glossterm> <acronym>DEDS</acronym>
	    <glossdef> <para>
		Discrete Event Dynamic System,  a discrete-state, event-driven system of which the state evolution depends entirely
		on the occurrence of asynchronous discrete events over time. Although similar to continuous-variable dynamic systems (CVDS),
		DEDS consists solely of discrete state spaces and event-driven state transition mechanisms.  Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete_event_dynamic_system"/></para>
		<glossseealso otherterm="gls_des"/> </glossdef>
	</glossentry>

	<glossentry id="gls_des"><glossterm>DES</glossterm> <acronym>DES</acronym>
	    <glossdef> <para>
		Discrete-Event Simulation - model of the operation of a system as a discrete sequence of events in time.
		Each event occurs at a particular instant in time and marks a change of state in the system. Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete-event_simulation"/></para> <glossseealso otherterm="gls_deds"/>
		<para>Also this abbreviation is designates Discrete Event System, the implementation of discrete-event simulation.</para>
	    </glossdef>
	</glossentry>

	<glossentry id="gls_desas"><glossterm>DESAS</glossterm> <acronym>DESAS</acronym>
	    <glossdef> <para>
		Discrete Event System Active Subsystem, the part of discrete-event system that is implemented as
			autonomous sub-system. Ref <xref linkend="ds_desas"/></para> for design.</glossdef>
	    </glossentry>

	    <glossentry id="gls_dhc"><glossterm>DHC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Direct Hierarchical Chromosome</para> <para>
		Approach of multi-agent system definition that describes the model's structure directly. 
		Ref <xref linkend="ds_smc"/> for discussion regarding chromo desing approaches.
		    Ref <xref linkend="gls_osm"/> for anoter design approach.</para></glossdef> </glossentry>

	<glossentry id="gls_dmc"><glossterm>DMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Dependent Mutations Chromosome</para> <para>
		Chromo definition approach when the mutation can have other mutaions (of node type) as the operands.
		This approach helps defining the model with anonymous nodes that is especially effective for <xref linkend="gls_des"/> models.
		    Ref <ulink url="../../../grayb/doc/design/index.html#gls_dmc"/> for original glossary. </para></glossdef> </glossentry>

	<glossentry id="gls_ddmc"><glossterm>DDMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>
		Direct Dependent Mutations Chromosome structure.
		Chromo structure that directly aligned to
		    <xref linkend="gls_dmc"/>.
			This approach allows to have single unified chromo representation.  Ref
		    <ulink url="ds_cli_ddmc"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_ccn"><glossterm>CCN</glossterm> <acronym>CCN</acronym>
	    <glossdef> <para>
		Compact (and customized) Chromo Notation, approach that focus on having compact notation of model chromo.
		This allows effectivelly creating the model via 'manually' creating chromo of it. Another solution
		is Native Chromo Notation, ref
		    <xref linkend="gls_ncn"/>. </para></glossdef> </glossentry>

	<glossentry id="gls_clm"><glossterm>CLM</glossterm> <acronym>CLM</acronym>
	    <glossdef> <para>Command Line Monitor application <ulink url="../../../grayb/doc/design/index.html#gls_clm"/> for original glossary </para></glossdef> </glossentry>

	<glossentry id="gls_cmt"><glossterm>CMT</glossterm> <acronym>CMT</acronym>
	    <glossdef> <para>Combined Mutation Target.  The approach of specifying target in mutation spec when mutation target and change targets are
		spedified separately. With this approach the target specified with two mutation attribute, ref also <xref linkend="gls_umt"/> for
		    alternative approach.</para></glossdef> </glossentry>

	<glossentry id="gls_cpa"><glossterm>CPA</glossterm> <acronym>CPA</acronym>
	    <glossdef> <para>Connecting Proxy Agent.
		The approach of agents design where dedicated embedded agents play the role of 
		connection points of agent, i.e. doing all connecting relative work instead of agent.
		In contrast of <xref linkend="gls_pia"/> connecting proxy agent provides interface
		    resolution mechanism for the client, so the mechanism is distributed between multiple
		    connecting agents in the model.  </para></glossdef> </glossentry>

	<glossentry id="gls_dmm"><glossterm>DMM</glossterm> <acronym>DMM</acronym>
	    <glossdef> <para>
		DES Managing of Model.  The approach of using DES to manage the generic multi-agent model.
		With this approach it is not needed to have some external native model managing entity, this managing entity
		is implemented as managing DES model, ref also
		    <xref linkend="ds_dmm"/> for details.</para></glossdef> </glossentry>

	<glossentry id="gls_eosm"><glossterm>EOSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		Extended Original Sequence of Mutations chromo language approach- 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase. This approach extends
		    <xref linkend="gls_osm"/> in that, enables segments in mutation output chromo. Initial
		    <xref linkend="gls_osm"/> solution just transormed hierarchical input chromo to flat structre (without segments) </para></glossdef>
	</glossentry>

	<glossentry id="gls_fap2"><glossterm>FAP2</glossterm> <acronym>FAP2</acronym>
	    <glossdef> <para>
		Discrete Events System (DES) framework ver. 2 aka "grayb". Ref
		    <ulink url="../../../grayb/doc/design/index.html"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_irm"><glossterm>IRM</glossterm>
	    <glossdef> <para>Interface resolution mechanism.  <ulink url="../../../grayb/doc/design/index.htmds_ifcache"/>
	</para></glossdef> </glossentry>

	<glossentry id="gls_irmc"><glossterm>IRMC</glossterm>
	    <glossdef> <para>
		Interface resolution mechanism with caching result. This solution reduces access to resolved ifaces, to increase
		the model performance.  Ref
		    <xref linkend="ds_irm_cr"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_lsc"><glossterm>LSC</glossterm>
	    <glossdef> <para>
		Layered System Control. Controlling of DES specific approach where controlling part is isolated from controlled in separate "layer".
		Ref
		    <xref linkend="ds_dcs_sl"/> for details.  </para></glossdef>
	</glossentry>


	<glossentry id="gls_ncn"><glossterm>NCN</glossterm> <acronym>NCN</acronym>
	    <glossdef> <para>
		Native Chromo Notation, approach that focus on very simple chromo notation, like
		assembler. It is 'universal', less readable and more suitable for creating model with IDE. Another solution
		is Compact Chromo Notation, ref
		    <xref linkend="gls_ccn"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_osm"><glossterm>OSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		Original Sequence of Mutations - 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase, ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_mut_osm"/>. Ref
		    <xref linkend="gls_dhc"/> for another approach.  Ref also
		    <xref linkend="gls_eosm"/> for extended solutions.
	</para></glossdef> </glossentry>

	<glossentry id="gls_odb"><glossterm>ODB</glossterm> <acronym>ODB</acronym>
	    <glossdef> <para>
		An object database or object-oriented database is a database management system in which information is represented
		in the form of objects as used in object-oriented programming.
		    <ulink url="https://en.wikipedia.org/wiki/Object_database"/> and
		    <ulink url="https://www.service-architecture.com/articles/object-oriented-databases/"/>.
	</para></glossdef> </glossentry>


	<glossentry id="gls_orm"><glossterm>ORM</glossterm> <acronym>ORM</acronym>
	    <glossdef> <para>
		Objectâ€“relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique
		for converting data between a relational database and the heap of an object-oriented programming language.
		This creates, in effect, a virtual object database that can be used from within the programming language.
		    <ulink url="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping"/> and
		    <ulink url="https://www.service-architecture.com/articles/object-oriented-databases/object-relational-mapping.html"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_mae"><glossterm>MAE</glossterm>
	    <glossdef> <para>
		Using monodilic agent instead of embedded.  Optimization approach, where monolitic native agents instead of constructed agents.
		    <xref linkend="ds_mae"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_pia"><glossterm>PIA</glossterm> <acronym>PIA</acronym>
	    <glossdef> <para>
		Properties Instead of embedded auxiliary Agents
		The approach of agents design where properties are using instead of auxiliary agents
		in order to minimize the agents number, ref
		    <xref linkend="ds_pia"/>. Ref <xref linkend="gls_cpa"/> for another connecting solution. </para></glossdef>
	</glossentry>

	<glossentry id="gls_csl"><glossterm>CSL</glossterm> <acronym>CSL</acronym>
	    <glossdef> <para>
		Connecting Same Layer vertices -
		Model creation policy of binding vertexes. According to this policy the only same layer
		vertexes can be connected. The owner of the layer is respondible to verify the policy.
		    <xref linkend="ds_conn_cwdl"/>.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_scc"><glossterm>SCC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		State with Combined Chains. DES state design where data and observing chains are same.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_ssc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_sdc"><glossterm>SDC</glossterm> <acronym>SDC</acronym>
	    <glossdef> <para>
		System DES controller. The mechanism of system structure update controlled by DES where the controlling DES "accesses"
		to managed system structure via a number of specialized systems performing certain mutation. 
		     Ref <xref linkend="gls_adp"/> for another design solution.</para></glossdef>
	</glossentry>

	<glossentry id="gls_sdo"><glossterm>SDO</glossterm> <acronym>SDO</acronym>
	    <glossdef> <para>
		System DES observer. The mechanism of system structure observing compatible with DES.
		     Ref <xref linkend="ds_dcs_sdo"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_slc"><glossterm>SLC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		Sockets Loopback Connections. Socket design approach when loopback connections are supported
		    <xref linkend="ds_ifcache_slc"/>. </para></glossdef>
	</glossentry>

	<glossentry id="gls_ssc"><glossterm>SSC</glossterm> <acronym>SSC</acronym>
	    <glossdef> <para>
		State with Separate Chains. DES state design where data and observing chains are separated.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_scc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_uac"><glossterm>UAC</glossterm> <acronym>UAC</acronym>
	    <glossdef> <para>
		Units for Auxiliary Components
		The approach of agents design where "passive" units are used instead of agnents as
		auxiliary components, ref
		    <xref linkend="ds_uac"/>. Ref <xref linkend="gls_cpa"/>, <xref linkend="gls_pia"/> for other connecting solutions. </para></glossdef>
	</glossentry>

	<glossentry id="gls_umt"><glossterm>UMT</glossterm> <acronym>UMT</acronym>
	    <glossdef> <para>
		Unified Mutation Target.  The approach of specifying target in mutation spec.
			With this approach the target specified with just one mutation attribute, ref
		    <xref linkend="ds_umt"/>.  Ref <xref linkend="gls_cmt"/> for alternative approach.</para></glossdef>
	</glossentry>

    </glossary>

    <sect1 id="ds_itr"><title>Intro</title>
	<sect2 id="ds_itr_sp"><title>The scope of the project</title>
	    <simpara>This project is focusing on re-desing of DES framework fap2, aka grayb, ref <ulink url="../../../grayb/doc/design/index.html"/> for
		the desing. Ref also <xref linkend="ds_ibc"/> and <xref linkend="ds_ic"/> for tracked list of the items to be addressed and completed items in FAP3.
		    The main areas of improvement are:</simpara>
	    <itemizedlist>
		<listitem>
		    Unify of native level relations (connections), like owner-component, observer-observable, etc. Create common desing for the
		    relations.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_i_anr"/> for current desing weakness analysis.</simpara>
		</listitem>
		<listitem>Design native connections iterating mechanism.</listitem>
		<listitem>
		    Base iface resolution on native level connections.
		    <simpara>Ref <xref linkend="ds_irm"/></simpara>
		</listitem>
		<listitem>
		    Design content basing on native level connections tree of content units.
		    <simpara>Also look at <xref linkend="ds_cnh"/> for another content desing discussion.</simpara>
		</listitem>
		<listitem>Easy support of anonymous units.</listitem>
		<listitem>
		    System creation language (chromo) optimization.
		    <simpara>Ref <xref linkend="ds_cli"/></simpara>
		</listitem>
		<listitem>Notification mechainsm optimization. Ref <ulink url="../../../grayb/doc/design/index.html#ds_prfopt_ahn"/></listitem>
		<listitem>Fix the IRM problem <ulink url="../../../grayb/doc/design/index.html#ds_i_nrn"/>
		    <simpara>Ref <xref linkend="ds_irm_ut_inv_own"/></simpara> </listitem>
		<listitem>Redesign system navigation mechanism to restrict the access. <simpara>Ref <xref linkend="ds_sn"/></simpara></listitem>
		<listitem>
		    Improve chromo language: support mutations chain (<xref linkend="gls_dmc"/>), use strong parsing.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_mc"/> for FAP2 desing item. Ref <xref linkend="ds_cli"/> for the material.</simpara>
		    <simpara></simpara>
		</listitem>
		<listitem>Redesign import to avoid chromo analysis for selecting imported node. Ref <xref linkend="ds_imp"/> for details.</listitem>
		<listitem>
		    Redesign DES adapter referencing to managed agent.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_dmm_irta"/> for details.</simpara>
		</listitem>
		<listitem>
		    Redesign chromo to make it really copyable.
		    <simpara>At least one related use-case is MElem <xref linkend="gls_adp"/> that can mutate managed agent basing on the input
			receiveing chromo. Current chromo desing potentially allows copy (ref DChr2 data based state) but in rather messy way.
			Ref <xref linkend="ds_mcrc"/>
		    </simpara>
		</listitem>
		<listitem>Redesign connpoint extender. Ref <ulink url="../../../grayb/doc/design/index.html#ds_di_wrcpe"/> for desing issue.</listitem>
		<listitem>
		    <glossterm id="ds_itr_sp_rnac">Redesing notification of agent change.</glossterm>
		    <simpara>
			Currently, the agent notifies of its updates to owner, embedded agents and observers. This is too comlicated. We need
			to remain only observer and implement proper native relation observer-observable. Also there should be some policy enabling
			establishing such relation. For instance is embedded agent can set itself as observer there should be acceptance from the embedding agent.
		    </simpara>
		</listitem>
		<listitem>
		    Redesing URI to make is simpler and convenient.
		    <simpara>Ref <xref linkend="ds_urd"/> for details.</simpara>
		</listitem>
		<listitem>
		    Avoid necessity of having dedicated chromo for mutation in inheritable agents. Ref <xref linkend="ds_adcm"/> for details.
		</listitem>
		<listitem>
		    Modify DES cycle to avoid polling the comps but keep the lists of active/updated in owner. Ref <xref linkend="ds_mdc"/> for details.
		</listitem>
		<listitem>Implement <xref linkend="gls_ddmc"/>, ref <xref linkend="ds_cli_ddmc"/></listitem>
		<listitem>Improve means of debugging, ref <xref linkend="ds_dbg"/></listitem>
		<listitem>Keep consistent tree-ish chromo on run-time. Ref <xref linkend="ds_tch"/></listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_itr_dp"><title>Dependent projects</title>
	    <sect3 id="ds_itr_dp_grayb"><title>DES framework fap3, aka grayb, ref <ulink url="../../../grayb/doc/design/index.html"/></title>
	    </sect3>
	</sect2>
	<sect2 id="ds_itr_pss"><title>The philosophy of structured systems.</title>
	    <simpara>All FAP projects are about using structured system as the means of creating big models. Structured system philosophy is very simple:
		there are a number of agents that can be combined according to the topology. The topology connects the agents according to that required for the created model.</simpara>
	    <simpara>The structured sytem creates topology basing on system principles: the big model is separated to smaller parts,
		these parts are also separated etc. So the topology is "hidden" in the clear and well understandable structure.</simpara>
	    <simpara>So the model is created via the creation of proper topology of the given set of pre-defined compoments.</simpara>
	    <simpara>There are a number of models types suitable for such model creation apporach. One of the types is <xref linkend="gls_deds"/> that allows creating
		complex dynamic systems.</simpara>
	</sect2>
	<sect2><title>Misc refs</title>
	    <itemizedlist>
		<listitem><ulink url="https://en.wikipedia.org/wiki/Specification_and_Description_Language"/> for SDL</listitem>
	    </itemizedlist>
	</sect2>
    </sect1>

    <sect1 id="ds_nn"><title>Native net</title>
	<sect2><title>Intro</title>
	    <sect3><title>What is native net?</title>
		<simpara>Native net is the initial topology and environment that allows to create the systems using system (model) creation language.
		    So native net is the "sceleton" of the model. Native net allows to manage all units of the model.</simpara>
	    </sect3>
	    <sect3><title>Institutionalize all the relation on native layer.</title>
		<simpara>The main idea of native net is to support all relations on the native layer via common design approach, common mechanism. Saing "on
		    native layer" we mean the relations that are not seen from the top layer model, for instance the relations created via iface resoluion, 
		    notifications etc.. In fap2 different approaches are used for establishing such relations.</simpara>
	    </sect3>
	    <sect3><title>Distributed env support by native net.</title>
		<simpara>Native net supports interactions between units. Theas mean that these interactions shall correctly work in distributed env. So all
		    ifaces created relations in native net shall be MIface.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>What is difference between native and system level connections?</title>
	    <simpara>Native connection allows creating native net, the connection is like "owner-component", "iface_requetor-iface_provider". System level
		connection is just abstraction of system topology. In fap2 the only base mechanism of MVert-MVert binding is used.
		This connection is to utilize interactions between specialilzed units. The behaviour of such 
		connection is defined via this specifics of connected units.</simpara>
	    <simpara>Parameters of system level connectins are defined via system creaton spec (specifying in terms of system creation language).</simpara>
	</sect2>
	<sect2><title>Considering common desing for native net two-ways relations.</title>
	    <simpara>The serious problem in fap2 was that this desing principle was not supported completely. For instance owned-owner iface is not defined
		properly, huge MUnit is used instead.</simpara>
	</sect2>
	<sect2><title>Interface vs connections</title>
	    <sect3><title>Intro</title>
		<simpara>In fap2 the "atom" of C++ objects interactions is interface, that according to OOP philosophy. However as we see the most of interactions
		    are of 2-ways. The abstraction of 2-ways relation is connection, that covers two interacting interfaces and binding mechanism. Seems the connections
		    can play the role of "atom" when 2-ways interactions.</simpara>
		<simpara>This is also applicable for the interactions in the system layer over native net. Currently the ifaces are resolved over native net. Probably
		    it makes sense to resolve connection points instead.</simpara>
	    </sect3>
	    <sect3><title>Do we need "connecting" iface?</title>
		<simpara>The possible design solution is MIface is extended to introduce connection functions, ref MCIface or MCIface2 in 74ed7dd2. The rationale
		    of such design is that iface can be obtain using the current iface resolution  or local iface providing mechanisms,
		    so as iface supports connection we can connect it. The emotions promoting this desing was "What? Why we need now two abstractions to be taken care -
		    iface and connpoint. Let's have just one."</simpara>
		<simpara>This desing is not clear actually. The iface resolution itself involves connections. As for local iface providing, the specific API can 
		    be addd to access conn points.</simpara>
		<simpara>The idea is: connection is just means of accessing and managing iface. They are not same level abstractions.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>How to implement native connection?</title>
	    <sect3><title>Intro</title>
		<sect4><title>Native connection point vs 2-ways connection iface.</title>
		    <simpara>First idea was to define specific iface for 2-ways connection (allowes connect, disconnect, access to provided and required
			ifaces). That was like this:</simpara>
		    <programlisting>
			template &lt;class TPif, class TRif&gt; class MNcpp
			{
			public:
			    using TPair = MNcpp&lt;TRif, TPif&gt;;
			virtual TPif* provided() = 0;
			virtual bool connect(TPair* aPair) = 0;
			virtual bool disconnect(TPair* aPair) = 0;
			virtual bool attach(TPair* aPair) = 0;
			virtual bool deattach(TPair* aPair) = 0;
			virtual bool isConnected(TPair* aPair) const = 0;
			virtual bool getId(string&amp; aId) const = 0;
			};
		    </programlisting>
		    <simpara>but then trying to implements MVert with this and see that it is needed to use MNcpp&lt;MVert, MVert&gt; instead of just MVert when
			connecting. So the question was why cannot we just introduce iface "iface as part of 2-ways connection" and inherit MVert from it but
			not from MIface. These two solution differs in ifaces inheritance stack.</simpara>
		    <simpara>The "Native conn point" approach: MIface - &lt;provided iface&gt; - connection_iface</simpara>
		    <simpara>The "2-ways connection iface":  approach: MIface - connection_iface - &lt;provided iface&gt;</simpara>
		    <simpara>For "Native conn point" approach we can implement native connection point base class that implements connection_iface. Then from this
			class we can inherit custom connpoint implementing (delegating) provided iface. This isolates conn point functionality from 
			host (e.g Unit) implementation,that seems to be advantage. However intuitively this also seems superfluos. For instance MVert already includes the
			methods for 2-ways connection (connect, disconnect etc).</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_nn_tree"><title>How to implement tree?</title>
	    <sect3><title>Intro</title>
		<simpara>There is the initial implementation (4da8309df913) of the tree node, ref nconn.h:NTnnp or nconn.h:NTnip. But there are doubts regarding the
		    desing, it seems not proper. This is bacause of quite complicated scheme. Actually the "tree node" functionality is implemented on application
		    iface level but not in the tree node class itself.</simpara>
	    </sect3>
	    <sect3 id="ds_nn_tree_si"><title>Design approach: specific iface for tree node.</title>
		<simpara>Currently (4da8309df913) the tree node class is just combination of two connpoints. So it doesnt support upward navigation for instance.</simpara>
		<simpara>We can introduce specific iface for tree node that is both down connpoint&lt;Prov,Req&gt; and up connpoint&lt;Req,Prov&gt;</simpara>
		<sect4 id="ds_nn_tree_si_dtl"><title>How to distinguish tree node and tree leaf?</title>
		    <simpara>This is the problem that gets shown when implementing tree traversal: we need to know if the down connpoint is node or leaf. The one solution
			is to dynamic cast the connpoint to node. Another solution is to extend connpoit API with method getting up/down connpoint. To have ability of travarsal 
			both downwards and upwards we need both such solutions for both way.</simpara>
		</sect4>
		<sect4><title>Cons and pros</title>
		    <simpara>Cons: needs to have stub for one iface up or down</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_nn_tree_bc"><title>Design approach: extended cp api for binded cp, embedded up cp</title>
		<sect4><title>Intro</title>
		    <simpara>The idea is to extend cp api to get up/down  connpoint (<xref linkend="ds_nn_tree_si_dtl"/>) and implemend specific tree node embedded up connpoint
			so that it returns the host as down cp.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2><title>How to simplify the desing of native net.</title>
	    <sect3><title>Intro</title>
		<simpara>Current implementation of native net is quite complicated and not convenient in use. How can we simplify it. Look for instance
		    at firstLeafB().</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_nn_efcoop"><title>Native hier efficiency comparing to OOP</title>
	    <sect3><title>Intro</title>
		<simpara>Lets look at the current FAP systems creation approach. It is based on inheritance, like it is done in OOP.</simpara>
		<simpara>The diff of fap agents and OOP can be seen obviously: in OOP the class keeps the common part of its instances.
		    The instance specific part is the instance context - all the states, whereas the class contains "constant and common" part - methods.</simpara>
		<simpara>If we look at some DES we can see that it also has states and methods (transitions). But in DES transitions is part of instance but
		    not the class (parent). Why?</simpara>
		<simpara>Potentially we can imagine DES following such OOP approach: let's imagine that we can separate all variable part of DES
		    (i.e. all states data). Then the parent DES (i.e. "class") will keep only "constant" part (i.e. structure - states (w.o. states data, 
		    transition etc.). Heirs in that case will use single parent constant part to update its variable part. This would be very efficient - 
		    all heirs would contain only small variable part.</simpara>
		<simpara>Of course the pictue is more complicated that this simple view - the heirs also need to keep another variable data like
		    indication of active/updated etc.</simpara>
		<simpara>Another point that always is eyecatcher: why we need to dupilcate DES controlling part in heirs. For instance fap3-vis containter
	    includes DES SDCs to add vidgets. Thiese SDCs belongs to each instance of container. Obviously this looks superfluous.</simpara>
	    </sect3>
	    <sect3><title>Is the structure variable or constant part?</title>
		<simpara>What about structure? It also is represented by variable data like trees data (owned/owning tree, IFR tree, pairs tree etc.).
		    In OOP it is also the part of hier, look for instance to any container, list etc.
		    All regular data in OOP is put to hiers, the only methods or static data is posessed by class.</simpara>
		<simpara>But we face contradiction here: the transitions are defined via the structure (i.e. variable data) so how they can be
		    the essential part of class?</simpara>
		<simpara>The cause of this contradiction is that in FAP the part that is analogue of OOP methods (transitions, states etc)
		    is created via structure (i.e.  variable data) on run-time whereas in OOP it is created via constant definition on compilation time.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_nn_abo"><title>Using auto-indexed arrays for ownership connection instead of name-to-owned_instance mapping</title>
	    <sect3><title>Intro</title>
		<simpara>Currently name-to-owned_instance map is used form owning connpoint (specifically NCpOmip, ref Node class def). We can simplify
		    this by using array instead of map. For that we need to keep all owned of the current owning in form of table. So URI in native hier
		    will "internally" be represented by the list of names indexes. Textual representation can be simply formed. Back conversion (from textual repr
		    to index repr seems to be more time consuming but this operation is requred on chromo applying phase only.)</simpara>
		<simpara>Probably, We also need to migrate to the approach "Name as the attribute of the relation" for native hier node local identification,
		    ref <ulink url="../../../fap4/doc/design/index.html#ds_nh_ni"/> for details</simpara>
	    </sect3>
	    <sect3><title>UC: owned depends on name. Renaming. Do we need notification.</title>
		<simpara>This is use-case for the case when  "Name as the attribute of the relation" approach is also applied.
		    In this case owning shall have method to get owned name. But it is not enough.
		    Owned can depend on its name (not sure this is a good desing), TrCmpVar for instance, or future constants like SI_23 where the name
		    encodes the constant parameter. Yes, owned can get the name from owning but it also needs to be notified when the name gets changed.</simpara>
	    </sect3>
	    <sect3><title>UC: Removing owned.</title>
		<simpara>To make this op effective we can just mark the table element as unused (set nullptr for owned). It can be utilized when adding next owned.
		</simpara>
	    </sect3>
	    <sect3><title>Does it really increase the performance?</title>
		<simpara>Most imprtant native hier node method that ownership relation desing affects is MNode::getNode(GUri). This method is called actively not
		    only on the system creation phase but on system running also.</simpara>
		<simpara>I just experimented, added input cache into State:</simpara>
		<programlisting>
		    MDVarGet* State::GetInp()
		    ||          //MNode* inp = getNode("Inp");
		    ||          if (!mInp) mInp = getNode("Inp");
		    ||          MNode* inp = mInp;
		</programlisting>
		<simpara>Run fap3-vis ut_avr_vert_drp_2 5 vertexes ring as reference model:</simpara>
		<programlisting>
		    Without inp cache: 8.333 (sec) = 05:56:12.454 - 05:56:04.121
		    With    inp cache: 8.227 (sec) = 06:04:32.867 - 06:04:24.640
		</programlisting>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_uinn"><title>Units identification in native net.</title>
	<sect2><title>Intro</title>
	    <simpara>It is common practice to use anonymous units of any type (even native net units). For instance ifaces set obtained via iface resolution
		mechanism consists of anonymous units. However units identification is very important: it gives us essential information of unit that
		helps us in case of debug, analysis etc. Also identification is required to resolve the unit in native net, e.g.
		in case of distributed models. The question is what kind of identification shall be used?</simpara>
	    <simpara>In <xref linkend="gls_fap2"/> the only identificator of unit in native tree is the unit name. So anonymous unit is simply unit with
		hidden name.</simpara>
	</sect2>
	<sect2 id="ds_uinn_id"><title>What units in native net need to have identification.</title>
	    <sect3><title>Intro</title>
		<simpara>In <xref linkend="gls_fap2"/> the only ifaces have identification. The focus was to provide native hier creating iface (MUnit) with
		    safe identification mechanism. Other ifaces are identified via MUnit identification plus iface type - so the identifiation scheme is restricted,
		    there is no rule to identify given iface in case of MUnit node includes number of ifaces of same type.
		    Ref <xref linkend="ds_f2dw_isr"/> for the desing weakness description.</simpara>
		<simpara>
		    The question is if we really need to identify all ifaces? The identification require some additional resources.
		    This why in <xref linkend="gls_fap2"/> the exact identification is supported by MUnit only (it supports identification by name and is element of native
			hier, thus can be identified by URI). All other ifaces are "attached" to MUnit so identified via MUnit identification (ref MIface::Mid()).
		</simpara>
		<simpara>Actually identification of ifaces are supported in fap2, ifaces owned MUnit can overload MIface::Uid() to generate unique IDs for each
		    iface (even of same type) but there is mechanism of resolving the iface using this ID. So attempt to have full identification of iface is just
		    attempt of representing iface as unit. Do we really need it? Seems not, because iface is just ptr to virtual func table, so needs the 
		    "carrier" of the iface (i.e. owner of the table).</simpara>
	    </sect3>
	    <sect3><title>Do we need to identify the native units?</title>
		<simpara>Native units provides the means of creating native net. These are native connections, ifaces etc. I cannot see the necessity
		    of identifying these units. The matter is that any identifying is just the means of distinguish the unit within some topology, but we are not going
		    to have dedicatied subnative topology.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_uinn_cs"><title>Units identification in complex sytem. Name as identifier is not effective.</title>
	    <sect3><title>Intro</title>
		<simpara>Let's look at fap3-vis VertDRP design (and especially the design of EdgeCRP). This modes shows the units identifiaction problems in
		    complex systems. DRP has column index as inernal state of columns iterator. But there is not means of identifying columns via index - we
		    have only name as identifier. So, VertDRP solution was to "embed" the index into the name. This works but now we have extra transitions to
		    form the name from index.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_irm"><title>Iface resoluion mechanism (<xref linkend="gls_irm"/>) redesign</title>
	<sect2><title>Intro</title>
	    <itemizedlist>
		<listitem>Ref <ulink url="../../../grayb/doc/design/index.html#ds_ifcache"/> for FAP2 design of iface resolution. </listitem>
		<listitem>In FAP2 the iface resolution cache was implemented as the reolutio mechanism. </listitem>
	    </itemizedlist>
	</sect2>
	<sect2><title>Proposals</title>
	    <simpara>The idea of redesign is to get rid of fap2 iface cache and use native tree of iface providers instead. Each iface request shall
		create specific native tree of providers, so the client can traverse via the tree to get all the ifaces provided.</simpara>
	</sect2>
	<sect2 id="ds_irm_ut"><title>How to update <xref linkend="gls_irm"/> tree?</title>
	    <sect3><title>Intro</title>
		<simpara>The tree created in result of iface request needs to be updated according to the system changes. For instance if system node provided
		    iface is removed then the tree corresponds branch needs to be removed too. How can we implement this updatae of IRM tree?</simpara>
		<simpara>In FAP3 the invalidation apporach was applied: the whole branch is marked as invalid on any provider update, this causes 
		    the cache update on the iface next request.</simpara>
		<simpara>Ref <xref linkend="ds_iss_003"/> for the problem with IFR update on sockets connect/disconnect.</simpara>
	    </sect3>
	    <sect3 id="ds_irm_ut_inv"><title>Solution: branch invalidation via setting invalid indication</title>
		<sect4><title>Intro</title>
		    <simpara>The generic approach is clear. But the questions remain what nodes to mark invalid and how to refresh resolution then.
			This is same approach as FAP2 applied ATM. Revised the approach. Implemented <xref linkend="ds_irm_ut_inv_cno"/> as most
			    safe.</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_ib"><title>Solution#1 Current one. Invalidata the whole branch.</title>
			<simpara>It is not enough that the current provider "passes" all potential providers and refresh the tree. It is also required to
			    go thru all up pairs after that and remove the pairs that are still invalid.</simpara>
			<simpara>Is this approach effective? It is implemented (I stay on ac6c810e11a16f1) but has sowe drowbacks - we need to apply quite complicated schema to 
			    refresh providers tree: when we resolve iface after invalidating current node we need to check if the potential provider already
			    exists in the tree (ref IfrNode::findOwner). This should be done in any resolution methods, so needs to be very carefull to not
			    avoid this checking, otherwise there will be duplicated branches in providers tree. Why don't just remove the whole providers tree in
			    case of invalidating (ref <xref linkend="ds_irm_ut_inv_rb"/>)? Probably the idea was that the valid branches to providers can be re-used.  </simpara>
			<simpara> Seems there is the problem in the current implementation:
			    When the invalidated node is refreshed, it is marked as valid, but when the invalidated providers node is checked on existence
			    then we just omit redirecting to it and it stays invalid. So with this approach we need to check if the node already exists in the path
			    and if the node is invalid then request it for resolving. There is obvious drawback: each resolution code needs to be created very
			    carefully to not avoid this checking of node existence.</simpara>
			<simpara>
			</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_inv_rb"><title>Solution#2: remove the branch</title>
			<simpara>This solution seems not effective. Indeed, what is the reason of removing owners of invalidated node? Actually the owners are not
			    invalid, the current node invalidation doesn't affect the owners validity. The only reason would be to initiate the chan of resolution.</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_inv_cno"><title>Solution#3: invalidate only current node, remove owned tree, resolve invalid node in leafs tree-walk.</title>
			<simpara>With this approach we don't need to check existence of node in each resolving procedure, ref <xref linkend="ds_irm_ut_inv"/>
			    We just need to modify the leafs three-walk to check if the node is invalid so refresh resolution.
			</simpara>
		    </sect4>
		</sect3>
		<sect3 id="ds_irm_ut_inv_own"><title>Providers owner iface, notification of provider updated</title>
		    <sect4><title>Intro</title>
			<simpara>We need to support owning of iface providers nodes, the proper way for that is introducing specific iface for the owner.</simpara>
			<simpara>Also the owner iface shall support notification of provider update. This will solve the FAP2 IRM problem
			<ulink url="../../../grayb/doc/design/index.html#ds_i_nrn"/> </simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_irm_cr"><title><xref linkend="gls_irm"/> with caching result (<xref linkend="gls_irmc"/>) </title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to avoid traversing of IRM tree each time the slient requests the ifaces. Caching of ifaces resolved can significantly
		    reduce the time of access to ifaces.</simpara>
	    </sect3>
	    <sect3><title>How to minimize access to root (default) provider node?</title>
		<sect4><title>Intro</title>
		    <simpara>Currently the client requests the root node by the iface name. The Node owning the IRM node uses std::map to keep the nodes.
			So the access to root node also is quite time-consuming. How to simplify the access.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_irm_pdi"><title>Proposal of <xref linkend="gls_irm"/> desing improvement</title>
	    <sect3><title>Intro</title>
		<simpara>The current desing (1641500c15) seems a bit overkill. IfrNode implements both provider and requester ifaces. IfrNode also
		    includes ref to the owning node as MIfProvOwner dedicated iface. Can we simplify the design utilizing NTnnp ifaces proxy feature so that the 
		    owning node acts as the provider and requestor.</simpara>
		<simpara>Do we really need MUnit iface? Why don't use directly MIfProv?</simpara>
	    </sect3>
	    <sect3><title>How to access IfrNode attributes, mValid for instance.</title>
	    </sect3>
	    <sect3><title>IFR supporiting the context</title>
		<simpara>Ref <xref linkend="ds_irm_ctx"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_irm_ctx"><title>IFR with context.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ds_ssp_dip_sss"/> for the "Service point" use-case and design discussion.</simpara>
		<simpara>This use-case actually highlights specific class of DES - system that contains the collections of uniform subsystems. Current DES design
		    doen't have specific means to create and run such class of systems.</simpara>
		<simpara> Actually there are two problems: </simpara>
		<itemizedlist>
		    <listitem>
			#1 How to pass the context data to the point where it can be used to resolve iface.
			<para>
			    The example can be seen from <xref linkend="ds_ssp_dip_sss"/>: Client A (client name is the context) requests the MDVarGet from CP,
			    CP shall pass the context to its MDVarGet call to SSS so this context needs to be propagated to SSS inputs and then back to CP.
			    Ref <xref linkend="ds_irm_ctx_pcd"/> for details.
			</para>
		    </listitem>
		    <listitem>
			#2 IFR request should be extended to get context as the argument. Also default iface provider (ref Unit::defaultIfProv()) shall be parametrized
			with the context. Or should there be the number of default provs for specific context. 
		    </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_irm_ctx_pcd"><title>Passing context data</title>
		<simpara>
		    The question is how to pass context to the point where the context is using to resolve interface. For instance if we would like to
		    pass the context from transitions root to transitions leafs (from state to transition inputs) we simply need to pass the context data in MDVarGet method.
		    This can be done via extending base MIface by the method setContext(ctx_data). However this seems weird at the first glance.
		</simpara>
	    </sect3>
	    <sect3><title>"Service point" use-case. Passing context data: ifaces mux.</title>
		<simpara>This is one approach of how to pass the context. The idea is to have specific native agent "Mux" instead of "Service point" socket output
		    (we assume atm that single output is used). This Mux implements MDVarGet iface but contains the array of ifaces (pins), one for each client. Each iface
		    keeps client's context data - it is obtaiened during IFR request from Client to mux. When the client calls MDVarGet method via mux pin, the pin notifies
		    service point of active context. Service point uses this context when to "switch" its other muxes.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_irm_wprc"><title>IFR as the weak point if the system is re-configurable</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ds_desopt_est"/> for the use-case. This use-case shows that IFR is 
		    not effective when system is re-configurable, the example is VertDRP.</simpara>
	    </sect3>
	    <sect3 id="ds_irm_wprc_uic"><title>Solution: Use IRM only in case of implicit connections.</title>
		<simpara>Tried this approach (ref CpStateInp with DES_CPS_IFC macro) but couldnt fix all the problems. Postponed.</simpara>
	    </sect3>
	    <sect3 id="ds_irm_wprc_blc"><title>Solution: Use DES extenders breaking long IRM chans</title>
		<simpara>
		    It is noticed when debugging that some IRM chains too long and complex. This causes long invalidation.  Ref
		    <xref linkend="ds_desopt_est"/> for the metrics - max invalidation time is ~72ms that is too long. 
			We can reduce the chains useng special extenders, ref ExtdStateOutpI.
		</simpara>
		<simpara>Tried this solution for ut_avr_vert_drp_2 - it reduces the invalidation time from 2.93s to 1.2s, max invalidation time is reduced to 7.5ms.
		    But this solution is not persistent and depends on the model topology.</simpara>
	    </sect3>
	    <sect3 id="ds_irm_wprc_lsc"><title>Solution: Layered system DES control (<xref linkend="gls_sdc"/>)</title>
		<sect4><title>Intro</title>
		    <simpara>This idea is to avoid running the system under re-configuration (controlled system). If controlled system is not run
			then we don't need to notify DES inputs immediately. This notification can be done only on controlling is completed.</simpara>
		    <simpara>Ref <xref linkend="ds_dcs_sl"/> for layered control design details.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_sn"><title>System navigation improvement. Access restrictions</title>
	<sect2><title>Intro</title>
	    <simpara>There is the gap in FAP2 desing: the access to system nodes is not restricted. So any node can access to any node. This can cause the models
		unreliability.</simpara>
	</sect2>
	<sect2><title>GUri improvement: avoid upward navigation</title>
	    <sect3><title>Intro</title>
		<simpara>In FAP2 GUri can specify upward navigation, for instance navigation thru owner to root, direct access root etc. This needs to
		be disabled. So we don't need such navigation at all. Instead we can have "special nodes" that can be accessed via GUri. Special nodes need
		to have named specifically, prefix '_' can be used for instance. Owner can be such special node also.
		    such special node.</simpara>
	    </sect3>
	    <sect3><title>Usecase: agents accesses neighbours in owning container.</title>
		<simpara>This is very common case when agent is placed in system so it needs access to other components of this system, e.g to system coppnoints.
		The agents acs in this case as system's confidant so it is reasonable it has the access to system's internals. How this use-case can be
		    supported? </simpara>
		<simpara>The solution can be as: the agent uses URI with special node "owner", so the navigation goes thru the owner, the client acces the owner
		via MOwner iface, passing self as the argument. Thus the owner can handle this request specifically - it can check if the requestor is 
		    an agent and event verify if such agent has rights for access to owner's components.</simpara>
	    </sect3>
	    <sect3><title>Use-case: fap2-vis VrController - unit adapter gets path to managed agent upward.</title>
		<simpara>So agent needs access upward its owner.</simpara>
	    </sect3>
	    <sect3><title>Use-case: creating node from parent located in arbitrary layer of hier.</title>
	    </sect3>
	    <sect3><title>Approach#1: node reference in owner.</title>
		<simpara>The idea is that sub-system needs to ask its owner to get required node - owner is the only sub-system "window to the world". The owner
		prepares the reference to the node for it's components. What is the reference? This is the node that proxies some ifaces, MUnit in case of
		    ref to parent.</simpara>
		<simpara>It some "deep" located node requires access to much upper layer than all the owners have to create such references.</simpara>
		<simpara>With this approach the owners responsibility is to create "environment" for its compoments.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Namespaces support</title>
	    <sect3><title>Use-case: native units</title>
		<simpara>Native units is specific units category, they cannot be accessed via navigation thru native hier. Specific rule is used in FAP2 to
		    distinguish native units in URI: native units are identified by single name.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_sn_aul"><title>[DS_SN_AUL] Access for upper layer. Parents, modules etc.</title>
	    <sect3><title>Intro</title>
		<simpara>Even the generic rule of access restriction is to not allow access to upper layer of native hier, sometimes such access is
		required. The example is creating "library" of systems and then use them to create heir in lower layer. Another example is 
		the modules. Also the example is <xref linkend="gls_adp"/> where adapter has to has the access to "adapted" (or monitired) agent that
		    is not in the scope of adapters node.</simpara>
	    </sect3>
	    <sect3><title>Approach#1: special nodes</title>
		<sect4><title>Intro</title>
		    <simpara>Special names (predefined?) are introduced, started let's say with underscore, _Import for instance. This names are handled by environment
			when getting access to the nodes named that names.</simpara>
		</sect4>
		<sect4><title>Criticism</title>
		    <simpara>It is unconvenient to use special name in case if we just have some system defined that needs to be used to create heir in
			lower layer.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Using implicit namespace for getting parent</title>
		<sect4><title>Intro</title>
		    <simpara>For getting the parent specific version of getNode() is used. This version gets implicit namespaces. We can utilize
		    implicit namespace like "all owners" plus _Imports plus all owners _Modules etc. "All owners" namespace should be for name only whereas
			special names can resolve uri also.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_sn_aul_lnk"><title>Using links</title>
		<sect4 id="ds_sn_aul_lnk_itr"><title>Intro</title>
		    <simpara>Let's consider the problem with <xref linkend="gls_adp"/>
		    : adapter agent needs the access to managed agent, the access can be defined with having content "Managed agent URI" but this works only
		    if the managed agent takes place within adapter tree.
		    </simpara>
		    <simpara>
			The idea is to introduce "Link" agent that implements "MLink" interface and has content "Managed agent URI". The MLink interface
			gets pointer to given interface (MNode for instance) of Managed agent. Link agent also has connection point provided MLink interface.
			Upper node connects Link agent connection point to the corresponding connection point of adapter.
		    </simpara>
		    <simpara>
			Hmm, we again faicing same problem - to specify this "subject of link" we need to use content "Subject of link URI", so with navigation 
			restrictions the "Subject of link" shall be in the tree of link that makes almost same inconvenience. Ref
			<xref linkend="ds_sn_aul_lnk_conn"/>
			for discussing this issue.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_conn"><title>Using Link specific "Connect" mutation</title>
		    <simpara>
			This problem restricted access with content "Subject of link URI" can be solved by introducing Link specific "Connection" mutation.
			Or we can introduce another mutation - "Association". In that case the system thit mutation is applied to checks if Link and node
			with proper interface (MNode for instance) are "connecting" and invokes proper "connect" API of Link.
		    </simpara>
		    <simpara>
			This solution requires some redesign of fap3. Currently MVert iface is "connectable" (is inherited to base iface MCIface) but it assumes
			the connection is of "two-ways" - it also connects to MCIface. But in our case the connection is "asymmetric" - just one side is connectable.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_sma"><title>[DS_SN_AUL_LNK_SMA] Inconvenience when using links for specify managed agent for <xref linkend="gls_adp"/></title>
		    <simpara>
			Using link doesn't allow the adapter to simply swithching to another managed agent. Currently we can use simple switching utilizing adapter
			input InpMagUri - transitions can change managed agent URI quite simply.
		    </simpara>
		    <simpara>
			Actually this problem can be solved if we have the link to managed agents owner but not managed agent itself. In that case the content MagUri and
			input InpMagUri shall specify the managed agent URI from owning node specified by the link.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_cohl"><title>Link another inconvenience: "connection" over hier levels</title>
		    <simpara>
			It's very often case where the link needs to be linked from one hier branch to another. The example is "modnav" application.
			In "modnav" Model detail representation view (that is located in Launcher.Window.Scene..ModelDrp) shall contain the link to the model but the model 
			is located in Launcher.Controller.ModelMnt. So we need to mutate Launcher to "connect" the link and the "connection" is established
			directly between different branch nodes crossing hier levels. This is bad system design.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_sn_aul_avcp"><title>Using Accessor agent giving access to manager agent via conn point.</title>
		<sect4><title>Intro</title>
		    <simpara>Using Link approach often leads to bad system desing, ref <xref linkend="ds_sn_aul_lnk_cohl"/>. Alternative solution can be using the 
			standard connections via connpoint. In that case the connection can be structured to keep subsystem isolation.</simpara>
		    <simpara>Indeed, the standard connection point mechanism can provide access to any interface including MNode for instance. What we need is 
		    to introduce "managing" agent that includes the connpoint provideing the required iface (MNode for instance) and redirecting IFR request
		    to managed agent. The desing can be simplified event more - we can just embed the connpoint into the managed agent, connpoint will
			redirect IFR request to the agent directly.</simpara>
		</sect4>
		<sect4><title>Criticism:</title>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_cli"><title>Chromo language improvement</title>
	<sect2><title>Intro</title>
	    <simpara><xref linkend="gls_dmc"/> chromo was prototyped in the scope of fap2, ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_dmc_proto"/> so
		it was decided that fap3 has to support <xref linkend="gls_dmc"/> chromo language.</simpara>
	</sect2>
	<sect2><title>Support of mutation chain</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_mc"/> for FAP2 desing discussion.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_syntax"><title>Syntax of chromo language.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_sns"/> for fap2 syntax draft.</simpara>
	    </sect3>
	    <sect3><title>Needs to updata syntax to avoid inproper semantic.</title>
		<sect4><title>Intro</title>
		    <simpara>Currently the <xref linkend="gls_dmc"/> syntax allows connection mutation operand to be node mutations and also segment with
		    context (node in context is considering the operand). In this syntax the semantic of segment context as the operand is completely
		    imporper. Even using node mutation as operand is not quite correct - the mutation is just the update of the current elem, thinking exactly
			it doesn't has the meaning "node created in result of the mutation".</simpara>
		</sect4>
		<sect4><title>Solution#1: Introduce the rule of operands interpretation.</title>
		    <simpara>The idea is to interpret node mutation  and segment context as the created node in the operand of connection mutation.
			For segment, we need to add some restriction: there should be just one context in the segment.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Get rid of combined node mut</title>
		<sect4><title>Intro</title>
		    <simpara>In chromo2 the obsolete type of mutation is still valid - combined node mutation. This was done for the purpose of 
			compatibility. But actually combined node mutation is same as segment with the node as target context.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_syntax_ss"><title>Sequence of segments</title>
		<sect4><title>Intro</title>
		    <simpara>Often (especially in case of dependent tree-like chromo) it is required to have not only namespace context segment but
		    also target segment. For instance transition1 input connects to state, the state value is set, the state input connects to 
			transition2 output. </simpara>
		</sect4>
		<sect4><title>Solution.</title>
		    <simpara>We can allow number of segments with same node as context, for instance:</simpara>
		    <programlisting>
			Trans1/Inp ~ : AStatec { Value = "SI 2"; } @ { Inp ~ : ATrcAdd ... }
		    </programlisting>
		    <simpara>There are two segments here, first one uses anonymous state as target context, the second use same node as namespace.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Syntax definintion</title>
		<sect4><title>Do we need mutation_create_with_chromo?</title>
		    <simpara>This mutation is creation of model node and applying assosiated chromo, note this is single mutation.
		    Currently this mutation is valid but same result can be achieved by using simple mutation_create (without chromo) plus
			segment with the created node as target. So the reasonable question is if we really need this mutation_create_with_chromo?</simpara>
		    <simpara>Yes, we do. One of the reasons is that syntax production for model_spec cannot be unabmigous in case of using segment. Indeed the
			full substitution of mutation_create_with_chromo is :</simpara>
		    <programlisting>
			Name : Unit &lt; {
			chromo
			}
		    </programlisting>
		    <simpara>But this also can be defined as (and this is what is real root chromo after model creation):</simpara>
		    <programlisting>
			Name : Unit;
			Name {   (or Name &lt; {)
			chromo
			}
		    </programlisting>
		    <simpara>This makes systax productions quite complicated.</simpara>
		</sect4>
		<sect4><title>Initial (EBNF)</title>
		    <programlisting>
			model_spec = segment | mutation_create_chromo;
			chromo = chromo_node { node_separator, chromo_node };
			chromo_node = ctx_mutation | segment | segment_target | segment_namespace | ctx_mutation_create_chromo;
			ctx_mutation = [context, separator ]  mutation;
			ctx_segment = segment_target | segment_namespace;
			ctx_mutation_create_chromo = [context, separator ] mutation_create_chromo;
			segment_namespace = context_namespace_ext, [separator], segment;
			segment_target = target_primary_segment, [ target_secondary_segment ];
			target_primary_segment = context_target_ext, [separator], segment;
			target_secondary_segment = impliclit_context_unit, [separator] segment;

			segment = '{', [separator], chromo_node, { node_separator, chromo_node }, [separator], '}';

			(* Mutation Create with assosiated chromo *)
			mutation_create_chromo = mutation_create, [separator], segment;

			context = (context_target, context_namespace) | context_target | context_namespace;
			context_target = (uri | special_name_nearest_namespace | special_name_nil), separator, "&lt;";
			context_target_ext = (uri | special_name_nearest_namespace | special_name_nil | mutation_create), separator, "&lt;";
			context_node = mutation_node;
			context_namespace = uri, separator, "@";
			context_namespace_ext = (uri | mutation_create), separator, "@";
			implicit_context_unit = context_type;
			context_source = mutation_node | node_uri;

			separator = white_space | end_of_line;
			white_space = ' ';
			end_of_line = ;

			(* Ref <xref linkend="ds_cli_pi_ms"/> for the improvement proposal *)
			mutation = (mutation_create | mutation_content| mutation_remove | mutation_import
			| mutation_connect | mutation_disconnect | mutation_rename | mutation_move | mutation_comment), ';';
			mutation_create = [name, separator] ":" separator, parent;
			parent = uri;

			#ifdef _DCE_
			mutation_content = [ node_uri, separator ] "=" separator, content_value;
			#else
			mutation_content = [ content_uri, separator ] "=" separator, content_value;
			#endif // _DCE_
			content_value = string;

			mutation_import = "+" separator, module_uri;
			node_uri = uri;
			module_uri = uri;
			content_uri = uri;
			node_name = name;
			mutation_remove = "!" separator, node_uri;
			(* There is alternative variant, where the target should be owner of node being removed:
			mutation_remove = "!" separator, node_name;
			*)
			mutation_comment = "#", separator, string
			mutation_connect = uri, separator, "~", separator, (uri | mutation_create_chromo | mutation_create | segment_target | segment_namespace);

			name = letter, { letter | digit | "_"};
			special_name = special_name_nearest_namespace | special_name_nil;
			special_name_nearest_namespace = "_@";
			special_name_nil = "_";

			uri = [name], { "." , name }
			string = '"' { symbol } '"';
		    </programlisting>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_dsa"><title>Design of chromo language syntax analyzer and compiler.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ref_ss_cof"/> for studying of basics of syntactic analysis and compiling.</simpara>
		<simpara>Ref <ulink url="https://en.wikipedia.org/wiki/LL_parser"/> for LL(k) parser wiki.</simpara>
	    </sect3>
	    <sect3><title>Can recursive descent parser be used?</title>
		<simpara>As mentioned in <xref linkend="ref_ss_cof"/>:</simpara>
		<programlisting>
		    Ð ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ñ‹Ð¹ ÑÐ¿ÑƒÑÐº â€” ÑÑ‚Ð¾ Ð´ÐµÑ‚ÐµÑ€Ð¼Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´ Ð½Ð¸ÑÑ…Ð¾Ð´Ñ-
		    Ñ‰ÐµÐ³Ð¾ Ñ€Ð°Ð·Ð±Ð¾Ñ€Ð° ÐšÐ¡-ÑÐ·Ñ‹ÐºÐ¾Ð², Ð¿Ð¾Ñ€Ð¾Ð¶Ð´Ð°ÐµÐ¼Ñ‹Ñ… LL(1)-Ð³Ñ€Ð°Ð¼Ð¼Ð°Ñ‚Ð¸ÐºÐ°Ð¼Ð¸.
		</programlisting>
		<simpara>But is the grammar of Cromo2 language LL(k)?</simpara>
	    </sect3>
	    <sect3><title>Syntactic analyiss based on recursive descent parser</title>
		<sect4><title>Intro</title>
		    <simpara>Ref <xref linkend="ref_ss_cof"/>, chapter "Ð¡Ð¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· ÐšÐ¡-ÑÐ·Ñ‹ÐºÐ¾Ð² Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼ Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ ÑÐ¿ÑƒÑÐºÐ°" for the theory.</simpara>
		    <simpara>Ref <ulink url="https://en.wikipedia.org/wiki/Recursive_descent_parser"/> for wiki material.</simpara>
		</sect4>
		<sect4><title>Predictive parser vs table-based parser.</title>
		    <simpara>There are two variants of parsing: predictive parser ("Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ ÑÐ¿ÑƒÑÐºÐ°" in <xref linkend="ref_ss_cof"/>) and
			table-based parser ("Ñ‚Ð°Ð±Ð»Ð¸Ñ‡Ð½Ñ‹Ð¹ Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð²Ð°Ñ‚ÐµÐ»ÑŒ"  in <xref linkend="ref_ss_cof"/>). </simpara>
		    <simpara>Let's protorype predictive parser first.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_cii_ascl"><title>Agent specific chromo-language (<xref linkend="gls_ascl"/>).</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the chromo is the language of mutation of base agent - Elem in FAP2. So it can be applied for any Elem derived agents.
		    In earlier implementation so called "custom mutations" were considered, for instance the mutation "connect". But later "connect" mutation
		    was included in the base mutations set.
		</simpara>
		<simpara>
		    The drawback of this approach is clear - it doesn't allow to utilize the advantage of core FAP desing prinicple "The model is created by
		    mutating agent." (initially root agent). With current approach it is not possible to have optimized mutation language for agent specific mutation.
		    The idea of the current approach was that there shouldn't be specific mutation and that all cases can be simply covered by mutating the base
		    agent (Elem).
		</simpara>
		<simpara>
		    The question is if there really can be some custom mutations? Seems so. For instance we can constider "transition" agent that 
		    uses compact notations for transition agents, like Add instead of ATrcAddVar.
		</simpara>
		<simpara>
		    Note that FAP2 already support this partially. Indeed, the base agent mutation APIs are virtual so base agent hier can overload
		    the mutation processing.
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_ascl_bdp"><title>Base desing principle of </title>
		<sect4 ><title>Any agents should allow mutating even if the agent can be not allowing derivation.</title>
		    <sect5><title>Intro</title>
			<simpara>
			    FAP2 intoduced two types of agents, mutable and not-mutable. Actually both types are updated via mutation, the only difference is
			    that "non-mutable" agent don't kept its own mutation, so are not derivable in some sense. Instead they are mutated by theirs owners.
			</simpara>
		    </sect5>
		</sect4>
		<sect4><title>Common chromo internal structure.</title>
		    <simpara>
			Chromo is just the data describing the mutations. This data can be represented in different forms. There should be internal chromo 
			representation that is kept in the model any agents. This is important because we can imagine the model where is agent A and its
			compoment B at that mutations of B is B-specific but B is not derivable. So agent A keeps the whole mutation. And even A cannot 
			"understand" B-specific mutation A shall be able to keep them.
		    </simpara>
		    <simpara>
			Also the <xref linkend="gls_osm"/> approach currently applied presumes that models any agent keeps the
			<emphasis>whole</emphasis> chromo, including chromo of it's componetns.
		    </simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2><title>Mutation of root content instead of specific content set mutation.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    FAP2 uses specific content set mutation syntax to define hierarhical content. So FAP2 implements specific parser for this syntax.
		    Probably we don't need this specific parser if we consider content as native hier node that can be mutated. In that case the mutation of 
		    root content node in content nodes hierarchy can be used instead.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_pi"><title>Proposal of <xref linkend="gls_chromo2"/> improvement</title>
	    <sect3 id="ds_cli_pi_ms"><title>To make mutation end symbol (mutation separator) (";") not mandatory.</title>
		<sect4><title>Intro</title>
		    <simpara>I.e. to use the syntax</simpara>
		    <programlisting>
			mutation = (mutation_create | mutation_content| mutation_remove | mutation_import
			| mutation_connect | mutation_disconnect | mutation_rename | mutation_move | mutation_comment), [';'];
		    </programlisting>
		    <simpara>In case of a number mutations in one line the separator is useful and helps recognize the mutations. In many other
			cases the separator is redundant.</simpara>
		</sect4>
		<sect4><title>Problem: mutation mutation_chromo production clashes with mutation_create_chromo.</title>
		    <simpara>For intance:</simpara>
		    <programlisting>
			|  e2 : e1 {
			|     e2_1 : Elem;
			|  }
		    </programlisting>
		    <simpara>is recognized by parser as mutation_create followed by illegal sentence.</simpara>
		    <simpara>Solution: to check mutation_create_chromo first</simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>Implemented. Experimental, ref d65a391ce4b0850e.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_pi_pn"><title>To introduce special pseudo-names</title>
		<simpara>
		    "Special name" approach can help us to make chromo more compact. We already use symbol "$" as special name of "whatewer"
		    in mutation "Comment"
		</simpara>
		<simpara>In some cases it seems usefull to have pseudonames for some special nodes. For instance the pseudoname can be using
		    to explicitly designate namespace: this approach can simplify namespace node direct modifying within the section with namaspace context.</simpara>
		<simpara>Note that some pseudo-name cannot be used in URI in general. For istance nearedt name space is defined in mutation context but
		    not native hier one, so it cannot be used in URI.</simpara>
	    </sect3>
	    <sect3 id="ds_cli_pi_ic"><title>To introduce "Inactivity" context to solve the problem with comments. Or using special target segment.</title>
		<simpara>
		    Ref <xref linkend="ds_cli_icc_cfc"/> for the FAP2 chromo language weakness. To solve this problem
		    we can just introduce new context of type "Inactive". This context applied to the mut or segment just makes it inactive.
		</simpara>
		<simpara>Or, similarly we can introduce special pseudo-name "nil" and use target segment to redirect the number of mutations to "nil"</simpara>
		<sect4><title>Status</title>
		    <simpara>20221224 Implemented special target "nil", ref special_name_nil in chromo language syntax notation.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_pi_scm"><title>Special comment mut for long comment boundary </title>
		<simpara>This is another solution for  <xref linkend="ds_cli_icc_cfc"/>: introduce "begin comment" and "end comment" pseudo-mutations, like </simpara>
		<programlisting>
			# &lt;
			# &gt;
		</programlisting>
	    </sect3>
	    <sect3><title>To introduce segment type depending on context.</title>
		<simpara>
		    For instance the segment type "target" can have "{}" boundaries, but "namespace" segment - "()".
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_pi_dn"><title>To add "depenency" node to chromo run time model.</title>
		<sect4><title>Intro</title>
		    <simpara>Current chromo syntax includes chromo dependency: for instance in mutation_connect right part can be chromo node. This
		    defines mutation_connect dependency on this right part chromo node. But this mutation_connect is compiled into chromo run-time in the manner that
		    dosn't keep such dependency semantic: mutation connect in chromo run-time doesn't have pointer to the dependency but add the dependency node 
			before mutation connect node in the chromo and state this dep uri as mutation connect right part.</simpara>
		    <simpara>Ref <xref linkend="ds_cli_ddmc"/> for details.</simpara>
		    <simpara>Ref <xref linkend="ds_tch"/> for other materials.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Clean-up chromo abstract model (chromo.h)</title>
		<simpara>For instance ENa_Id can be replaced by ENa_P, etc. ENt_Change can be replaced by ENt_Rename with corresponding replacing of ENa_MutAttr and ENa_MutVal</simpara>
	    </sect3>
	    <sect3><title>Do we need multiple context?</title>
	    </sect3>
	</sect2>
	<sect2><title>FAP2 chromo language analysis and criticism.</title>
	    <sect3><title>Do we really need namespace context?</title>
		<simpara>
		    Namespace helps to make transition notation compact with <xref linkend="gls_dmc"/>. But it is still not perfect, ref
		    <xref linkend="ds_cli_icc_uncs"/> for instance. What helps NS context to do in
		    <xref linkend="gls_dmc"/>? Just to compact (i.e. without full URI) specify the inputs in the connectins chain plus have a new segment
		    (this is important to create hierarchical chromo structure that is more readeable that the flat structure).
		    Can we specify it compact in another way?
		</simpara>
		<simpara>
		    Note that the context types actually are not independent. Indeed, the target context means also that target node is also namespace.
		</simpara>
	    </sect3>
	    <sect3><title>Is it OK to use segments for forming connections hierarchy?</title>
		<simpara>
		    FAP2 <xref linkend="gls_dmc"/> uses segments plus namespace context to form connections hierarhy represetation of 
		    hierarchical stype. But is using segments really nesessary?
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_icc"><title>What seems inconvenient in the FAP2 current chromo (<xref linkend="gls_chromo2"/>, <xref linkend="gls_dmc"/>)</title>
	    <sect3 id="ds_cli_icc_uncs"><title>Using namespace context symbol in <xref linkend="gls_dmc"/> chromo.</title>
		<simpara>
		    It needs to be used wastely in case of complex transition.
		    It really seems messy to see a lot of "@" in chromo.
		</simpara>
	    </sect3>
	    <sect3><title>Cannot simply specify chromo of last-created anonymous agent.</title>
		<simpara>
		    It is common case when required to specify some mutation of newly-created anonymous agent in connection heirarchy with
		    <xref linkend="gls_dmc"/>. New chromo syntax (ref
		    <xref linkend="ds_cli_syntax_ss"/>) allows to do it having two subsequent
		    namespace and target segments. However it is not convenient. The solution would be to use special name designating the
		    top namespace agent, like that (compate to
		    <xref linkend="ds_cli_syntax_ss"/>):
		</simpara>
		<programlisting>
		    Trans1/Inp ~ : AStatec @ { _N &lt; Value = "SI 2"; Inp ~ : ATrcAdd ... }
		</programlisting>
	    </sect3>
	    <sect3><title>Comment syntax is too complicated.</title>
	    </sect3>
	    <sect3 id="ds_cli_icc_cfc"><title>Cannot to simply comment out some fragment of chromo.</title>
		<simpara>Ref <xref linkend="ds_cli_pi_ic"/> for soution based on special context or special target.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_sno"><title>Issue: cannot specify namespace in <xref linkend="gls_osm"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    This happens when namespace is specified for segment and some node is created within this segment and mutated then.
		    It's clear that the namespace will be propagated to all muts within the segment.
		    Let's look at what will be the root node chromo after <xref linkend="gls_osm"/> transformation.
		    Mut of newly created node the namespace will be "upper" than the target (target is the newly created node). But specifying "upper" node cannot be
		    done via regular URI (that is relative to the target) but via absolute URI only (absolute URI is also prohibited in chromo.)
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_sno_s1"><title>Solution#1 special mutations for segment start and end</title>
		<simpara>
		    <xref linkend="gls_osm"/> tranform hierarchical chromo to the flat chromo. This is the root-cause of the problem. With flat
		    chromo we cannot keep the namespece in segment mutation (we just don't have segment in
		    <xref linkend="gls_osm"/>. The idea is to have segment mutation in <xref linkend="gls_osm"/> by introducing the mutation
		    for segment start and end (like begin and end keywords
		    in Pascal). Thus the namespace will be stated for segment begin mut but not propagated to segment's "internal" muts.
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_sno_s2"><title>Solution#2 Enable segments in <xref linkend="gls_osm"/></title>
		<sect4><title>Intro</title>
		    <simpara>
			Actually segments dont contradict to OSM. It is just the implementation of muts propagation that converts segments to 
			muts flat sequence. We can keep the serments and propagate them to owners. We need to modify procedure of propagation.
			We need to know that the mutation is propagated in scope of segment.
		    </simpara>
		</sect4>
		<sect4><title>What about propagation "below" segment?</title>
		    <simpara>
			Let's consider the case: node A is mutated with serment MS including namespace. There is A component B.
			Within the segment is mutation M targeted to B. How can we specify namespace of M in B? There is no segment MS in B chromo.
			So ne need to specify namespace explicitly, i.e. we still have provlem with namespace. So this solution doesn't work.
			Again, to correctly support of inheritability of B we need to keep mutation context in B mutations.
			Same problem with solution#1. Both solutions are based on the idea that we can specify context in segment only and
			propagate context implicitly to lower layers.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_sno_s3"><title>Solution#3 Enable namespace for only serments direct mutations. </title>
		<simpara>Seems this limitation solves the original problem. With the limitation  Solution#1 and Solution#2  also shall work.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Issue: weak design of namespace support in <xref linkend="gls_osm"/></title>
	    <sect3><title>Into</title>
		<simpara>The design gaps is:</simpara>
		<itemizedlist>
		    <listitem>Curently only one namespace can be specified in mut. But if we specify namespaces for two nested node that the 
		    "lower" mut will actually have two namespaces applied. How this mut can be represented in <xref linkend="gls_osm"/> form?
			Both namespeces should be specified but just one is supported.</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_eosm"><title>Extended <xref linkend="gls_osm"/> - <xref linkend="gls_eosm"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    Current <xref linkend="gls_osm"/> implementation  generates "inconvenient" bad readeable output chromo. The question is if the approach 
		    can be improved by enabling segments propagation to the output chromo.
		    Ref <xref linkend="ds_cli_sno_s1"/> and <xref linkend="ds_cli_sno_s2"/> that introduce the possible approaches to this.
		</simpara>
		<simpara>Ref <xref linkend="ds_iss_001"/> for related issue.</simpara>
	    </sect3>
	    <sect3 id="ds_eosm_s1"><title>Solution#1 Checking of parent mutation from the mut context.</title>
		<sect4><title>Intro</title>
		    <simpara>The idea is to set the mutation to the chromo at the beginning of the mutation applying. Then
		    apply the owned muatitions from the current node if the current node is the composite mutation. Mutation context of
		    this owned mut applying needs to be modified - add the current composite mutation ref as "owning node". Propagation of owned mutation in
		    onOwnedMutated also needs to be modified: to check if the mutation context "owning node" is alreasy in chormo, in that case
			deny the mut propagation.  </simpara>
		    <simpara>The provlem with this approach is that checking of mutation context is qute complicated. The direct way to do it is just
			search the context ("owning node") in the node chromo so the full traverse thru chromo is required.</simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>I tried to implement it but it didn't work for some reason. So focused on <xref linkend="ds_eosm_s2"/></simpara>
		    <simpara>The solution dev branch is yb_dce_eosm_s1.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_eosm_s2"><title>Solution#2 Checking mutation originator node when propagaring mut</title>
		<sect4><title>Intro</title>
		    <simpara>
			This is similar to <xref linkend="ds_eosm_s1"/> but the mutation context checked on mut propagarion is not
			a parent mutation but mut originator node. Actually this approach is already used in the current
			<xref linkend="gls_osm"/> solution, ref MutCtx::mNode.
		    </simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>Implemented over eed4231d23f6.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_ddmc"><title>Direct <xref linkend="gls_dmc"/> chromo structure - <xref linkend="gls_ddmc"/></title>
	    <sect3><title>Intro</title>
		<simpara>The main idea is that current chromo is actually a complex tree. For instance: Q arg of connection mut can be 
		simple URI. Or it can be dependent on creation mut (in that case the actual Q arg is P arg of this dependent creation mut). Or
		    it can depend on namespace segment, in that case conn mut Q arg is this namespace segment "namespace" context.</simpara>
		<simpara>So there actual relation between connection mut Q arg and another dependent mut parameter. However in the current
		chromo2 implementation this relation doesn't exists explicitly. The relation is implemented via name (ID); the name is resolved
		    on chromo parsing phase and the relation is set.</simpara>
		<simpara>This approach is quite reasonable. In result of <xref linkend="gls_dmc"/> chromo parsing we get simple <xref linkend="gls_osm"/> chromo
		where the dependencies are resolved via the names (ID) substitution and stated in form of name references in the model native hier.
		So what is the problem here? The problem is that the original chromo and
		parsed chromo has different structure. The ouput chromo can be "reused" but its representation is not convenient.
		    The possible solution is to convert it back to <xref linkend="gls_dmc"/> but this complicates the whole process.</simpara>
		<simpara>Is it possible to have chromo structure aligned with the structure of <xref linkend="gls_dmc"/> chromo syntax?</simpara>
	    </sect3>
	    <sect3><title>Solution#1 References of given type to depending mutation.</title>
		<sect4><title>Intro</title>
		    <simpara>Mut include args both as values and references to depending mutation. The reference is typed. The types
		    means what depending mutation parameter the reference is to. Actually we can define default reference for each mutation type and
		    use this default relation type. For instance mut of type "creation" has default relation to name of created node; mut
		    of type "segment" has default relation the name of context (it is assumed that either the name of context is unambiguos,
			i.e eihter the context is single, or same value both for target and namespace).  </simpara>
		    <simpara>It is possible to have the chain of references. For instance connection attr Q references to namespace segment mut
		    (i.e. to namespace context value). The namespace context value in turn references to mut of "creation" type (i.e to 
			name of created node).</simpara>
		</sect4>
		<sect4><title>How to apply the mutation with the reference.</title>
		    <simpara>If the mut being applied has the ref then the ref is applied first.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_ddmc_ues"><title>Soution#2 Using chromo node embedded segment as the relation.</title>
		<sect4><title>Intro</title>
		    <simpara>Actually the chromo node (both of abstract chromo model and chromo2 run-time) already has the relation - node embedded "chromo".
		    This embedded chromo is the list of nodes binded to the given node. Currently this dependency is only of type owning-owned, i.e. all the nodes 
		    in chromo are the nodes that have to be applied into the native hier node created by given chromo node mutation.
			But we can extend the usage of this chromo node embedded chromo: we can use it to keep for instance connection mutation Q-dependent node.</simpara>
		</sect4>
		<sect4 id="ds_cli_ddmc_ues_ics"><title>How we need to improve chromo node structure.</title>
		    <simpara>The proposal is to have the following structure of the node:</simpara>
		    <programlisting>
			|   Ctx ----T--- Mut
			|      \        /
			|       T      T 
			|        \    /
			|        Chromo
			|          /\
			|         /  \
			|        nodes
		    </programlisting>
		    <simpara>Here "Ctx" is context value, "T" - context type, "Mut" - mutation part of chromo node, "Chromo" - chromo part of chromo node.</simpara>
		    <simpara>This node strucure covers all the configuration needed to support current chromo syntax and run-time:</simpara>
		    <programlisting>
			Ctx - Chromo, Mut is not set   - segment_namespace and segment_target with uri as context
			Ctx - Mut, Chromo is not set   - ctx_mutation
			Mut - Chromo, Ctx is not set   - segment_namespace and segment_target with mutation_create in mutation_create
		    </programlisting>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_ddmc_rcdc"><title>Revieving current design of the creation of system</title>
		<simpara>20221230 Trying implement <xref linkend="gls_ddmc"/> - improve chromo structure to have dependency as child node, chromo itself is parsed fine,
		but the creation of system doesn't work properly. So it needs to be also updated. Seems we need to aligned the creation mechanism to the new chromo structure.
		    First we need to review the current design and outline the desing update areas. </simpara>
		<simpara>Ref <xref linkend="ds_rcdc"/> for the details.</simpara>
	    </sect3>
	    <sect3><title>Status</title>
		<simpara>
		    20210417 Decided to postpone the feature. The reason is that the problem with generated chromo output in pure
		    <xref linkend="gls_osm"/> flat format is still not solved, ref <xref linkend="ds_eosm"/>.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_nseg"><title>Named segment</title>
	    <sect3><title>Intro</title>
		<simpara>Use-case_1: some system used <xref linkend="gls_sdc"/> controller to update itself with some chromo segment. The controller
		forms its status (Outp output) by checking system's if the segment is applied (check if there is this serment in the chromo). This checking
		    operation is simple because serments name is supported.</simpara>
		<simpara>Use-case_2: widget system (ref fap3-vis widget.chs); there is base widget system WidgetBase that is just default "template"; specialized
		widget (for instance VLabel) is based on WidgetBase, includes specialized agent (native agent inherited from some base) and adjusts the topology including connections to the agent.
		The agent base already has some connpoints that needs to be connected to the compoments of WidgetBase, but this connection cannot be done in the scope of WidgetBase becaues
		it doesn't include agent. So currently we need add agent and do these connections for any widget in widget system - i.e. the spec is duplicated many time. The solution can be to
		    combine all that connections within single chromo named segment and then apply it in any particular widget.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_errh"><title>Handling of chromo2 syntax errors</title>
	    <sect3><title>Intro</title>
		<simpara>One of errors handling approach is to add special erroneous non-terminals to the syntax.</simpara>
		<programlisting>
		    mutation_content_err_wrong_uri = [ not_node_uri, separator ] "=" separator, content_value;
		    no_node_uri = no_uri;
		    no_uri = ...

		    (* Mutation error: missing separator before mutation keyword *)
		    mut_err_sep_before = (name | uri), mutation_keyword; 
		    mutation_keyword = mutation_create_keyword | mutation_connect_keyword | mutation_import_keyword | mutation_comment_keyword | mutation_content_keyword | mutation_remove_keyword;
		    mutation_create_keyword = ":";
		    mutation_connect_keyword = "~";
		    mutation_import_keyword = "+";
		    mutation_comment_keyword = "#";
		    mutation_content_keyword = "=";
		    mutation_remove_keyword = "!";

		    (* Mutation error: missing mutation separator *)
		    mut_err_missing_sep
		    (* Mutation error: Wrong mutation left part*)
		    mut_err_p
		</programlisting>
	    </sect3>
	    <sect3><title>Using Recursive descent parsing for errors is rather redundant.</title>
		<simpara>The problem seems to be that we are trying to use "negative" non-terminals like "not URI". We try to use existing not-terminal matching function to
		match this non-terminals. So, our meaning of this not-terminals is "the mininal sentence that match it". For instance "a1.a2*blabla" is "not URI" but
		    we match "a1.a2*" as sentence matched. </simpara>
	    </sect3>
	</sect2>
	<sect2><title>How to refer to anonymous nodes in further muts?</title>
	    <sect3><title>Intro</title>
		<simpara>Chromo2 introduced support of anonymous nodes. It helps making chromo more compact and readable.
		    But there is the problem of how to refer anonumous mode in the mutions that goes after anonumous node is created.</simpara>
	    </sect3>
	    <sect3><title>Using generated name of anonymous node.</title>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_rcdc"><title>Revieving current design of the creation of system</title>
	<sect2><title>Intro</title>
	    <simpara>This desing item was caused by <xref linkend="gls_ddmc"/> - chromo new desing, ref <xref linkend="ds_cli_ddmc_rcdc"/> for details.</simpara>
	    <simpara>This section is intended to collect the questions, spots, criticism to the current mechanism system creation.</simpara>
	</sect2>
	<sect2><title>What is the agent chromo: the description of how to create node or of how to change?</title>
	    <sect3><title>Intro</title>
		<simpara>Currently the chromo of the node is mutation_create_chromo, i.e. includes mutation_create part. This actually mean that the agent chromo
		    contain info of how to create the agent, i.e the mutation of the agents owner. Is this reasonable approach?</simpara>
		<simpara>Another approach would be to have the agents chromo as the info of changing the agent. Or may be at least plus the parent.</simpara>
		<simpara>The current approach causes some complication when applying the mutations: we need to use "treat_as_chromo" option of mutation routine
		to separate the mutation mutation_create part from segment. So when some owner creates new owned agent it first applies to itself the 
		    mutation_create part of the mutation and then segment part to the newly created agent ("treat_as_chromo" option is used here).</simpara>
	    </sect3>
	    <sect3><title>Actually both</title>
		<simpara>Mutation part of the node (ENt_Add specifically) is the info of "how to create" but segment part is of "how to change".
		Actually these parts even used with theirs specific aims. 
		This is why in the current implementation MNode::mutate() method contains aTreatAsChromo arg - if true it tells to the routine
		    "take that part of the chromo node that is the set of the agent mutations"</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dce"><title>Dedicated content element of native hier (<xref linkend="gls_dce"/>)</title>
	<sect2><title>Intro</title>
	    <simpara>
		This section if for discussing specific content desing solution. In earlier FAP version the complex content was implemented as
		unit components, i.e. was the part of model native hier. In further FAP versions this was changed - the content was moved from native hier
		to Unit internals, so specific MUnit API was introduced. This idea was to simplify native hier thus to improve the model performance. 
	    </simpara>
	    <simpara>Current FAP3 content designg is not perfect obviously. </simpara>
	</sect2>
	<sect2 id="ds_dce_uc"><title>Use-cases</title>
	    <sect3 id="ds_dce_uc_01"><title>[DCE_UC_01] Function result as content.</title>
		<simpara>
		    There was such technic used to visualize function - dedicated content was created for the function result. This content was
		    observed from UI and visualized in a compact manner (even inside the function agent visial representation).
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_uc_02"><title>[DCE_UC_02] Model visualizatio: content is hidden.</title>
		<simpara>
		    The content is normally hidden when model is visualized. Oherwize the structure were very complex and hard upderstandable.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_uc_03"><title>[DCE_UC_03] Self content</title>
		<simpara>
		    To optimize the model some agents (state for instance) can support content by itself.
		</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Pros</title>
	    <sect3><title>Content language is no needed, chromo language is used instead.</title>
		<simpara>Current design - Conent language. Set content of conn point:</simpara>
		<programlisting>
		    |  Cp : ConnPoint {
		    |      $ = "{ Provided:'Iface1' Required:'Iface2;}";
		    |  } 
		</programlisting>
		<simpara>Embedded to native hier, content items to be created (Prop is the base Property agent):</simpara>
		<programlisting>
		    |  Cp : ConnPoint {
		    |      Provided : Prop = 'Iface1'; Required : Prop = 'Iface2;
		    |  } 
		</programlisting>
		<simpara>One more example of <xref linkend="gls_dce"/> - Debug property.</simpara>
		    |  Agt : AStatec {
		    |      Debug : Prop {
		    |          Update = "yes";
		    |          LogLevel = "20";
		    |      }
		    |  }
	    </sect3>
	</sect2>
	<sect2><title>Cons</title>
	    <sect3><title>Requires native hier node for each content.</title>
	    </sect3>
	    <sect3><title>Content owner needs to sign up for observing content nodes change.</title>
		<simpara>
		    In current FAP3 solution native CP of ContentOwner alredy has method of notification. With new approach we need to utilize
		    standart node notification mechanism.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dce_dso"><title>Design outline</title>
	    <sect3><title>MCont iface and Content node</title>
		<simpara>
		    We need to introduce new elements of native hier - node. Node can just support owner-owned relation and have content.
		    Aslo dedicated iface "MCont" needs to be defined to support property (i.e. content). It makes sense that normal agents doesn't implement.
		    Agent Prop is implemented this iface. Prop can owns other Props only. 
		</simpara>
	    </sect3>
	    <sect3><title>Content nodes (properties) are distinguish from ohter nodes.</title>
		<simpara>
		    We need to means of distinguishing of MCont node from other. This is required to process properties in a separate manner, ref use-cases
		    <xref linkend="ds_dce_uc_01"/>,  <xref linkend="ds_dce_uc_02"/>
		</simpara>
	    </sect3>
	    <sect3><title>Content provider specific mutation - "set value"</title>
		<simpara>
		    Interesting but if keeping content is the ability just Content nodes then the mutation "Content" gets only MCont specific, ref
		    <xref linkend="ds_cii_ascl"/> for related desing item.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_dso_coi"><title>Do we need to have also iface for content owner?</title>
		<simpara>
		    This iface could be indented for nodes that owns content provider. The iface could contain FAP2-like content API -
		    to get content by name, URI etc. Potentially this will be simple wrappers over narive hier and MCont but potentially the iface
		    can make content desing more clear.
		</simpara>
	    </sect3>
	    <sect3><title>How to notify of content change.</title>
		<simpara>
		    <simpara>
			Current FAP Unit supports notification of content changed and agent changed. How this will be desingned in 
			<xref linkend="gls_dce"/>
		    </simpara>
		    <simpara>
			Ref <xref linkend="ds_itr_sp_rnac"/> regarding re-desing of notification scheme. There will not be dedicated notif of 
			    content change. Instead it is up Prop owner to observe the notif of Prop change and generate it's own "Changed" notif.
		    </simpara>
		    <simpara></simpara>
		</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_chmc"><title>Creating heir: using mutation context.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 the problem of mutating of "temporary" nodes (ref
		<ulink url="../../../grayb/doc/design/index.html#ds_daa_itn"/>) is solved with solution 
		<ulink url="../../../grayb/doc/design/index.html#kds_daa_itn_sfo"/> - mutation context is used. Is this solution suitable with FAP3 dsign?
	    </simpara>
	    <simpara>On FAP2 the problem initially was with distributed models - in such model Uid() is used as node ID so the regular ID based on native hier
		doesn't work for temp nodes not attached to hier yet.</simpara>
	</sect2>
	<sect2><title>Why dont't attach the heir to the parent.</title>
	    <simpara>From the first glance it is ok just to attach the hier to parent before mutating by parents chromo. However this straighforward
		approach has some drawbacks. Firt one is that attaching the hier shall cause the IRM tree invalidating. This can cause a big overhead especially
		if parents chain is quite long.</simpara>
	</sect2>
	<sect2><title>Keep current solution but have context as MOwner.</title>
	    <simpara>So we can use the current solution - using the context. The only change would be to have context as MOwner to restrict the access.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_urd"><title>URI re-desing</title>
	<sect2><title>Use-cases</title>
	    <sect3><title>URI can designates both absolute and relative path to node.</title>
	    </sect3>
	</sect2>
	<sect2><title>Design outline</title>
	    <sect3><title>Absolution vs relation.</title>
		<simpara>Absolute URI has mostleft relation symbol.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Do we need designation of the current node?</title>
	    <simpara>Currently the "current node" URI is just the empty URI. This is reasonable for URI is just the "path" to the node,
		empty path means "no need to go, you are already here".</simpara>
	</sect2>
	<sect2><title>Do we need designation of the root node?</title>
	</sect2>
    </sect1>

    <sect1><title>Chromo of element: Node or Segment?</title>
	<sect2><title>Intro</title>
	    <simpara>
		Originally the chromo of element is the mut of Node type. It contains name and parent. The idea was that the chromo should be
		the whole info to create this elem. But this logic is not quite reasonable - actually Node mut is the mut to create the node and add it
		to the owner as its comp. Node mut is the mut of the owner actually. What is the mut of element itself is the segment of this Node mut -
		it is the mut the has to be applied to elements parent to get the element.
		So the question is if we need elem chromo to be Node mut or segment?
	    </simpara>
	    <simpara>In other words: what is chromo of element: mut of adding the element to owner or mut the element parent? </simpara>
	    <simpara>The rationale of Node variant is that it tells "Get the given parent and mutate it via given segment".</simpara>
	</sect2>
    </sect1>

    <sect1 id="sec_att"><title>Is it possible to avoid using "attached" property.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 the
		<xref linkend="gls_osm"/> mutation solution uses agent "attached-to-chromo" property to decide if the agent mutation
		    needs to be propagated or not. However this property is rather trkcky calculated. The question is if this property
		    is fundamental part of
		<xref linkend="gls_osm"/> mutation process or can be replaced by simpler mechanism.
	    </simpara>
	</sect2>
	<sect2><title>Approach#1: using mutation context.</title>
	    <simpara>
		"Deattached" agents are the agents created by parent in the scope of parents creating its hier. So if we set mutation context as 
		the created hier then we can use the context to stop propagating the mutation.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_f2dw"><title>FAP2 design gaps and weaknesses</title>
	<sect2 id="ds_f2dw_isr"><title>Ifaces identification scheme is restricted.</title>
	    <simpara>In <xref linkend="gls_fap2"/> the only ifaces have identification. The focus was to provide native hier creating iface (MUnit) with
		safe identification mechanism. Other ifaces are identified via MUnit identification plus iface type - so the identifiation scheme is restricted,
		there is no rule to identify given iface in case of MUnit node includes number of ifaces of same type.
		Ref <xref linkend="ds_uinn_id"/> for the desing consideration.</simpara>
	</sect2>
	<sect2 id="ds_f2dw_ccnu"><title>Creating complex native unit is not supported safely</title>
	    <simpara>It is often required to create "complex" native unit, adding componentes, changing context etc. This is more effective that create
		the unit spec in module. But this direct creation of "complex" native unit is not supported properly.</simpara>
	</sect2>
    </sect1>

    <sect1><title>Giving "Changeable" ability to Node</title>
	<sect2><title>Intro</title>
	    <simpara>
		Currently the only MElem is truly mutable, even Unit also can be changed. It make sense to generalize mutable/changeable desing.
		We can give changeable ability to lower layer, havng method "Mutate" in it. The method actually will change but not mutate
		(the term "Change" designates here the ability to be changed but not propagate this change to childs).
	    </simpara>
	</sect2>
    </sect1>

    <sect1><title>Having pre-created Root node in the model.</title>
	<sect2><title>Intro</title>
	    <simpara>
		Currently the root is created via rather tricky procedure: env gets it's parent from chromo and creates it. More reasonable
		would be just pre-create "true Root" and then mutate it with given chromo.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_adcm"><title>Avoid necessity of having dedicated chromo for mutation in inheritable agents.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 base inheritable agent Elem contains two chromo: one for mutation and another for chromo of itslef. This creates overheads in
		design. 
	    </simpara>
	</sect2>
	<sect2><title>The reason why it was designed that way in FAP2</title>
	    <simpara>
		There is known dilemma in mutable agent - what is the change object - mutation (
		<xref linkend="gls_cam"/> approach) or chromo (list of mutations) (
		<xref linkend="gls_cac"/> approach). In FAP2 it was assumed
		    the the change object is chromo. So the design was corresponding: there was emvedded "mutation" member of Chromo type. Incoming
		    mutation went to this chromo and then the whole chromo was applied.
	    </simpara>
	</sect2>
	<sect2><title>Initial design considerations</title>
	    <sect3><title>Can be the dilemma solved in favor of "change is mutaion"?</title>
		<simpara>
		    Current desing of Chromo2 allows mutation containing chromo. Each mutaion node contains chromo segment. So let's
		    apply <xref linkend="gls_cam"/> for FAP3.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_adcm_pamcc"><title>Problem with applying mutation_create_chromo.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Wiht <xref linkend="gls_cam"/> in FAP3 the problem occurs whent we apply mutation_create_chromo. To apply
			this mutation we need to apply "create" mutation first and then the embedded chromo as segment. But for
			that we need to transform the given mut to segment. Current chromo design doesn't allow to do it properly till
		    <xref linkend="ds_mcrc"/> is not done. 
		</simpara>
		<simpara>There are two options: #1 to disable mutation_create_chromo at all, #2 to have <xref linkend="ds_mcrc"/> done and 
		    transform mut to segment in mutAddEem. Let's use workaround ATM, ref code Node::mutate() aTreatAsChromo param.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mdc"><title>Modify DES cycle to avoid polling the comps but keep the lists of active/updated in owner.</title>
	<sect2 id="ds_mdc_sw"><title>[Impl] Avoid copying active/update lists elems. Using active/update lists swap approach.</title>
	    <sect3><title>Status</title>
		<simpara>20230401 Initial implementation, experimental.</simpara>
	    </sect3>
	    <sect3><title>Intro</title>
		<simpara>Using base active/updated lists approach was implemented and verified. Even having a number of cons against
		    "MDesSyncable polling thru owneds" approach this "active/update lists" approach can be improved further.</simpara>
		<simpara>In the current implementation each MDesSyncable from "active" list inevitably goes to "update" list thru the
		    setUpdated() Des method. So on Update phase completed "update" list is the copy of "active" list (copyed elem by elem).
		    We can just swap the lists on Update phase completion and then clean "active" list.</simpara>
		<simpara>Same design idiom was used to improve updated/confirmed data in State, ref <xref linkend="ds_desopt_ums"/>.</simpara>
	    </sect3>
	    <sect3><title>Verification</title>
		<sect4><title>Fap3-vis ut_avr_vert_drp_2_chs model, 5 vert cycled.</title>
		    <simpara>Original variant run time: 8.5s, optimized: 8.4s (note that switching off rendering gives us 6.8s)</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mcrc"><title>[DS_MCRC] Redesign chromo to make it really copyable.</title>
	<sect2><title>Intro</title>
	    <simpara>Let's apply the simplest solution. We just need to update ChromoNode to be copiable - just replace ref to model by 
		ptr to model. Also a number of small updates of chromo2 is needed.</simpara>
	</sect2>
	<sect2><title>Status</title>
	    <simpara>Implemented in next of 0297b38cfca8.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_tch"><title>Keep consistent tree-ish chromo on run-time.</title>
	<sect2><title>Intro</title>
	    <simpara>Currently (0297b38cfca8) the chromo of created model differs from the original chromo - the resulted chromo
		is not same fully tree-ish as the original chromo. For instance the mutation. Ref ut_des_dmc_1.chs as example.
		Input chromo:</simpara>
	    <programlisting>
		|  St1.Inp ~ : TrAddVar @ {
		|      _@ &lt; Debug.LogLevel = "Dbg";
	    </programlisting>
	    <simpara>Resulted chromo (ut_des_dmc_1_saved.chs):</simpara>
	    <programlisting>
		|  TrAddVar_279 : TrAddVar;
		|  TrAddVar_279 @ {
		|      _@ &lt; Debug.LogLevel = "Dbg";
	    </programlisting>
	    <simpara>Actually there are two problems here:</simpara>
	    <itemizedlist>
		<listitem>
			#1 Input tree-ish chromo is parsed into non-treish chromo2. Chromo2 model is not tree-ish.
		    <para>Ref <xref linkend="ds_tch_c2nt"/> for analysis</para>
		</listitem>
		<listitem>#2 Tree-ish chromo is not suitable for simple <xref linkend="gls_osm"/> mutation scheme.</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_tch_c2nt"><title>Input tree-ish chromo is parsed into non-treish chromo2. Chromo2 model is not tree-ish.</title>
	    <sect3><title>In chromo2 the dependencies are resolved.</title>
		<simpara>The tree-ish structure of input chromo is caused by the dependencies within the chromo. The main
		    dependency is on the node that shall be created by some mutation. In the example above this node is
		    anonymous node TrAddVar_279.</simpara>
		<simpara>Currenly this dependency is resolved on chromo parsing phase, so the node creaton mutation is "extracted"
		    from the tree and node name is use for dependency resolution. This allows to keep the current "linear"
		    sequence of mutation: one by one.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_tch_c2t"><title>Approach: make chromo2 model fully tre-ish, remove ChromoNode wrapper and used chromo2 directly</title>
	</sect2>
    </sect1>

    <sect1 id="ds_ams"><title>Agents mechanism support</title>
	<sect2><title>Intro</title>
	    <simpara>We have <xref linkend="ds_sn"/> implemented in FAP3. So now the MOwner interface doesn't provide the MNode iface to 
		node components. How can we support embedded agents desing approach in that case? Agents normally requires full access to 
		agents manageable host.</simpara>
	</sect2>
	<sect2><title>Solution#1 Special connection point for agents.</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to have dedicated interfaces for agent and host (there is already iface MAgent defined for agents) and
		    dedicated connection point in system and agents to connect them. MOwner APIs needs to be extended by the method of
		    connecting agent or better to introduce interim iface to connect (it is not proper idea to add the method to MOwner iface
		    that doesn't know of agents at all). So the agents will request the owner to connect is as agent.</simpara>
	    </sect3>
	    <sect3><title>How restrictions policy can be applied.</title>
		<simpara>With this approach the system (host) can decide if it accepts connection request from agent or not. This mechanism can
		    be even extended - the system can ask some agents to accept connecting new agent. So we can simply customize the policies with 
		    special agents.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_imp"><title>Redesign import</title>
	<sect2><title>Intro</title>
	</sect2>
	<sect2><title>Parent's resolution mechanism.</title>
	    <sect3><title>Intro</title>
		<simpara>It is very important to simplify specifying parent in system chromo. The best way is to specify just parent's name. But in that case
		    we need to specific mechanism to resolve parent by its name.</simpara>
		<simpara>Refer issue <xref linkend="iss_008"/> for the related issue.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_asr"><title>State activation on input provided ifaces change - Activation on System Reconfiguration (<xref linkend="gls_asr"/>)</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <ulink url="../requirements/index.html#fap3_uc_ica"/> for use-case</simpara>
	</sect2>
	<sect2><title>Design solution: using <xref linkend="gls_irm"/></title>
	    <simpara>
		First idea was that corresponding "source" state has to notify the destination state of input updated. But the use-case is that
		the state has to be activated even in case of connection removing. So seems the most sutable design solution at the moment is to use
		<xref linkend="gls_irm"/>. We just need to add notification on IRM node invalidation event.
	    </simpara>
	    <simpara>Tried this approach, seems it is not working. The number of problems were discovered, <xref linkend="ds_asr_pnc"/> and more.</simpara>
	</sect2>
	<sect2><title>Design solution: using DES input observer interface.</title>
	    <simpara>This solution seems simple. Actually what we need is to notify any DES change via this interface. But there are use-cases showing this 
		approach limitations, ref ut_des_asr_2.chs - connpoints here are not connected directly but via sockets. So this pure approach neither doesn't work.</simpara>
	</sect2>
	<sect2 id="ds_asr_cbs"><title>Design solution: update detection via IRM and notification via DES inp observer.</title>
	    <simpara>We can use the "combined" solution: to get the event of unit change via IRM and then use DES inp observer net to activate DES.</simpara>
	    <simpara>However, see the problem caused by this solution.<xref linkend="ds_asr_cbscpd"/></simpara>
	</sect2>
	<sect2 id="ds_asr_pnc"><title>Issue: IFR MDesInpObserver path is not created from constant.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref test/ut_des_asr_1.chs. ASR doesn't work for this test. The root-cause is that MDesInpObserver path is not created for 
		    Const_1 because "confirm" doesn't try to notify, the constant state is not updated actually - both updated and confirmed values are equal.</simpara>
		<simpara>State (and const state also) notifies the inp observers on "value" content set, but the problem here is that at content set moment
		    the Const_1 is not connected so IFR path isn't formed.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_asr_cbscpd"><title>Using DES inp notification on connpoint irm invalidation causes significant performance degradation.</title>
	    <sect3><title>Intro</title>
		<programlisting>
		    void CpState::onIfpInvalidated(MIfProv* aProv)
		    -   {
		    |       ConnPointu::onIfpInvalidated(aProv);
		    |       notifyInpsUpdated();  
		    |   }
		</programlisting>
		<simpara>
		    This problem relates to the problem with performance degradation in configurable systems, ref
		    <xref linkend="ds_irm_wprc"/>.  Layered control solution was proposed to solve, ref
		    <xref linkend="ds_dcs_sl_lsc"/>. Test Ut_deslsc::test_DesLsc_2 was created for LSC.
			With this test removing the inp notification in CpState::onIfpInvalidated() reduces the run time from 5s to 0.1s.
			(of corse this change causes UT ut_des_asr_2 failure.)
		</simpara>
		<simpara>Looking at the MDesInpObserver notification - the notifications are issued a big number of times. It show that
		    the current scheme of DES notifying of structure changed is not optimal and needs to be changed.</simpara>
	    </sect3>
	    <sect3 id="ds_asr_cbscpd_ahoi"><title>Interim solution: avoid handling invalidation ifaces other that MDVarGet</title>
		<simpara>Currently CpState notifies DES inputs irrespectively to iface. But the notification actually does make
		    sense only if MDVarGet iface gets invalidated. So we can just avoid notif in case if iface isn't MDVarGet.</simpara>
		<simpara>Performance metrics for Ut_avr::test_VertDrp_2:</simpara>
		<programlisting>
		    Was:
		    2       IFC_U_INV       17656   0.000001        0.071789        2.938181        0.000166        0.001650        0
		    1001    IFC_LNCH_RUN    1       4.335055        4.335055        4.335055        4.335055        0.000000        0

		    Now:
		    2       IFC_U_INV       16444   0.000001        0.005683        0.422340        0.000026        0.000124        0
		    1001    IFC_LNCH_RUN    1       2.381778        2.381778        2.381778        2.381778        0.000000        0
		</programlisting>
		<simpara>This solution is interim and doesn't cancel LSC approach.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dcs"><title>DES control of system (<xref linkend="gls_dcs"/>)</title>
	<sect2 id="ds_dcs_itr"><title>Intro</title>
	    <sect3 id="ds_dcs_itr_cs"><title>The current solution: mutation via DES adapter.</title>
		<simpara>Currently (ca30980a3dae3) the controlling of system is used in some tests and apps - some subsystems are mutated by another subsystem via DES.
		    The "naive" approach was used to implement such controlling: managed sybsystem is considered as DES (i.e. represents itself via "states" where the "states" are
		    even native elements of subsystem, for instance its components), managing DES just gives controling data (mutation) to managed subsystem.</simpara>
		<simpara>Even this schema looks reasonable it still causes the questions:</simpara>
		<itemizedlist>
		    <listitem><xref linkend="ds_dcs_itr_nrd"/></listitem>
		    <listitem><xref linkend="ds_dcs_itr_sna"/></listitem>
		    <listitem><xref linkend="ds_dcs_itr_sar"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_dcs_itr_nrd"><title> Mutation as "controlling data" is not a regular DES data but an action.  </title>
		<para>First of all its nature is impuls: controlling subsystem needs to remove the mutation data as soon as it is done. This is not something
		    wrong, there are the models where "impulse" data is used sometimes, especially for representing "events" - mouse button press for instance.
		    However this "events" approach causes a lot of inconvenieces. With it DES controlling looks like the typical computer program - just
		    the sequence of the "commands".</para>
		<para>Is this really the problem. From the first glance it is not. This seems almost same as simple incrementor - new incrementor status is the
		    current status plus delta. In case of mutation the new controlled subsystem status is the current status (current structure) and the changed defined by
		    the mutation.</para>
	    </sect3>
	    <sect3 id="ds_dcs_itr_sna"><title>Controlled subsystem is not activated on mutation</title>
		<simpara>It was analogy to incrementor discussed in <xref linkend="ds_dcs_itr_nrd"/>. But there is the difference: controlled subsystem is not
		    activated on the mutation.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_itr_sar"><title>Special adapter is required DES control a subsystem.</title>
		<simpara>Using the adapter isn't convenient. Morover it is possible to "attach" more than one adapter to the subsystem. There aren't any policies to
		    avoid the possible conflicts when some controlling subsustems try to control same controlled subsystem.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>DES controlling phiylosophy: object as data</title>
	    <sect3><title>Intro</title>
		<simpara>
		    DES controlling (
		    <xref linkend="gls_dcs"/> needs to be considered in the scope of DES nature:
			updating the states data via transormation of the data of
			dependencies. The only specific of DES controlling is that the data to be updating is the controlled object.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_ucs"><title>How to support update-confirm scheme when controlling system</title>
	    <sect3 id="ds_dcs_ucs_itr"><title>Into</title>
		<simpara>
		    DES architecture is based on update-confirm principle: current sytem state is updated (calculated new state value) basing on "freezed"
		    confirmed data. Current DES
		    desing implements the current-new system state via update-confirm pattern. Confirmed data is the current state whereas updated data is new state.
		    This desing is compact and effective in case of updating regular data. But how this pattern can be apply to updating system structure?
		</simpara>
		<simpara>
		    Let's distinguish "system data" and "system structue data". "System data" is the data of system states. "System structure data" is the data
		    representation of system structure. There could be different representation. For instance system chromo is one of them.
		    Obviously it is wrong to update system structure on update phase - this would make the update process not deterministic because the system structure
		    can be changed at any time during update. This would be OK if we had the same solution for system structure data as for system data. System data is 
		    "double buffered" - on update phase updated not state value but buffered one. But this solution hardly possible for system structure data.
		    Updating system structure on confirmation phase is also wrong because the structure update depends on some system data but the data can be
		    change on confirm phase, the double buffering copy is not deterministic here.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_ucs_cip"><title>Current implementation - a problem.</title>
		<sect4><title>Intro</title>
		    <simpara>
			How the problem with system structure update is solved at the moment (239ba130a63)? Node adapter is used for updating system structure - the update
			performs via system mutation. Adapter performs the mutation ON CONFIRMATION PHASE. It is assumes that the mutation formed by DES depens on system data only
			but not system structure date. So on update phase the system structure is unchanged. But the problem is (!!) with system structure update on confirmation
			phase: the system data on what the mut depends can change during confirmation phase (it depends on the sequence of system states confirmation).
		    </simpara>
		    <simpara>In other words: if there are a number of system structures are dependent one on another and being updated simultaneously
			they also need to follow current-new scheme. Doing system structure modification on confirmation phase works only in case if the system structure
			is independent!</simpara>
		    <simpara>The previous NodeAdp implementation perfored the system mutation on update phase. But is also was wrong because the change of system structure
			affects the system states so affects the process of update depending states.</simpara>
		    <simpara>Another problem is that system data depends on system structure so it needs to be studied if system structure change affect system data confirmation.</simpara>
		</sect4>
		<sect4><title>Solution : to buffer the mutation</title>
		    <simpara>We can avoid the system mut dependency from system data by buffering the mut. With that approach NodeAdp updates and save mut on update phase and
			apply the buffered mut on confirm phase.</simpara>
		</sect4>
		<sect4 id="ds_dcs_ucs_cip_ib"><title>Solution: using inputs buffering instead of state data buffering.</title>
		    <simpara>Let's consider two dependent system that needs to be changed: S1 and S2 and let's try to change them.
			Actually the dependencies can be interpreted as dependencies on some parameters of system, but not on whole system.
			For instance S2 depends on P1(S1), ... Pn(S1)
			and vice versa. These parameters (i.e. data) are the inputs of transition S2_T performing S2 change. We can freeze these inputs on confirmation phase.
			In this case S2_T inputs will be stable during S2 update. </simpara>
		    <simpara>This inputs freeze scheme was considered earlier (fapws?) also for data but that time state data freeze was choose because it is more effective -
			if some state is connected to N inputs then inputs freeze approach needs N double buffering instead of just one for data freeze.</simpara>
		    <simpara>Actually this solution aleady attempted to be applied in the current DES controller implementation,
			ref dessdc.h::SdcIapb and dessdc.cpp::ASdc::confirm() -
			inputs are freezed (confirmed) before controller controlling action. However this implementation is wrong -
			if we consider two dependent systems S1 and S2 then
			the confirmation is performed one to another. This means that for instance S1 handle confirmation first then S2. S1 params (i.e. S2 inps) are freezed on
			S2 confirmation. So S2 will be updated with NEW (not current) S1 params.
			The result will be affected (in common cases) by confirmation order (S2, S1 vs S1, S2) </simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_sl"><title>Using special layer for controlling systems (<xref linkend="gls_lsc"/> approach).</title>
	    <sect3><title>Intro</title>
		<simpara>On initial times of DES design there was the idea of how such systems can be controlled. The idea was that specific layer needs to be used.
		    This layer considers underlying layer (controlled) as a data (same manner as regular DES considers states simple data as a data).
		    This means that controlling layer defines controlled layer via some data
		    (it should be structured data and complex enough). In fact this data is the static description of the structure of the controlled layer.
		    In contrast of chromosome this description doesn't specify the system in "dynamic" manner (i.e. via the chromo - spec of changes the sytem)
		    but statically, as existed structure. There shall be the transitions that can manipulate with such definitions, for instance delete one 
		    branch in sytem hierarchy etc.</simpara>
	    </sect3>
	    <sect3><title>This is just another form of the current solution</title>
		<simpara>At the first look this seems same as <xref linkend="ds_dcs_itr_cs"/> but different form. With special layer the controlling subsystem
		    update is DES standard: the data (controlled system definition) is modified in the proper transition that the controlled system "apply" this
		    data to it controlled model (i.e. changes the model). In DES adapter there is no explicit transition. Instead, the adapter performs "the transition" via
		    direct changing (mutating) of the controlled system. The only diff is <xref linkend="ds_dcs_itr_sna"/> - this causes the different behaviour.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_sl_dbo"><title>DES based objects</title>
		<simpara>This philosophy can be interpreted with another manner - we can create object which chromo (or some another equivalent of structure
		    representation) parts are states. Obviously this will be "higher" level objects, that can be called "DES based" objects.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_sl_lsc"><title>Layered system control (<xref linkend="gls_lsc"/>) as the solution of system performance issue.</title>
		<sect4><title>Intro</title>
		    <simpara>Ref <xref linkend="ds_irm_wprc_lsc"/> for the issue description and initial analysis.</simpara>
		    <simpara>The system performance is degraded because of a lot of IRM invalidation and related to that DES inputs notifications. This
			mechanism supports DES actual with re-configuration performed but makes the system run slower.</simpara>
		    <simpara>The idea is to extend MDesSyncable with pause/resume/run so controlling system can use this method to manage controlled system.
			Controlling system shall be on "upper" layer in term that it can manage controlled system via SDCs. So controlling system
			stops controlled system, makes all controlled system re-configuration, performs IRM invalidation and DES inp notification and then resumes the 
			controlled system again.</simpara>
		</sect4>
		<sect4><title>How to "perform IRM invalidation and DES inp notification"?</title>
		    <simpara>
			This insists that we need to disable IRM invalidation and DES inp notification before staring the control of manageable system. But there are no
			proper mechanism of how to disable them. One solution is to just remove DES inp notification from CPs onIfpInvalidated
			but this will lead to "normal" systems not working (ref
			<xref linkend="ds_asr_cbscpd"/>) 
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sl_hil"><title>How to implement LSC layers?</title>
		<sect4 id="ds_dcs_sl_hil_s1"><tite>Solution#1 Managed subsystem owned by managing subsystem.</tite>
		    <simpara>
			One approach is to have managed agent adapter, then keep managed subsystem MSS inside so the adapter points to owned MSS and then
			managing subsystem inside the adapter.
		    </simpara>
		    <simpara>
			With this approach we have simple access from managing subsystem to managed one.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sl_nti"><title>What needs to be improved for applying LSC approach</title>
		<sect4><title>Intro</title>
		    <simpara>
			Current design is not optimal for using LSC approach. For instance it assumes that special "Managed agent adapter" needs
			to be used to give controlling part access to managed part.
		    </simpara>
		</sect4>
		<sect4 id="ds_dcs_sl_nti_sa"><title>Simpify managed agent adapter (DAdp agent)</title>
		    <simpara>Currently the adapter agent needs to be linked to some owner of managed system. Link agent is used for that linking.
			It works ok but create some overhead in case if managed subsystem is owned by the adapter itself. This can be simplified:
			adapter can assume that ower of managed system is adapter itself in case if link is not established.</simpara>
		</sect4>
		<sect4><title>Managing subsystem is "flat" in the current solution. Needs to have it in hier form. </title>
		    <simpara>Let's look at the solution <xref linkend="ds_dcs_sl_hil_s1"/> - it is not possible to create hierarchical managing
			subsystem here because any <xref linkend="gls_sdc"/> agents became access to managed agent via owner (adapter in our case). </simpara>
		    <simpara>We need some solution that allows creating complex enough, hierarchical managing subsystems.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_cssd"><title>System update: chromo vs system structure data.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the mut is used to update system structure via Node DES adapter (NodeAdp). But this solution is not convenient - the mut is specific
		    data and we need to form this data via rather complicated transition. What is the alternative? It is the solution where system structure data
		    is represented as simple data, for instance boolean data that represened the sign of some component of the system. Updating this data to true
		    means that system shall create that compoment.
		</simpara>
	    </sect3>
	    <sect3><title>System structue data is just another representation of Node DES adapter.</title>
		<simpara>
		    Indeed, the structure data can be implemented in the scope of adapter with adding specific inputs, outputs and internal modules.
		    Morover the system structure update via structure data finally uses mutation - we just don't have another way to change system structure.
		</simpara>
		<simpara>
		    However these two approach differs from usage point of view. With NodeAdp we need to form the sequence of mutations with complex transitions. System structure
		    data potentially can be implemeted as separate DES. Let's call this DES "system data controller". In that case With system structure data we can create two
		    controllers. There is an argument that we could create two adapters with embedded system data controller feature, but this would be rather expensive. Another
		    way is to create controller in the adapter.
		</simpara>
		<simpara>
		    Actually forming mutation for adapter is not true DES approach - in most cases we form just the sequence of mutations. With DES approach we shouldn't use
		    the sequence by set mutation depending on some valuable data (not just sequence counter).
		</simpara>
	    </sect3>
	    <sect3><title>System DES controller</title>
		<simpara>Ref <xref linkend="ds_dcs_sdc"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_sdc"><title>System DES controller (<xref linkend="gls_sdc"/>).</title>
	    <sect3><title>Controller as controlling system agent.</title>
		<simpara>
		    It is the common case that controlling DES is implemented right in controlled DES. We can intoduce specific agents - 
		    <xref linkend="gls_sdc"/> to simplify the control. This agent input on one hand form "query" to managed system so the query provides
			boolean result (for instance, for "Comp" controller that creates new comp there are inputs "Name", "Parent" that forms the query
			"Is there component of type "Parent" and name "Name"). Let's call the query result as "output" of controller.
			On another hand the inputs forms control action - "Comp" controller creates the component.
			Controller also contains special boolean input "Enable" that enables the contolling action.
			Such controller scheme allows to create the controlling DES more convenient. One controller output connects to another controller
			"Enable" input so DES-stype dependencies are simply established.
		</simpara>
		<simpara>The main idea of this approach is "distributed" nature of controlling : there can be complex controlling scheme that includes
		    many controlling agents. The agents forms "standard" DES via connecting one to another.</simpara>
	    </sect3>
	    <sect3><title>How to control "remote" system.</title>
		<simpara>
		    Another case is when controlled system is not direct owner of controller. The solution here can be collect the controllers in
		    special host DES where we can provide controllers with "environmental" access to controlled system. This "environmental" access can
		    be implemented as the link to managed system that (this link is "known" to controllers). If we need to support more comples use-cases
		    (for instance the main case of modnav - select managed sub-system via navigation thru given system) then we can create custorm host DES that updates this 
		    link to managed system in same manner as DES adaptor does.
		</simpara>
	    </sect3>
	    <sect3><title>Controller can be implemented as non-native agent</title>
		<simpara>
		    Indeed, we can have controller as a system that includes adapter to managed system. The control action can be done via
		    the mutation thru the adapter, the controller output can be formed via specific functions getting data from the adapter.
		</simpara>
		<simpara>
		    The problem here is that the adapter performs the mutation on confirmation phase but the sequence of confirmation is not
		    detarministic: some inputs can be changed.
		</simpara>
	    </sect3>
	    <sect3><title>Controller native implementation.</title>
		<simpara>
		    Native implementation can help to avoid the problem with non-deterministic inputs update on confirmation phase, see the problem
		    description above.
		</simpara>
	    </sect3>
	    <sect3><title>"Multi-client" controlling.</title>
		<simpara>Major benefit of SDC solution is that the controlling of target system can be performed from many points of the model. It is
		    similar to "client-server" approach. However we can see the potential problems here. Let's look at fap3-vis DContainer. It embeds the 
		    controlling syb-system that allows to add widget. DController expose specific socket as an input to this subsystem. Also the controlling status
		    output is included into the socket.</simpara>
		<simpara>But what is we need that DContainer control performs from tho parts of the model? How to support this?  </simpara>
		<simpara> The firt approach is to 
		    pull out this controlling subsystem from DContainer. In that case we can create two controlling sybsystem for each controlling 
		    parts ("clients"). However we need to support such "remote" controlling providing the controlling system with access to managed system like it
		    is done for DES adapter. Also it is not nice solution. The controlling DES is specific for DContainer so it would be architecturally more
		    correct way to have controling system incapsulated into container.</simpara>
		<simpara>Another solution would be to keep controlling subsytem inside DContainer but provide the container with means of creating other such
		    controling subsystem (again via controloing of DContainer.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_sdc_acc"><title>One more note about using change on confirmed phase with buffering inputs on update phase.</title>
		<simpara>
		    There was a number of discussion regarding DES "movement" design. Ref
		    <xref linkend="ds_dcs_ucs_itr"/>
		    Normally we use two-phase scheme (update-confirm) for that:
		    we calculate new values of states on update phase (the transition inputs are freezed) and freeze the values on confirm phase.
		    There is another approach - to calculate new value on confirm phase.
		</simpara>
		<simpara>In case of <xref linkend="gls_dcs"/> the important point is that the update-confirm scheme used for state simple data is
		    not convenient for controlling where the "data" is the whole controlled system. Obviously it is not possible to keep two instances of
		    data - confirmed and updated.</simpara>
		<simpara>Note that currently even simple state update mechanism is optimized, ref <xref linkend="ds_desopt_ums"/> but with this optimization
		    there are still two data instances.
		</simpara>
		<simpara>Why we need two instances"? Actually it is not necessary. What we actually need is to keep freezed current data when we 
		    calculate new value. In case of <xref linkend="gls_dcs"/> we can freeze not whole current data (i.e. not whole managed system structure)
			but just parts of it that are required to calculate the change to managed system.
			This is more simple. In that case we can freeze data on controling system transitions inputs.
			It is already discussed in <xref linkend="ds_dcs_ucs_cip_ib"/>. So the current note is just highlighting of that solution.
		</simpara>
		<simpara>
		    There were many doubts that the scheme described above (mutating controlled system on confirmation phase) is not complied with 
		    standard scheme used for simple DES.
		    But actually this approach fully conforms to the "classic" simple DES update-confirm. Simple DES prepares the change on update phase and applies
		    the change on confirm phase. Same is performed with the scheme described above: "prepare change" means prepare all inputs that required to
		    perform mutation, "apply change" means perform mutation.
		</simpara>
		<simpara>It was clarified that using combines scheme (true update-confirm for system data and mut on confirmation for system structure) has
		    the problem, ref <xref linkend="ds_dcs_ucs_cip"/>. But this problem can be avoided with approach <xref linkend="ds_dcs_sl_lsc"/>.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_sdc_uc"><title>Use-cases</title>
		<sect4><title>[<glossterm id="uc_sdc_01">UC_SDC_01</glossterm>] Loading the pipeline</title>
		    <simpara>The first data is loaded the pipeline (for container example it is that Name value is set for IoAddWidg.Enable input)
			- The controlling chain is completed (for container example it is that the widget was added and last SDCs in the chain sets outp Outp to true)
			- New Name is set to pipeline input - the controlling chain creates new widget successfully.</simpara>
		    <sect5><title>Discussion</title>
			<simpara>This UC seems not valid. Ref <xref linkend="uc_sdc_05"/> for another UC that seems more reasonable.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_02">UC_SDC_02</glossterm>] Controller doesn't change system in case of DES Inp notification comes but inputs are not changed actually</title>
		    <simpara>The first data is loaded the pipeline (for container example it is that Name value is set for IoAddWidg.Enable input)
			- The controlling chain is completed (for container example it is that the widget was added and last SDCs in the chain sets outp Outp to true)
			- Some controller input (for instance IoAddWidg.Name) gets DES inp notification comes but the input data is not changed actually (this can happed
			especially if the input connects to some function output and func input is changed but doesn't cause func outp change actually)
			- Controller doesn't change the system.</simpara>
		    <sect5><title>Discussion</title>
			<simpara>This means that controller is not sensitive to "fake" input change. In regular DES such feature is not needed - in case of 
			    "fake" change DES just recalculate it't states (they keep unchanged in result). But for SDC it is inportant because the controller DES data
			    is not simple data, controller changes the system structure incrementally. </simpara>
			<simpara>But do we really need this? Ponentially controller can avoid incorrect system update via checking if the system is updated already.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_03">UC_SDC_03</glossterm>] SDCs form right control trigger</title>
		    <simpara>
			There is the pipeline of SDCs: SDC_1 (creating node_1), SDC_2 (creating node_2), SDC_3 (removing node_1), SDC_4 (removing node_2).
			SDC_4 triggering condition is SDC_3 status (Outp). This mean SDC_4 is to remove node_2 only after node_1 is removed. 
			System starts, SDC_3 formal condition is met (because on this phase node_1 doesn't exitst). SDC_4 gets correct trigger only creating and then removeing node_1.
		    </simpara>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_04">UC_SDC_04</glossterm>] Creating/removing component in cycle</title>
		    <simpara>
			There is the pipeline of SDCs: SDC_1 (creating component "Comp"), SDC_2 (removing component "Comp").
			SDC_2 triggering condition is SDC_1 status (Outp). This mean SDC_2 is to remove component "Comp" only after SDC_1 has created the comp. 
			SDC_1 triggering condition is SDC_2 status (Outp). This mean SDC_1 is to create component "Comp" only after SDC_2 has removed the comp. 
			System starts and run N ticks - SDCs create and remove component "Comp" N times.
		    </simpara>
		    <sect5><title>Notes</title>
			<simpara>Ref ut_dessdc.cpp:test_Sdc_3 (ut_sdc_3.chs) for correspoiding unit test.</simpara>
			<simpara>Ref <xref linkend="ds_dcs_sdc_dsgn_os"/> for desing item.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_05">UC_SDC_05</glossterm>] Controller change system when being notified thru "Enable" inp event inp value is not changed</title>
		    <simpara>The direct specifying this case is rather exhausted. Ref fap3/test/ut_sdc_2.chs for the model. This UC contradicts to <xref linkend="uc_sdc_01"/></simpara>
		    <simpara>PRECONDITIONS</simpara>
		    <programlisting>
			There is the model that contains 3 SDCs: SDC_Comp - creation component - list node, SDC_Insert - inserting the node into the list,
			SDC_Extract - extracting the node from the list. The model insert/extract the node in the cycle. To do this SDC_Insert trigger ("Enable" inp)
			depends on the switch that initially is switched to SDC_Comp status and then, after insertion switches to extraction status.
		    </programlisting>
		    <simpara>STEPS</simpara>
		    <programlisting>
			#0 - link node is created
			#1 - insertion trigger is ok (switcher on status of creation). Node is inserted.
			#2 - insertion status is OK, i.e. extraction trigger is OK. Switcher is still on status of creation (OK). Extracted.
			#3 - Switcher on extraction status - OK, i.e insertion trigger is still 1. Expecting that insertion SDC performs the control.
		    </programlisting>
		    <sect5><title>Discussion.</title>
			<simpara>Acc to <xref linkend="uc_sdc_01"/> the insertion on #3 cannot happen because the trigger value is not change.</simpara>
		    </sect5>
		    <sect5><title>Design</title>
			<simpara>Ref <xref linkend="ds_dcs_sdc_dsgn_oin"/> for the desing</simpara>
		    </sect5>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sdc_dsgn"><title>Pipelined controlling. Design of native SDC</title>
		<sect4><title>Intro</title>
		    <simpara>The tipical system controlling consists of number of SDCs combining in a chain so that some controlling operation happens depending on
			"previous" operation gets completed. This structure actually creates controlling pipeline. The example is the adding the widget into vis container,
			refer to fap3-vis/modules/container.chs. Initial SDC design already contains support of such pipeline - there was input "Enable" and "Outp" output:
			The current SDC depends(inp Enable) on previous SDCs completion (out Outp).  Such structure however posesses its specific use-cases and design specifics.</simpara>
		    <simpara>Ref <xref linkend="ds_dcs_sdc_uc"/> for the pipeline specific use-cases.</simpara>
		</sect4>
		<sect4><title>Controlling phase</title>
		    <simpara>SDC changes the controlled system on Confirmation phase.</simpara>
		</sect4>
		<sect4><title>Inputs buffering</title>
		    <simpara>To support of controlling on confirmation phase the controller buffers all the inputs. Ref fap3 6db8376c3f3e:src/dessdc ASdc::Iap desing
			(mUdt, mCdt etc).</simpara>
		    <simpara>
			Is this really needed? Why not just get the inputs data on confirmation phase when controlling? This is the support of
			<xref linkend="uc_sdc_02"/>. But as stated in the UC discussion there are other desing solution for that.
		    </simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_idp"><title>Inputs data pipeline in SDC</title>
		    <simpara>
			<xref linkend="uc_sdc_01"/> assumes that next pipeline chain proceeds reacting the data from previous one. For instance for the container example SdcConnWdg
			    reacts on same IoAddWidg.Name that previous SDCs (CreateWdg, AddSlot) are reacting. But SdcConnWdg "V1" input cannot be connected directly to IoAddWidg.Name.
			    This is because this input can be changed after CreateWdg is done. So we need to have SdcConnWdg "V1" input same data that CreateWdg was reacting. 
			    The solution here is to pipeline the IoAddWidg.Name data also. For that we need to have IoAddWidg.Name corresponding output OutpName so input data is copyind
			    to output.
		    </simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_cc"><title>Forming status. Taking into account the completion of controlling.</title>
		    <simpara>Ref <xref linkend="uc_sdc_03"/> for the use-case.  </simpara>
		    <simpara>The desing supporting this use-case is that we need to form pipeline controllers status with taking into account that the sign of controlling completion.</simpara>
		    <sect5><title>Status</title>
			<simpara>This feature is disabled because of clear indication that the use-case is not valid. Alternative design Solution#2 is used - to check the status before 
			    performing the control.</simpara>
		    </sect5>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_os"><title>Controller observs controlled system status and notifies inputs of Outp (SDC status) changed.</title>
		    <simpara>Ref <xref linkend="uc_sdc_04"/> for the use-case.  </simpara>
		    <simpara>Controller needs to notify controlling status (Outp) change on controlled system change. For that controller needs to observe controlled system.</simpara>
		    <simpara>It is not obvious consideration but without this notification the cycle scheme described in use-case doesn't work. The root-cause of this problem is that for 
			instance SDC_1 doesn't notify SDC_2 on status update when SDC_2 removes the comp thus the controling system sticks.</simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_oin"><title>Controller updating on inps notifications even input value not changed</title>
		    <simpara>Ref <xref linked="uc_sdc_05"/> for the UC</simpara>
		    <simpara>Main Solution#1 is simple - just enable control if inp was notified even its value is unchanged.  </simpara>
		    <simpara>Alternative Solution#2 is to set SDC as updated (i.e. enable performing control) if controlled system data observation
			(MagDobs) gets the event. The idea is that the event means the status can be changed, so we need to recalc the status and
			perform the control if status isn't met.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_sdo"><title>System DES oberving (<xref linkend="gls_sdo"/>) </title>
	    <sect3><title>Intro</title>
		<simpara>Very often we need to observe the controlled system when creating controlling DES. Sometimes status functions embedded to SDC is enough, but in many cases
		    we need separate functions to get controlled system status.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_aes"><title>Design: access to explorable system</title>
		<sect4><title>Intro</title>
		    <simpara>SDO needs the access to explorable system. By default any owned components don't have an access to their owners. Same problem is actual for DCS. Current DCS
			design utilized MAgent interface that allows DCS (i.e. agent) to have the acces to its owner. However this solution is not far from perfect. This is because MAgent interface
			was not introduced for such purpose as system controlling. Instead it is just to establish "trusted" relationship between agent owner and agent so the agent can play the
			role of owener "consiliary". Fro instance owener event redirects IRM requests to its agents.  So MAgent iface is too "heavy" for the purpose of observing.</simpara>
		</sect4>
		<sect4 id="ds_dcs_aes_acp"><title>Soution: Owner accessibility controlled by owner props</title>
		    <simpara>The idea is to utilize MOwner local iface resolution mechanism to provide an access depending on owner props. For instance if owner property "Explorable" equals "y"
			then MOwner provides owned with iface allowing exploring of the owner.</simpara>
		    <simpara>The potential problem here is that this access is given for all owned compoments that expose the vulnerability. We can solve this problem using IRM mechanism instead
			of local iface resolution. With IRM the requestor (owend) gets accessible to the owner so the owner can set some restriction. For instance the restriction can be that the owner
			request some iface (kimd of MExploring) from the requestor.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sdo_owi"><title><xref linkend="gls_sdo"/> operating with ifaces. Ifaces identifying in <xref linkend="gls_sdo"/></title>
		<sect4><title>Intro</title>
		    <simpara> It is required to represent iface in systems DES controlling (<xref linkend="gls_sdc"/>) and observing (<xref linkend="gls_sdo"/>).
			Such DES operate with ifaces as if they are data. To support this, ifaces are represented by identificator. Currently (20220705) URI is used for that. But URI doesn't indentify the iface but
			just MNode underlying. Operating with MNode in SDO is not secure, more correct is to operate with ifaces. In that case we also need to use iface identification (UID) for 
			idenffying ifaces.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sdo_gmn"><title>Use-case: getting MNode by MVert in SDO </title>
		<sect4><title>Intro</title>
		    <simpara>The use-case is as: DES controlling fap3-vis columns layout checks if columns exist. For that it uses first SdoPair to get the pair of the 
			layout "End" connpooint. SdoPair needs to get URI of its pair (note currently URI is used as iface identificator in SDO) but it's not possible to get URI from pair (MVert).
			To do that we need to get MNode first that is prohibited. Controlling DES then needs to get name of the pair, but this required getting MNode from
			MVert that is prohibited.</simpara>
		    <simpara>The noce solution here would be to enable the owner (i.e. SDO system under exploring (SUE)) to get MNode from MVert. Potentially we could extend
			MIface::getLif() method passing owner as the argument. But this solution looks ugly.</simpara>
		    <simpara>Currently there is a workaround: MVert gets MUnit - for ConnPoint iface resolution allows getting MNode:</simpara>
		    <programlisting>
			void ConnPointu::resolveIfc(const string&amp; aName, MIfReq::TIfReqCp* aReq)
			-   {
			|       MIface* ifr = MNode_getLif(aName.c_str()); // Local
			|-      if (ifr) {
			||          addIfpLeaf(ifr, aReq);
			||      }
		    </programlisting>
		    <simpara>Actually this workaround can be improved - resolveIfc() can check context and enable MVert in case if context is MNode owner. But the problem here that
			MUnit iface resolution doesn't know from what iitial iface (MVert from instance) was the request.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_cda"><title>Composite DES adapter as the context for controllers and observers.</title>
	    <sect3><title>Intro</title>
		<simpara>Currently [5734b4e935a0, 20220403] the initial desing of DES adapter is in usage - tha adapter is monolitic and iface specific
		    (MNode, MElem etc). This design has the number of cons: it makes overhead (not all CPs are used etc. So we consider another desing - 
		    comopsite adapter. With this desing the adapter itself provides the context for owning controllers and observers. The main part of the context
		    is the link to managed agent.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_ord"><title>DCS example/test - ordering of agents.</title>
	    <sect3><title>Intro</title>
		<simpara>We need to create numberer of examples to discover the weaknesses of the current DCS approach and find the proper solutions. The first
		    example is ordering of agents.</simpara>
		<simpara>The model is as "fap3/test/ut_adp_dcs_1.chs".</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Activating system via implicit dependencies.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    It is normal case in the system using controlling when the controlled system (i.e. system + adapter) depends on itlself implicitly. The example is
		    <xref linkend="ds_dcs_ord"/> - the system is mutated with transition that gets system itself (acually internal connections) as input.
		</simpara>
		<simpara>In contrast of typical DES there aren't explicit dependencies, e.g states that depends each other.</simpara>
		<simpara>
		    The question is how to understand if subsystem depends on another subsystem (or even on itself) if threre aren't explicit dependencies?
		    Let's look at the example
		    <xref linkend="ds_dcs_ord"/>: how to get known if controlled system (Root.Launcher) depends on itself via the mutating
			transition?
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_trs"><title>DCS transaction</title>
	    <sect3><title>Intro</title>
		<simpara>Let's consider an example: DContainer adding widget. It is DCS SDC solution that includes 4 SDCs: CreateWdg, CreateSlot, ConnectSlot, InsertSlot.
		    What if some SDC fails, lets say InsertSlot. In that case we will have the managed system messed: there will be created widget, new slot but the widget
		    will not be shown. It is clear that we need to consider all these 4 SDCs as the single controlling DES. It looks like the transaction in database
		    solutions.  </simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_iui"><title>Inputs update indication</title>
	    <sect3 id="ds_dcs_iui_itr"><title>Intro</title>
		<simpara>Let's look at FAP3-VIS VertDrp for the primary use-case. In VertDrp there is subsystem that positions the CRPs. This subsystem gets the inputs of CRPs params "CrpPars".
		    Then the subs iterates thru the inputs and performs poistioning for each CRP. But what is CRP pars changed during the iteration? In that case we need to reset the iterator and
		    start the positioning process from scratch. The question is of how to get this CrpPars inputs update indication in "DES compatible" form that allows us to use it as
		    reset data.</simpara>
		<simpara>Even if the problems seems simple it is not. The first thinking is that we can use some DES level subsystem to form this indication basing solely on MDesInpObserver 
		    notifications. But this seems not reachable - the notification just indicates the updates so subsystem states re-calculates its value. I couldn't find the universal way of 
		    implementing the update DES indication using solely DES elements. The only solution I invented is getting data form the input and form the data change indication.
		    So to have universal method we need creating specific native agents to get the indication.</simpara>
		<simpara>So there are at least three approaches in creating such native agent: </simpara>
		<itemizedlist>
		    <listitem>Data change indication (depends on data type), ref <xref linkend="ds_dcs_iui_dci"/> for details</listitem>
		    <listitem>Transition that gives the data "hash", ref <xref linkend="ds_dcs_iui_tgh"/> for details.</listitem>
		    <listitem>State like agent that exposes bool -inp changed- indication, ref <xref linkend="ds_dcs_iui_sla"/> for details.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_dcs_iui_dci"><title>Data change indication (depends on data type)</title>
		<sect4><title>Intro</title>
		    <simpara>This is the straightforward solution. It is used in ut_des_utl_2.chs, ref ChgDetector_Neq. If the input is mutiiface then trans like TrAddVar can be used
			to get "common" data.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_iui_tgh"><title>Transition giving the input data hash</title>
		<sect4><title>Intro</title>
		    <simpara>The idea is to form the inputs hash and expose it in form of DES integer data. The data then can be used in DES to form hash change bool indication.
			Actually this is almost same as detecting the data change method mentioned in <xref linkend="ds_dcs_iui_itr"/> but kind of universal, i.e. not depends on
			    the particular data type.
			    The cons of this approach (comparing with "State like agent" is that it can be used in cases where we need to form the change indication not just for 
			    the whole input data but form the component of the data (the component of tuple for instance). This case if quite often. For instance VertCRP forms pairs most left
			    position by iterating pairs params. The params is the tuple but the iterator checks the only one comp of the tuple - column pos.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_iui_sla"><title>State like agent that exposes bool -inp changed- indication</title>
		<sect4><title>Intro</title>
		    <simpara>The cons is that it is not possible to form the change indicator for container compoment, other solution allows this.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dbg"><title>Debugging</title>
	<sect2><title>Intro</title>
	    <simpara>The following improvements can be considered: </simpara>
	    <itemizedlist>
		<listitem>
		    Unify the usage of debugging level 
		    <para>
			Currently the debugging level is almost unusable. Also in parallel the property "Update" is used to
			specify the particular logging feature to log the state update whereas it is just specific logging level.
			So we need to get rid of using the Update property.
		    </para>
		</listitem>
		<listitem> Logging level forcing to owned, ref <xref linkend="ds_dbg_llf"/> </listitem>
		<listitem>Using symbolic values for logging level, lile "Dbg.1"</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_dbg_llf"><title>Logging level forcing to owned</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to provide the system developer the ability to quick set the logging level for the whole system or its part.
		    Currently the logging level is set locally for the particular node only and doesn't affect the other nodes, even the owneds.</simpara>
		<simpara>Ref <xref linkend="ds_log_elc"/> for details.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dbg_sfll"><title>Symbolic form of logging level</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to set logging level in symbolic form like "Dbg.2" where "Dbg" is the name of level and "2" is the extension.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Tips</title>
	    <programlisting>
		p Dbg::getElem(this)->Chromos().Root().Dump()
		p Dbg::getElem(mEnv->Root())->Chromos().Root().Dump()
		p Dbg::getElem(mEnv->Root()->getNodeS("S1"))->Chromos().Root().Dump()
	    </programlisting>
	</sect2>
    </sect1>

    <sect1 id="ds_log"><title>Logging</title>
	<sect2 id="ds_log_elc"><title>Hierarchical logging control</title>
	    <sect3><title>Status</title>
		<simpara>20230329 Initially implemented.</simpara>
	    </sect3>
	    <sect3><title>Intro</title>
		<simpara>The current design of FAP logging means is not completed - it allows to control the logging the only local native hier node. 
		    Ref <xref linkend="ds_dbg_llf"/> for the enhancement proposal.</simpara>
	    </sect3>
	    <sect3><title>Local and Owned levels</title>
		<sect4><title>Intro</title>
		    <simpara>In the FAP any system is the native hier where logging decision is the responsibility of node. This means that we need to
			distribute the "global" setting thru native hier to have global affect. So the idea is to introduce node specific content
			"Owned Logging Level" that sets logging level for all node owned by the given node.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_iis"><title>Setting initial invalid status of State</title>
	<sect2><title>Intro</title>
	    <simpara>It is the common case when we need to set the initial "invalid" value to State. For instance quite often we need to define state signature, i.e SS but
		we don't want to set the value that can cause system movement, so currently we use something like "SS nil" assuming that the value "nil" has to be specifically handled
		(but actually it is not). It would be good if we have support setting of kind of "invalid" or "value-is-not-set" value. Current State desing doesn't allow doing that. </simpara>
	    <simpara>Not sure that currently supported by data "invalid" indication is suitable for such puproses. This indication currently interpreted as error.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_dee"><title>DES elements embedded</title>
	<sect2><title>Intro</title>
	    <simpara>Often it is required to create monolitic native DES specialized for the given usage. Such solution allows
		significantly inclrease the overall system desing effectiveness. There were already many local solutions for that, ref
		ASdc, AAdp etc. for instance. Having this local solution causes the code duplication and problems with support.
		So it is time to provide the proper framework for this solutions.  </simpara>
	    <simpara>The main idea of having DES embedded elements is to interfit native DES with DES agent's internal desing.</simpara>
	</sect2>
	<sect2 id="ds_dee_ssi"><title>Double buffered input</title>
	    <sect3><title>Intro</title>
		<simpara>The base DES desing states that we need to update the state value on Update phase and then actualize (confirm) it
		    on Confirm phase. But sometimes we can use another way for embedded solution. Let's consider tipical DES adapter (ref desadp.cpp):
		    the adapter embeds "Managed agent" (MAG) state. With standard desing we need to have adapter input "MagUri" that value points
		    to MAG relatively to MAG base and dedication state "MAG". Adaprer gets activated thru "MagUri" input notification (confirm phase)
		    and set "MAG" state as activated, then on Update phase form preliminary MAG value and then on next confirm phase actualize
		    the "MAG" value</simpara>
		<simpara>This scheme assumes two embedded entities (input and state) and native connections between them.</simpara>
		<simpara>Alternative option is to have double buffered input. In that case the "MagUri" input is fixed on confirmation phase.
		    On confirmation phase the adapter can just check if new MagUri is confirmed and apply it to MAG. The pros of this variant
		    is that state transition can be implemented in host that simplify the code.</simpara>
		<simpara>Note that local transition (ref <xref linkend="ds_dee_sac"/> is the alternative solution, probably more elegant (this
		    is questionable).</simpara>
	    </sect3>
	    <sect3 id="ds_dee_ssi_vgd"><title>Solution as the variant of DES generic desing</title>
		<simpara>Let's look at "Dedicated states ..." solution from DES generic desing point of view. Currently the DES cycle is based on
		    calculate new states values in Update phase (states freezed), confirm states and notify deps on Confirm phase - states are double-buffered,
		    states are freezed on Update.</simpara>
		<simpara>But there was alternative desing, that we considered on earlier fap2 (or even fap1) projects. This desing is to freeze transitions
		    inputs instead of states: calculate new states values in Update phase (inputs freezed), confirm inputs and notify deps on Confirm phase - inputs are
		    double buffered, states are freezed on conirm phase.</simpara>
		<simpara>This "Double buffered input" solution follows exactly such approach. The problem here is that for double buff inp solution DES cycle is
		    inverted the question is of how to align the parts working with contradicted phases. This problem can be simply solved in case of 
		    "embedded" states - DES just can control Confirmation phase: update the double buff inputs on early stage of confirm phase (so freeze them) and
		    then do the standart Confirm processing.</simpara>
	    </sect3>
	    <sect3><title>Solution as embedded state connected to host input</title>
		<simpara>The double buffered input above can be also intepreted as the embedded state connected to host input. Probably this intepretation is
		    simpler that <xref linken="ds_dee_ssi_vgd"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dee_sac"><title>Sharing DES agent context to transitions.</title>
	    <sect3><title>Intro</title>
		<simpara>It is common case when we decide to move some part of DES functionality into "internal" native desing because the transitions depends on
		    internal agent context. The example is fap3-vis widget: requisition states depends of font size but the transition depends on C++ font instance created
		    in the scope of the agent. The idea of how to solve this is to keep fap3 DES style topology but give the agent context to the transition.</simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_ait"><title>Solution: Exposing agent interface to transition.</title>
		<simpara>This solution is base of IFR. Currently owner in fap3 native hier provides local MUnit iface. This allows a transition to request
		    some iface from the owner (actually in case of DES agent the owned system will route the request to the agent). So we can introduce the generic
		    MDestContext interface that a transition can use for access to agent's resources. This iface IFR can provide access to the agent specifically
		    defined iface, in case of fap3-vis widget example is can be MWidgetContext that resolves all the dependencies from the agent for the transition.</simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_asp"><title>Solution: creating binded transition via agent's specific provider.</title>
		<simpara>The idea is to pass the context to the transition on transition contstruction phase. This can be done with using agent specific provider.
		    Currently it is possible for the agent to register it's own provider via env addProvider(). Such provider can create the transition and pass the context
		    pointer to transition instance on creation phase. It that case the agent just implements MProvider interface.</simpara>
		<simpara>The potential problem here is that adding the provider affects global behaviour. Can we improve Env providers mechanism to have "local" provider?
		    Yes, ref <xref linkend="ds_lps"/> for the design. </simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_taee"><title>Node: Embedded transition as the alternative of other DES embedded elements.</title>
		<simpara>
		    Let's again consider the use-case: fap3-vis widget (widget.h) needs to update embedded font instance depending on font path state. Initial
		    solution was to utilize Buffered input DES embedded element, ref
		    <xref linkend="ds_dee_ssi"/>. With this solution we need to add embedded elements
			support to widget agent (this is quite a lot of code). Alternative solution would be using local scope transition: we have state FontPath, state
			FontApplied and local scope transition "ApplyFont" that containts the agent content and updates (re-creates) the embedded font instance.
		</simpara>
		<simpara>The question here if this scheme provides better understanding of the system. From my view embedded elems still makes system better undertstanding.
		    this is because the transistion "hides" the actual context so it is hard to see that the transition changes the context of agent.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_lps"><title>Improving provider iface to limit the provider's scope</title>
	<sect2><title>Intro</title>
	    <simpara>Curently MEnv iface allows any agent in native hier to register provider, ref MEnv::addProvider(). This creates the vulnarability: local agent can
		affect the whole system by creatng improper node. We need to close this hole.</simpara>
	    <simpara>Ref <xref linkend="ds_dee_sac_asp"/> for the use-case.</simpara>
	</sect2>
	<sect2><title>Solution: add the context indication to provider iface.</title>
	    <simpara>The idea is to extend MProvider API by adding getContext() method. This method will return the node of native hier in which scope the provider is actual.
		If the context is root then the provider is "global" for the system. Note that currently root is available from env but this needs to be disabled.
		Node mutation methods shall check this context when creating node. If the method see that provider tries to create node in the upper scope the method
		needs to deny the creation.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_mtc"><title>Mutation as a transaction</title>
	<sect2><title>Intro</title>
	    <simpara>Curently the mutation is implemented very primitive: node try to apply the mutation, if mutation fails then the node just record this event into the log.
		The fact of mutation failure doesn't affect the overall mutation process - the node then tries to apply next mutation. This approach ever simple is wrong: 
		in result the inconsistent system can be created.</simpara>
	    <simpara>This problem significantly affects sysetems DES controlling (<xref linkend="gls_sdc"/>). Ref for instance the use-case described in <xref linkend="ds_mtc"/>:
		the controller cannot be sure that the required mutation segment is applied so the controller status is not fully deterministic here.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_dctx"><title>[DS_DCTX] DES context for components</title>
	<sect2><title>Intro</title>
	    <simpara>It is abundant use-case where some DES needs to share some context for its components. The example is fap3-vis Detail Representation (DRP). DRP
		creates a number of compact representations (CRP) to visualize represented agent's components. Each CRP needs info of the component it is representing: link to the whole
		model and component's URI related to this model. This info can be provided to CRP via connections but it creates significant overhead.</simpara>
	    <simpara>So the idea is to create the mechanism that can be used to establish such connection "automatically" OR even allow (in our example) CRP to get access to DRPs 
		states containing this info (this creates actually "virtual" connection that does't require such resources as explicit connection.</simpara>
	    <simpara>This feature requirements can vary. At the moment we can limit them by just sharing a socket. So the feature in that case looks like as:
		DRP has "shared" socket, CRP creates compatible socket in it's scope. Crp can use this interal socket as if the socket is connected to DRP socket via
		"virtual" connection.</simpara>
	    <simpara>Actually there is two approaches of creating such "virtual" connection. Approach#1 is to esablish native connection (via native conn).
		Approach#2 is to not establish explicit native connection but use some intermediate ifaces to get access to Provided and Required ifaces, ifaces in that case
		are not persistent but accessible via intermediate ifaces. Actually the intermediate "helper" ifaces are needed even for Approach#1 to establish persistent
		native conn.</simpara>
	</sect2>
	<sect2 id="ds_dctx_dic"><title>Solution#1: dedicated supplier-consumer interface for DES context resolution, explicit connection</title>
	    <sect3><title>Intro</title>
		<simpara>This solution follows Approach#1. We need to introduce the interfaces MDesContextSupplier/MDesContextConsumer for consumer and supplier negotiation and
		    establishing connection. Consumer shall initiate supplier iface resolution. Then as soon as provider iface is resolver the consumer requests
		    binding it's parameters (StateCPs) to correspoinding CPs of supplier.</simpara>
		<simpara>The supplier posseses the number of output CPs and consumer - the number of input CPs. Consumer requests the supplier to connect it's input CPs
		    to the corresponding output CP of supplier.</simpara>
		<simpara>Having both supplier and consumer ifaces assumes that there will be persistent connections between them. The connection is one (supplier) to many
		    (providers).</simpara>
	    </sect3>
	    <sect3 id="ds_dctx_dic_rs"><title>How to resolve supplier?</title>
		<sect4><title>Intro</title>
		    <simpara>There can be a number of suppliers in consumer owning model part. The supplier resolution mechanism depends on the use-cases of context.
			Let's at the moment keep the simplest use-case: consumer resolves the supplier basing on single paremeter. The paremeter can be supplier ID, or given
			property etc. The problem here is that currently IRM doesn't support resolution by name + parameter but by name only. So we need to use two-stager 
			resolution: first we resolve supplier iface by iface name, then select the iface with given paremeter from them. This approach has a number of disadvantages.
			One of them is that the supplier iface resolution tree includes the paths to all suppliers even not matched the parementer. So the number of IRM interactions like
			invalidation grows. </simpara>
		</sect4>
	    </sect3>
	    <sect3><title>How to handle the changes in both parts?</title>
		<simpara>Both supplier and consumer can be changed. One use-case is that supplier adds new CPs that was expected by consumer but messed earlier. </simpara>
	    </sect3>
	    <sect3><title>Supplying restrictions</title>
		<simpara>Do we need to allow any consumer connect to any supplier? Is there use-case where supplier shall provide an access to some specific consumers?
		    We can imagine such use-cases, but is it realistic to implement them? Actually binding by ID is also kind of such restrictions. The massive case is that
		    some system inluceds components from module, this component requires some context with given ID, so it is up to the system to provide the compoment with
		    such context. The component doesn't know ID of other possible contexts.</simpara>
	    </sect3>
	    <sect3 id="ds_dctx_dic_bnd"><title>Context Binding scheme</title>
		<simpara>We assume that there should be automatic binding. This means that we need to specify the rule assosiating supplier ouput an consumer input. </simpara>
		<simpara>Soution_1 is that consumer has components (ctx) as CPs (actually extenders) which the names corresponding to supplier ctx names.
		    Then consumer requests supplier to bind ctx extender.</simpara>
	    </sect3>
	    <sect3 id="ds_dctx_dic_cs"><title>How to resolve same ID suppliers. Dependent context stack.</title>
		<sect4><title>Intro</title>
		    <simpara>It is possible that consumer owners provide more that one ctx suppliers with same ID. How to resolve them? What should be the policies of handling
			this. There is the concrete use-case: fap3-vis widget styles. The owner style can be considered as the context for owned widget. Most often case that
			there is top-level style that can be overriden. </simpara>
		    <simpara>For widget style we can consider the context with same ID  dependent one from another from bottom to top creating context stack.
			Lower level context in the stack (stack head) can override the owner context by implementing specific transition structure. With this approach we need to
			implement contex access policy to resolve lower level supplier. How this resolution policy can be desinged?</simpara>
		    <simpara>Solution_1 is to have supplier iface specific method to get head supplier like getHeadSpl(). With such supplier API the resolution sequence will be as:</simpara>
		    <simpara>Solution_2 is to involve supplier itself in the supplier iface resolution. Supplier shall request owner for ifaces and filter out the upper suppliers
			with same ID.</simpara>
		    <programlisting>
			consumer request owner to resolve suppliers
			owner gives consumer the set of suppliers ifaces (owner resolves it from bottom to top)
			consumer finds the first supplier with given ID and ask it for head supplier
			supplier finds head suppler using getHeadSpl() and gives it to consumer
			consumer registers itself to supplier
			consumer binds context
		    </programlisting>
		    <simpara>As for widgets style the scheme can be as follow (binding Solution_1):</simpara>
		    <programlisting>
			|   OwningWdg : Widget {
			|       Style : CtxSpl {
			|           Color : State;
			|       }
			|       OwnedWdg : Widget {
			|           ColorOverride : State;
			|           Style : CtxSpl {
			|               Style : CtxCsm {
			|                   Color : ExtdStateOutp;
			|               }
			|               Color : TrSvld @ {
			|                   Inp1 ~ ColorOverride;
			|                   Inp2 ~ Style.Color;
			|               }
			|           }
			|       }
			|   }
		    </programlisting>
		    <simpara>Here OwningWdg and OwnedWdg has the context supplier with same ID. OwnedWdg ctx suppiler includes ctx consumer to get overrided ctx (Color) and then
			overrides Color ctx with ColorOverride.</simpara>
		</sect4>
		<sect4><title>Binding in ctx stack.</title>
		    <simpara>What if head supplier does't override the context? In that case it should redirect binding request to upper layer.</simpara>
		    <simpara>What if after that head supplier overrides the context? In that case it should notiry consumer so that it can re-bind the context.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dctx_cvai"><title>Context vs access infrastructure.</title>
	    <simpara>Turning back to our DRP-CRP example. Actually there is another way to allow CRP access to common states - access infrastructure. This approach is already
		successfull applied in VIS container desing: the container deals with it's widget components via the sockets that are combined in some structure. For linear layout 
		container such structure is the linked list.</simpara>
	    <simpara>So we just can extend containers socket to distribute "model base" to all the CRPs.</simpara>
	    <simpara>Node_1: Even CRP "personal" state like "model component's URI related" can be
		distributed via sockets as "current CompName", CRP just needs to have the subsystem that "catches" this data on CRP creation phase.</simpara>
	    <simpara>The cons of this approach is rather big overhead: for instance the number of connpoints is increased significantly.</simpara>
	</sect2>
	<sect2><title>Status [IN_PROGRESS]</title>
	</sect2>
    </sect1>

    <sect1 id="ds_dsv"><title>Data special values</title>
	<sect2><title>Intro</title>
	    <simpara>It is common use-case when we need to analyze if the data is erroneous or the data isn't set yet. Data erroneous (validity) indication (mValid) is already supported in
		DtBase (ref rdata.h). "Isn't set" indicator is not supported yet, not sure we need it, probably validity indicator is enough even these indicators has different meaning
		actually.</simpara>
	    <simpara>But it is not possible to set this special value via mutation and the special values don't have text representation.</simpara>
	</sect2>
	<sect2><title>Option#1. Special values text representation.</title>
	    <simpara>We can use for instance the syntax of special values text representatio as: </simpara>
	    <programlisting>
		    representation = SIGNATURE " " "&lt;" special_value "&gt;"
		special_value = special_value_invalid | special_value_unset
		special_value_invalid = "ERR"
		special_value_unset = "NIL"
	    </programlisting>
	</sect2>
	<sect2><title>Option#2.Special values text representation.</title>
	    <simpara>We can use for instance the syntax of special values text representatio as: </simpara>
	    <programlisting>
		representation = SIGNATURE " " special_value
		special_value = special_value_invalid | special_value_unset
		special_value_invalid = "_INV"
		special_value_unset = "_NIL"
	    </programlisting>
	    <simpara>We can introduce also escaping such special values</simpara>
	</sect2>
	<sect2><title>Option#3 Use missing data criteria instead of special values</title>
	    <simpara>Using special value is annoying. In many cases we need to initialize the state with invalid data. It is more compact sintax if 
		we classify the data as invalid in case of the symbols after data signature are missing but same time classifying this as no data error
		(because no data is specified). The reasoning here is as: There is no data, so data is not set, i.e. invalid, but there is not data syntax error,
		because of not data specified.</simpara>
	    <simpara>We still need special_value_invalid in rare cases for instance when specifying invalid data in tuple (there are no signature when specifying
		field data in tuple, ref <xref linkend="iss_011"/>)</simpara>
	</sect2>
	<sect2><title>Status</title>
	    <simpara>20230130 Implemented Option#3 but Option#2 special_value_invalid also enabled.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_rdi"><title>Redesign of data interfaces.</title>
	<sect2><title>Intro</title>
	    <simpara>Current desing weakness is exposed by the use-case: how to simply check MDtBase IsValid() parameter. This parameter is the base one, i.e. not
		specific for type of data. It happens that it is not possible to get data base parameter in simply manner. Ref dest.h TrIsValid.</simpara>
	    <simpara>Currently the data ifaces are MDVarGet and parametrized MDtGet plus similar ifaces for setting data. All data related features are based on this
		parametrized data ifaces. This data parametrized iface approach causes a lot of related solutions. For instance there are paremetrized functions so 
		transitions just dynamically creates the function that matches output and input data types.</simpara>
	    <simpara>This approach was originated on earlier FAP design where is was assumed that any data types are allowed in the model. But then the
		idea of universal data was introduced, ref MDataBase iface. This approach allows to get rid of parametrized data at least for the model parts relation.
		But parametrized data was remain. We need to redesign the data ifaces to support universal data iface. This can vastly simplify DES framework.</simpara>
	</sect2>
	<sect2><title>Solution_1: Keep MDVarGet but use non-paremetrized MDget iface instead of paremetrized MDtGet. </title>
	    <simpara>Pros: This solution allows smooth migration from templated iface. We just can redesing DES framework part by part.</simpara>
	    <simpara>Cons: MDVarGet actually is not needed in our case - it aims exactly to support different type of data instead of generic one.</simpara>
	</sect2>
	<sect2><title>Solution_2: Get rid of parametrized MDtGet iface?</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Potentially we can have only MDVarGet with the method:
		    <programlisting> virtual bool DtbGet(MDtBase&amp; aData) </programlisting>
			With this method it is possible both resolving the suitable data getter and obtain the data.
		</simpara>
		<simpara>Cons if this approach is that MDVarGet implementation shall cast data instance from MDtBase to particular data type
		    on each DtbGet call. With parametrized MDVarGet iface such cast is not required.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_sor"><title>Redesing transtions to simplify MDesInpObserver routing.</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <xref linkend="iss_009"/> for the problem description. The exact root-cause is that the routing of MDesInpObserver can
		be very complex depending on tansition topology. This is because the transitions just routes the IRM request to pairs.</simpara>
	</sect2>
	<sect2><title>Solution#1 Disable transition MDesInpObserver IRM redirecting.</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to restrict this routing complexity by implementing MDesInpObserver in transition and rederecting the iface methods to
		    pairs. This will drastically reduce the model scope of MDesInpObserver resolution so simplifies the IRM pahtes.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Status: [DONE]</title>
	    <simpara>20220412 e015e4e41</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_cist"><title>[Impl] Constant instead of State</title>
	<sect2><title>Status</title>
	    20230407 Implemented
	</sect2>
	<sect2><title>Intro</title>
	    <simpara>Currently there are a lot of usages States in constant roles. Using States that are not changed creates
		an overhead. This needs to be optimized.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_gibu"><title>Getting interface by its UID</title>
	<sect2><title>Intro</title>
	    <simpara>Currently the utilization of UID looks very weak - UID just indentifies the iface. But what is the sense of identifying withiout
		possibility to get the iface by UID.</simpara>
	    <simpara>We need the feature of environmnet (and possible even owner) getting access to iface by UID.</simpara>
	    <simpara>There is the feeling that current implementation is not consistent regarding "atomic" object of the system. The idea was that iface is
		such atomic entity. If so then we need more instruments to operate with ifaces (and identify them).</simpara>
	    <simpara>Ref <xref linkend="ds_dcs_sdo_owi"/> for <xref linkend="gls_sdo"/> operating with ifaces.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_egio"><title>Enable getting ifaces for owner.</title>
	<sect2><title>Intro</title>
	    <simpara>It is common case that we request iface to get another iface (ref MIface::getLif()). Many ifaces restrict such ifaces resolution. For instance
		MVert disables getting MNode to allow access to MNode from pair (the pair can be part of separate system. </simpara>
	    <simpara>The idea is to enable local iface resolution for owner. Such solution already was implemented in earlier FAP versions where the context was passed
		to the resoltuion method.</simpara>
	    <simpara>Ref <xref linkend="ds_dcs_sdo_gmn"/> for use-case related to  <xref linkend="gls_sdo"/>.</simpara>
	</sect2>
	<sect2><title>Solution#1 MNode new method getIface(const Uid&amp;)</title>
	    <simpara>The idea to add new MNode method that utilizes getting iface by UID, ref <ulink url="ds_gibu"/>. It is assumed that UID identifies not only iface itself but
		also iface MNode "bearer" (current version of UID = URI + iface_name allows it). So the owner will be able to get the iface MNode bearer.</simpara>
	</sect2>
	<sect2><title>Solution#2 Pass owner as the context via getLif new argument. </title>
	    <simpara>The context should be another MIface.</simpara>
	    <simpara>Looks complicated. We expect to have simplistic operation when resolving ifaces locally.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_des_idmux"><title>DES inputs demultiplexor</title>
	<sect2><title>Intro</title>
	    <simpara>It is common case where a number of same subsystems react on similar data. Ofter it is designed as one connpoint to what many "supplying" subsystem output
		are connected. The example is FAP3-VIS vertex DRP where DRP has context connpoint to what all CRPs are connected. DRP needs to react (create ordering) on all CRPs
		data - DRP has ordering subsystem that needs to order all CRPs connected. The naive "direct" solution would be to have separate ordering DRP subsystem for
		each CRP but it is too expensive. Another solution is to have just one ordering subsystem and react on each input one-by-one implementing kind of inputs
		demultiplexor.</simpara>
	    <simpara>The demultiplexor has input resolving the number of ifaces and output that connects to "demultiplexed" subsystem input.
		Multiplexor "connects" output the input first interface, thus update demultiplexed subsystem input. Then mutliplexor waits till demultiplexed subsystem reaction
		gets completed (it needs special indication from subsystem) and switches to next iface.</simpara>
	    <simpara>We need to consider at least two cases:</simpara>
	    <itemizedlist>
		<listitem>Multiplexer input is state input. Multiple MDVarGet ifaces are resolved on the input.</listitem>
		<listitem>
		    Multiplexer input is generic input. It even can be a socket.
		    <para>This is exaclty the case of Vertex DRP where the input is socket {CRP uri, vector of pairs}</para>
		</listitem>
	    </itemizedlist>
	</sect2>
	<sect2><title>Design: demux is similar to multi-input transition.</title>
	    <simpara>
		Demux can be considered as multi-input transition. Indeed, the controlled system shouldn't have "unique" states bacause the system is one for
		all inputs. For instance for Vertex DRP the controlled system just updates the common pseudo states, DRP structure, via
		<xref linkend="gls_sdc"/>.
	    </simpara>
	    <simpara>
		Using this analogy we can say that use-case 
		<xref linkend="ds_des_idmux_uc_ginu"/> is not really suitable for our case - in multi-input transition all
		    inputs are important, even those that are not updated.
	    </simpara>
	</sect2>
	<sect2 id="ds_des_idmux_uc"><title>Use-cases</title>
	    <sect3 id="ds_des_idmux_uc_ginu"><title>Demux given input notifies of update - Demux updates controlled system for this input</title>
		<sect4><title>Clarification</title>
		    <simpara>On Vertex DRP example: given vertex is updated (got new connection for instance) - demux updates controlled system (i.e. CRPs orderer) so that 
			corresponding CRP is reordered.</simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>This use-case is not covered in the current design. This is because demux cannot understand what input notifies of update.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_desas"><title>DES active subsystem (<xref linkend="gls_desas"/>)</title>
	<sect2><title>Intro</title>
	    <simpara>In many cases it seems effective to desing the part of DES as subsystem that also is DES but in contrary to normal "monolitic" subsystem runs in it's own loop.
		The example can be subsystem that do iterative updates. This can be searching front of list etc.
		The idea of using such subsystem is that the subsystem runs "inside" main system update step and
		completes running "in a moment" from main system point of view. Thus the main system loop gets shorter and DES signalling is reduced.</simpara>
	    <simpara>This subsytem having completed trajectory "in a moment" also allows to awoid special indication of completeness in case of "monolitic" subsystem.</simpara>
	    <simpara>Even the main idea is clear the use-case model is not established yet.</simpara>
	</sect2>
	<sect2 id="ds_desas_sis"><title>Design issue: setting initial states.</title>
	    <sect3><title>Intro</title>
		<simpara>The autonomous subsystem in fact performs its trajectory from some initial states that are set by owning system. The question is how to set these
		    initial states. The best option would be to use standard state input desing. The initial idea is to use switch that switches from work topology to initial value inputs
		    after subsystem stops. But this idea is not working because update of switch selector notifies the state of update so subsytem starts new movement.</simpara>
		<simpara>What would be the solutions?  </simpara>
	    </sect3>
	    <sect3><title>Solution#1 Create special switcher that doesn't resolve MDesInpObserver for selector input.</title>
		<para>The idea isn't perfect, having this "special" switcher breaks the transitions common desing.</para>
	    </sect3>
	    <sect3 id="ds_desas_sis_iph"><title>Solution#2 Implements special "init" phase in DESAS agent.</title>
		<simpara>Each subsystem should have special boolean state "Init" that indicates special "init" phase. This state can be connected to the selector of the switchers
		    connecting internal states to the initial states value inputs. DESAS agent sets this state on the initial step of subsystem and then resets it.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Status</title>
	    <simpara>20220710 Initial design is implemented, ref des.h:DesAs. The desing is a bit weird. The subsystem "isolation" desing is not perfect. </simpara>
	    <simpara>20220714 Applied solution#2 for setting initial states (ref <xref linkend="ds_desas_sis"/>), UT  ut_desas_2.chs.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_ndes"><title>Native DES as the base of designing DES framework.</title>
	<sect2><title>Intro</title>
	    <simpara>The DES framework core approach is changeable and structured agents, ref <xref linkend="ds_itr_pss"/>. This "changeable and structured agents" framework is
		created using generic OOP (C++). However the base agent (node) and it's heirs contains wide context, so are DES. For instance node context includes references to owned nodes,
		content. Moreover nodes in the system depens on the context of other nodes. To support these dependencies specific mechanism of observation is designed. So the native agents
		theyself seem can be effectivelly implemented basing on low-level DES framework.</simpara>
	    <simpara>Using low-level DES can optimize the resolving of native dependencies. This low-level framework can alse be used as generic DES framework in 
		OOP applications.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_desopt"><title>DES optimization</title>
	<sect2 id="ds_desopt_ums"><title>Using move semantic in DES update/confirm data transition.</title>
	    <sect3><title>Intro</title>
		<simpara>Currently a lot of not optimized data copying happens on DES two-phase model update/confirm. This create significant overhead and
		    decrease the system performance. We already considered the possible desings to implement DES without using two-phase approach, but failed getting
		    valuable solution.</simpara>
		<simpara>There is another way to optimize it - we can keep proved 2-phases approach but apply move semantic to data transferring. For instance
		    we can avoid copying data on confirm phase but swap update and confirm data.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_desopt_asdc"><title>Avoid state update/confirm data comparition on confirmation step</title>
	    <sect3><title>Intro</title>
		<simpara>Currently [20220826] state data updation is checked on update state. If the data is not updated then the state is not "marked" as updated and
		    confirmation step of this state is omitted. This means update/confirm data comparition on confirmation step is not necessary -
		    if state goes to comparition step this means that the data was changed.</simpara>
		<simpara>This optimization was applied in fap4 primary deds layer.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>TrTuple::DtGet() - data copied via serialization-deserialization.</title>
	    <programlisting>
		string values;
		inphb->ToString(values);
		istringstream isv(values);
		elem->FromString(isv);
	    </programlisting>
	</sect2>
	<sect2 id="ds_desopt_udr"><title>Data copied from transition output. To use data reference instead.</title>
	    <sect3><title>Intro</title>
		<simpara>Many transition data "receivers" just copied data from its inputs and then use it. We need to avoid copying data but use refs instead.</simpara>
		<simpara>Hm. This copying seems the correct in general - function creates new data (result) and copy it to "receiver". The only problem here is that function
		    copy the result also to internal debugging data. This needs to be redesigned. Also getting the reference can be more optimal in the cases when the 
		    receiver doens't need the whole data but just parts of it. The example is the tuple component selector (TrTupleSel) or Vector element selector (TrAtVar). Currently
		    the selector transition copied the whole container and then gets the component of it. This is not optimal.</simpara>
		<simpara>The problem with getting refence is that we will need to cache the data in transitions - indeed we can get the ref to the persistent data only.
		    For the case of state as data getter it is simple, the state keeps persistent data.</simpara>
	    </sect3>
	    <sect3><title>Where to cache data in transtions: inputs or outputs?</title>
		<simpara>As was discussed in intro we anycase need to cache the data. The only questions in what point? There are two options: cache inputs data or 
		    cache output data.</simpara>
		<simpara>It is quite obvious that the inputs number is greater than the number of outputs. In "internals" of transition tree inputs number is greater 
		    because one output can be connected to the number of inputs but normally the numbers are same. But there are also "inputs" of transition tree - those
		    tranisition inputs that connect to states outputs. They make the inputs total number greater.</simpara>
		<simpara>So it makes sense to cache output data in transition.</simpara>
		<simpara>In that case we can also optimize the state - we don't need "updated" data anymore - the data is already cached in the transition connected to
		    state input.</simpara>
		<simpara>With this approach we needs to modify data getter iface (MDtGet) - it needs to return reference instead of perform the copy of data.</simpara>
	    </sect3>
	    <sect3><title>How caching output approach affect distributed DES design.</title>
		<simpara>Distributed DES design is based on iface proxy. How modified MDtGet (returning the ref) proxy will be implemented? </simpara>
	    </sect3>
	    <sect3><title>Use-case where using ouput data reference does't work.</title>
		<simpara>The is when state S2 input is connected to another state S1 input. Indeed, S2 gets S1 outp data ref on update phase. But
		    on confirm phase this ref can change or cannot, it depends on what state confirm gets done first.</simpara>
		<simpara>This use-case shows that "using ouput data reference" approach is not correct.</simpara>
		<simpara>Potentially we can keep this approach with disabling such state-to-state connection. However this solution is very hard to
		    implement. It is more simpler to apply update/confirm data swap, ref <xref linkend="ds_desopt_ums"/>.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_desopt_uic"><title>Getting inputs involves getting input node/unit - can we use iface cache directly.</title>
	    <sect3><title>Intro</title>
		<simpara>Look at the typical function code:</simpara>
		<programlisting>
		    template&lt;class T&gt; void FAddDt&lt;T&gt;::DtGet(T&amp; aData)
		    -   {
		    |       bool res = true;
		    |       MIfProv::TIfaces* inps = mHost.GetInps(EInp, MDVarGet::Type(), false);
		    ...
		</programlisting>
		<simpara>Where:</simpara>
		<programlisting>
		    MIfProv::TIfaces* TrVar::GetInps(int aId, const string&amp; aIfName, bool aOpt)
		    -   {
		    |       MIfProv::TIfaces* res = nullptr;
		    |       MNode* inp = getNode(GetInpUri(aId));
		    |-      if (inp) {
		    ||          MUnit* inpu = inp->lIf(inpu);
		    ||          MIfProv* ifp = inpu ? inpu->defaultIfProv(aIfName) : nullptr;
		    ||          res = ifp ? ifp->ifaces() : nullptr;
		</programlisting>
		<simpara>We can see that each DES cycle getNode() is called. It needs to be avoided.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_desopt_mdc"><title>Modify DES cycle to avoid polling the comps but keep the lists of active/updated in owner.</title>
	    <sect3><title>Status</title>
		Implemented
	    </sect3>
	    <simpara>Ref <xref linkend="ds_mdc"/> for details</simpara>
	</sect2>
	<sect2 id="ds_desopt_tdc"><title>[Impl] Transtions: avoid multiple update, use data cache for that.</title>
	    <sect3><title>Status</title>
		20230405 Implemented, b480bd415bf
	    </sect3>
	    <sect3><title>Intro</title>
		<simpara>In the complex systems the transitions topology can differs from "true" tree. It can be like that:</simpara>
		<programlisting>
		    |                    -----
		    |          --- ... --|
		    |         /          | 
		    |   TRANS            | TRANS2
		    |        \           | 
		    |          --- ... --|
		    |                    -----
		</programlisting>
		<simpara>or similar. In that case the TRANS will be updated many times on DES update phase.</simpara>
		<simpara>We need to avoid that. This can be done via caching transition output (this is already implemented) and 
		    enable the cache update only at the first update in DES update phase.</simpara>
		<simpara>Same approach can be applied to SDO and SDC also.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Misc optimization items</title>
	    <sect3><title>Seach when checking IRM requestor</title>
		<programlisting>
		    83	void Unit::resolveIface(const string&amp;aName, MIfReq::TIfReqCp* aReq)
		    ...
		    86	    // Check if the requestor was already registered
		    87	    MIfProv* prov = nullptr;
		    88	    for (auto item : mIrns) { 
		    89		if (item->isConnected(aReq)) { prov = item; break;}
		</programlisting>
	    </sect3>
	</sect2>
	<sect2 id="ds_desopt_est"><title>Fap3-vis ut_avr_vert_drp_2. Extracting VertCRP Slot takes long time.</title>
	    <sect3><title>Intro</title>
		<simpara>Analysis of the log shows that extracting VertCrp Slot takes long time.</simpara>
		<programlisting>
		    04/09/23 16:27:33.446340883;INF;;.testroot.Test.Window.Scene.Drp.SdcReposExtrSlot;Started extracting node [.testroot.Test.Window.Scene.Drp.Slot_Model_vert2%MNode]
		    04/09/23 16:27:33.629897118;INF;;.testroot.Test.Window.Scene.Drp.SdcReposExtrSlot;Started extracting node 1
		</programlisting>
		<simpara>So the operation takes ~180ms: disconnect </simpara>
		<programlisting>
		    ASdcExtract::doCtl (this=0x55555617e010) at dessdc.cpp:1307
		    ...
		    bool cres = MVert::disconnect(nextv, nextPair);
		</programlisting>
		<simpara>Where nextv is ".testroot.Test.Window.Scene.Drp.Slot_Model_vert2.Next%MVert" and nextPair is ".testroot.Test.Window.Scene.Drp.Column_0.Start.Prev%MVert"</simpara>
		<simpara>Disconnect operation includes handling:</simpara>
		<programlisting>
		    void Vert::onDisconnected()
		    -   {
		    |       invalidateIrm();
		    |       notifyChanged();
		</programlisting>
		<simpara>Checked Column_0.Start.Prev IRMs - the tree is too vast. This is because of the specifics of Columns container topology - slots CPs comprises very long chains.</simpara>
		<simpara>Checked with profiler the time consumed by invalidateIrm - it takes 2/3 of total system run (column#3 gives the num, #4 - min dur, #5- max, #6 - total duration):</simpara>
		<programlisting>
		    2       IFC_U_INV       17593   0.000001        0.071517        2.918130        0.000166        0.001689        0
		    1001    IFC_LNCH_RUN    1       4.307730        4.307730        4.307730        4.307730        0.000000        0
		</programlisting>
	    </sect3>
	    <sect3><title>Status</title>
		<simpara>20230501 Ref <xref linkend="ds_asr_cbscpd"/> for the problem analysis. Implemented interim soluiton <xref linkend="ds_asr_cbscpd_ahoi"/>.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dsps"><title>[Impl] Dynamic switching with TrSwitchBool: design problem and possible solution</title>
	<sect2><title>Status</title>
	    <simpara>20230409 Initial impl.</simpara>
	</sect2>
	<sect2><title>Intro</title>
	    <simpara>In the current fap3 version there is still TrSwitchBool issue that was discussed earlier and then forgotten:
		transition passes MDesInpObserver notification from non-selected input.</simpara>
	    <simpara>This dynamic switching is the alternative of struncture changing via SDC. Dynamic switching is more light-weight then
		changing of the structure. It just uses interface calls redirections instead of interface resolution.</simpara>
	</sect2>
	<sect2><title>Solution</title>
	    <simpara>
		Current implementation already does MDtGet calls redirection. The only MDesInpObserver call is not redirected.
		Created new agent TrSwitchBool2. Added MDesInpObserver call redirection. Tested on fap3-vis ut_avr_vert_drp_2 -
		there is no performance valuable improvement. This weak affect to the performance can be explained: transitions cache (
		<xref linkend="ds_desopt_tdc"/>) was introduced some time ago so even the dependent state is notified extra times the state just 
		    takes the trans cache (that is unchanged), so no re-calculation happens)
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_rdr"><title>Row data redesign.</title>
	<sect2 id="ds_rdr_itr"><title>Intro</title>
	    <simpara>The current implementation of row data has a number of problems that are indicated by use-cases below</simpara>
	    <sect3><title>Hierarchical composite data: serialization instead of direct parsing.</title>
		<simpara>The current design of row data is not consistent enough.</simpara>
		<simpara>The first problem is the composite data inconsistent text representation.
		    The use-case that expose the design problem is the container "Vector of Pair of string", signature "VPS",
		    ref rdata.cpp. The problem here is at least in the data deserialization from the text representation. It is assumed in the current design that the textual representation
		    of composite data is rather simple: just peace of text separated by space. This doesn't work for the composite data whose component is also composite data,
		    for instance Vector of Pairs.</simpara>
		<simpara>So, we need to re-design row-data at least in point of serialization/deserialization. We need to use subsequentual serialization from/to stream instead
		    of direct parsting of string.</simpara>
	    </sect3>
	    <sect3><title>Scalar data of string</title>
		<simpara>Migrating to serialization affects scalar data of string: now we need to understand where are the start and end of the string, i.e. string representation
		    syntax needs to include string delimiters.</simpara>
	    </sect3>
	    <sect3 id="ds_rdr_itr_ovst"><title>Overhead in Containers size transition.</title>
		<simpara>Look at TrSizeVar. Here we don't actually need to know what is the type of Vectors element. We simply need to get the size of Vector. But with the 
		    current design we need to exactly resolve the full type of Vector, i.e. have a number Vector variants supported.</simpara>
	    </sect3>
	    <sect3 id="ds_rdr_itr_senl"><title>Data text represenation syntax error is not logged</title>
		<simpara>The root-cause is that row-data has only one mValid flag that covers both undefined data and the data that gets erroneous because of wrong text representation.</simpara>
		<simpara>The solution would be have separate flags for these two cases.</simpara>
	    </sect3>
	    <sect3><title>Row data supporting of container components access interfaces</title>
		<simpara>This would be much more effective then copy container and then get compoments from it. Refer FAtVect&lt;T&gt;::DtGet():</simpara>
		<programlisting>
		    ||          Vector&lt;T&gt; arg;
		    ||          dfget->DtGet(arg); !! YB the data is copied
		    ...
		    234                 aData.mValid = arg.GetElem(ind.mData, aData.mData);
		</programlisting>
	    </sect3>
	</sect2>
	<sect2><title>Data text representation syntax</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_agt_data_repr"/> for the data represntation syntax in fap2 (and actually the current one).</simpara>
	    </sect3>
	    <sect3><title>Syntax</title>
		<programlisting>
		    data_repr = (scalar_data_repr | composite_date_repr)
		    composite_date_repr = (container_data_repr | tuple_data_repr)
		    container_data_repr = type, separator, container_data_value
		    type = type_signature, [ "," , type_parameters ]
		    value = (scalar_data_value | composite_data_value)
		    container_data_value = "(", [[separator], component_data_value], {[separator], ",", component_data_value}, ")"
		    component_data_value = data_repr

		    (* Node that native_string_repr differs from scalar_string_data:
		    native_string_repr terminates with space whereas scalar_string_data terminates by end_of_data 
		    native_string_repr = sybmbols, space

		    space = " "
		    scalar_data_repr = (scalar_string_repr | scalar_int_repr | ...)
		    scalar_string_repr = scalar_string_sig, separator, scalar_string_data
		    scalar_string_data = "'", {symbol}, "'"
		</programlisting>
	    </sect3>
	</sect2>
	<sect2><title>[STATUS]</title>
	    <simpara>20230109 Initial implementation. Tested with modnav.</simpara>
	</sect2>
	<sect2 id="ds_rdr_cnt"><title>Containers of non-typed data</title>
	    <sect3><title>Intro</title>
		<simpara>In the current design the containers are used where the elements are typed data. The only exception is Tuple.
		    It contains non-typed DtBase elements. It makes sense to propagate Tuple approach to other containers.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ssp"><title>System Service point (<xref linkend="gls_ssp"/>)</title>
	<sect2><title>Status</title>
	    <itemizedlist>
		<listitem>20230302 Initial variant, unit-case. Not completed. High-level use-cases are not confirmed. </listitem>
	    </itemizedlist>
	</sect2>
	<sect2><title>Intro</title>
	    <itemizedlist>
		<listitem>
		    Ref <ulink url="../../../fap3-vis/doc/design/index.html#ds_vtxdrp_ecr"/> for the primary use-cases.
		    <para>The main use-case if the system consisting from a number of "client" syb-system and "service" sub-system.
			Here the "clients" update theirs's state depending on "service" states. In the use-case above the EdgeCRP points states
			(coordinates) depends on DRP states set.</para>
		</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_ssp_dip"><title>Design initial points</title>
	    <sect3><title>Single conn point, multiple client updating (servicing) subsystems.</title>
		<simpara>It makes sense to simplify the interface for the clients. Because the clients are same from states updates needs we can have
		    "service" system single connpoint for all such clients. Even having signle connpoints the service system needs to have client's
		    dedicated subsystems to update each client.</simpara>
		<simpara>There should be dedicated servicing subsystem created for each client. Let's consider the simple servicing scheme.</simpara>
		<simpara>There are Servicing system SS, service connpoint CP with simplem interface (one inp Inp and one outp Outp),
		    clients A and B, and servicing subsystem SSS that "gets" the inp, gets SS context, and updates clients via CP output.</simpara>
		<programlisting>
		    |        |-------------|
		    |        |   SS        |
		    |   A---|  |---|SSS_A| |
		    |       |CP|           |     
		    |   B---|  |---|SSS_B| |
		    |        |             |
		    |        |-------------|
		</programlisting>
		<simpara>CP shall have special iface resolution rules to resolve iface depending on what the iface request comes from. For instance
		    if MDesInpObserver resolution request comes from client A then CP shall redirct iface resolution request to SSS_A input. In turn if iface 
		    resoution request comes from SSS_A then CP shall redirect the request to client A.</simpara>
	    </sect3>
	    <sect3 id="ds_ssp_dip_sss"><title>Can we have single updating (servicing) subsystem for clients?</title>
		<simpara>Note, that having single servicing subsystem makes sense only for the subsystem in form of transition, i.e. without any
		    states. If there are some states in subsystem there have to be separate subsystems.</simpara>
		<simpara>Yes, potentially such design can be used. But in that case we need to have enhanced interface resolution mechanism. Let's
		    consider same simple 2-clients schema:</simpara>
		<programlisting>
		    |        |-----------|
		    |   A---|  | SS      |
		    |       |CP|---|SSS| |     
		    |   B---|  |         |
		    |        |-----------|
		</programlisting>
		<simpara>There are Servicing system SS, service connpoint CP with simplem interface (one inp Inp and one outp Outp),
		    clients A and B, and servicing subsystem SSS that "gets" the inp, gets SS context, and updates clients via CP output.</simpara>
		<simpara>
		    When client A gets updated, it sends DES input update notification (MDesInpObserver) thru CP Inp. SSS should pass this
		    notif back to A thru CP Outp. When B get updated SSS should pass inp update notif back to B. So CP shall resolve MDesInpObserver
		    depending on iface resolution context, i.e. on what client makes the request.
		    Yes, CP Iface resolution rules can use iface resolution requestor. But the problem here is
		    that MDesInpObserver iface resolution request coming to CP doens't contain the full context - even each transition "breaks" the request context.
		</simpara>
		<simpara>
		    Current iface resolutin mechanism supports only context in form of requestor chain. But it is not enough in our case. We needs to have the 
		    context that can be somehow passed to the agent where it can be actually used. In our case for instance it will be the MDesInpObserver request
		    to CP. So we need to have the enhanced iface resoution mechanism to support single servicing subsystem schema. With the current resolution
		    mechanism the solution will not work. Ref <xref linkend="ds_irm_ctx"/> for IFR design materials.
		</simpara>
		<simpara>Potentially the solution would be keeping the request context in CP. For instance client A requests CP for MDVarGet, CP stores 
		    the request context (client A) and uses this context when servicing subsystem in turn requests CP for MDVarGet iface - CP will redirect the request to
		    client A.</simpara>
	    </sect3>
	    <sect3><title>How to create servicing subsystem for the clent.</title>
		<simpara>We need to have native agent "Servicing point" (or multi-clent point) for that. This agent specifics are:</simpara>
		<itemizedlist>
		    <listitem>It creates corresponding servicing subsystem on client connected event.</listitem>
		    <listitem>It removes corresponding servicing subsystem on client disconnected event.</listitem>
		    <listitem>It has specific iface resolution rules "binding" client to its servicing subsystem.</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2><title>Design. Separate servicing subsystem for each client.</title>
	    <sect3><title>Intro</title>
		<simpara>Single servicing subsystem desing options (ref <xref linkend="ds_ssp_dip_sss"/>) is not clarified so far. So we need to focuse on
		    the initial design option where separate servicing subsystem is created for each client.</simpara>
	    </sect3>
	    <sect3><title>Structure</title>
		<simpara>The structure is as:</simpara>
		<programlisting>
		    |
		    |
		    |                          -------------------------------------------------------------------------
		    |                          |   SSM                                                                 | 
		    |                          |                                                                       |
		    |    ------------------    |   -----------------      --------------------------                   |
		    |    |        ------- |    |   |       ------- |      |  --------     -------- |         --------  |
		    |    | Client | CCP |----------| ECP   | Int |-----------| CCPM | SS  | SCXC |-----------| SCXS |------------
		    |    |        ------- |    |   |       ------- |      |  --------     -------- |         --------  |
		    |    ------------------    |   -----------------      --------------------------                   |
		    |                          |                                                                       |
		    |                          -------------------------------------------------------------------------
		</programlisting>
		<simpara>Where:</simpara>
		<programlisting>
		    SSM - serivcing subsystems manager
		    CCP - Client Connection Point (Socket)
		    ECP - Client connection point extender - specific native agent inherited from Extd and having specific IFR.
		    CCPM - Client Connection Point mate
		    SS - servicing subsystem
		    SCXC - Servicing context consumer
		    SCXS - Servicing context supplier
		</programlisting>
		<simpara>SSM creates SS for each client connected to ECP and name SS with assosiation to its client. Such names assosiation is used to the proper 
		    iface resolution.  </simpara>
	    </sect3>
	    <sect3><title>How to resolver ifaces for client and servicing subsystem?</title>
		<sect4><title>Intro</title>
		    <simpara>Threre should be the proper IFR mechanism that "binds" assosiated client and service. To correctly resolve the ifaces the IFR nodes owners
			(CCP, ECP, ECP.Int, CCPM) should have the proper contex. We can use some client/service identification as the context at the moment.
			Let's use client and sevicing subsystem names (they should be same) as the identification. There is no existing means of how to get the names.
			So we need to create such means. We can propose the following mechanism of gettig the context: introduce dedicated iface MDesSpc for
			obtaining ID (this ifaces shall be implemented specific managing agents embedding to Client and SS). IFR nodes owners needs to be
			customized to use MDesSpc when obtaining ID.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1><title>Code review</title>
	<sect2><title>20221216 Native hier, protocols, node</title>
	    <sect3><title>Can the protocol of the manager of protocols be used instead of each protocole getLif()</title>
		<simpara>The ifaces (protocols) base MIface contains getLif() method so each of protocol needs to iplement it.
		    Does it make sense to have just one protocol (named "protocol mager") to have this method.</simpara>
	    </sect3>
	    <sect3><title>MNode is too complex, separate tree nav and mutation?</title>
	    </sect3>
	    <sect3><title>Env - is it really needed, especially each node access to env?</title>
	    </sect3>
	    <sect3><title>Does it make sense to use composition paradigm in native agents instead of inheritance? </title>
		<simpara>Protocols are used - this is element of composition paradign. Why the inheritance is used to
		    create native agents?</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ver"><title>Agents versioning</title>
	<sect2><title>Intro</title>
	    <simpara>Systems real development environment assumes that the modules are updated same time as the system is developed. So it is 
		important to be able to select the right version of the modules nodes. </simpara>
	</sect2>
    </sect1>

    <sect1><title>System persisting</title>
	<sect2><title>Intro</title>
	    <sect3><title>Usefull refs</title>
		<itemizedlist>
		    <listitem>
			<ulink url="https://www.codesynthesis.com/products/odb/doc/manual.xhtml"/> - C++ Object Persistence with <xref linkend="gls_odb"/>
		    </listitem>
		    <listitem>
			<ulink url="https://www.service-architecture.com/articles/database/"/> - articles explaining object-relational mapping (
			<xref linkend="gls_orm"/>) and object-oriented database (<xref linkend="gls_odb"/>)
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ibc"><title>Tracking: Design items to be handed</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <xref linkend="ds_itr_sp"/> for the initial list of the problems need to be addressed in FAP3.</simpara>
	</sect2>
	<sect2 id="ds_ibc_roncc"><title>Root as the only node containing chromo</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the model can contain many nodes that have theyrs own chromos - any Elem based nodes. This simplifies creating these nodes
		    heirs. But on another hand this causes chromo duplication. Actually any node chromo can be "calculated" from root chromo. This approach
		    was tried in some earlier version of FAP.
		    This approach potentially can improve the model performance. We need to consider such design.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_ibc_dgit"><title>[DS_IBC_DGIT] Do we need MDtGet iface as templated one?</title>
	    <simpara>Potentially we can have non-templated MDtGet that provides the access to base data iface MDtBase.</simpara>
	    <simpara>The indication of week desing is the problems with TrTuple: it is not possible to update the tuple components. The input of the 
		transition can get the access to data only via templated MDtGet but the type isn't explicitly known.</simpara>
	</sect2>
	<sect2><title>Intitial invalid status of State</title>
	    <simpara>Ref <xref linkend="ds_iis"/></simpara>
	</sect2>
	<sect2><title>Localize provider's scope</title>
	    <simpara>Ref <xref linkend="ds_lps"/></simpara>
	</sect2>
	<sect2><title>Chromo named segments</title>
	    <simpara>Ref <xref linkend="ds_cli_nseg"/></simpara>
	</sect2>
	<sect2><title>Mutation as transaction</title>
	    <simpara>Ref <xref linkend="ds_mtc"/></simpara>
	</sect2>
	<sect2><title>DES context</title>
	    <simpara>Ref <xref linkend="ds_dctx"/></simpara>
	</sect2>
	<sect2><title>Data special values.</title>
	    <simpara>Ref <xref linkend="ds_dsv"/></simpara>
	</sect2>
	<sect2><title>Redesing data interfaces.</title>
	    <simpara>Ref <xref linkend="ds_rdi"/></simpara>
	</sect2>
	<sect2><title>Introduce constant data instead of State</title>
	    <simpara>Ref <xref linkend="ds_cist"/></simpara>
	</sect2>
	<sect2><title>DES based objects</title>
	    <simpara>Ref <xref linkend="ds_dcs_sl_dbo"/></simpara>
	</sect2>
	<sect2><title>DCS transactions</title>
	    <simpara>Ref <xref linkend="ds_dcs_trs"/></simpara>
	</sect2>
	<sect2><title><xref linkend="ds_gibu"/></title> </sect2>
	<sect2><title><xref linkend="ds_egio"/></title> </sect2>
	<sect2><title><xref linkend="ds_desopt_ums"/></title> </sect2>
	<sect2><title><xref linkend="ds_desopt_asdc"/></title> </sect2>
	<sect2><title><xref linkend="ds_ndes"/></title> </sect2>
	<sect2><title><xref linkend="ds_irm_ctx"/></title> </sect2>
	<sect2><title><xref linkend="ds_nn_efcoop"/></title> </sect2>
	<sect2><title><xref linkend="ds_uinn_cs"/></title> </sect2>
	<sect2><title><xref linkend="ds_nn_abo"/></title> </sect2>
	<sect2><title><xref linkend="ds_dsps"/></title> </sect2>
	<sect2><title><xref linkend="ds_desopt_est"/></title> </sect2>
	<sect2><title><xref linkend="ds_ver"/></title> </sect2>
	<sect2><title><xref linkend="ds_dcs_sl_lsc"/></title> </sect2>
	<sect2><title><xref linkend="ds_dcs_sl_nti"/></title> </sect2>
    </sect1>

    <sect1 id="ds_ic"><title>Tracking: Design items completed</title>
	<sect2><title><xref linkend="ds_mdc_sw"/></title> </sect2>
	<sect2><title><xref linkend="ds_desopt_tdc"/></title> </sect2>
    </sect1>

    <sect1 id="ds_iss"><title>Issues</title>
	<sect2 id="ds_iss_001"><title>[DS_ISS_001] Wrong chromo forming in case of namespace segment.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Ref ut_elem.cpp:test_elem_inh_1() chromo ut_elem_inh_1.chs. The problem is that mutation 
		    <programlisting>About = "N1_1 new";</programlisting>
			will be included into E1 chormo twice: first entry is in the scope of namespace segment
		    <programlisting>
			N1_1 @ {
			About = "N1_1 new";
			}
		    </programlisting>
			and the second - in E1 chromo directly
		</simpara>
		<simpara>
		    Ref <xref linkend="ds_eosm"/> for the details of <xref linkend="gls_eosm"/> current solution. The reported problem is
			caused by this solution bad design.
		</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>
		    The root-cause is that the algorithm of E1 chromo forming is wrong: mutation and "About = ..." will be included even 
		    the namespace segment is alredy included.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_002"><title>[DS_ISS_002] Cannot define monitored agent for <xref linkend="gls_adp"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    It is very common case that the adapter is not owner of monitored agent. Potentially we can put monitored
		    agent to adaper owneds but it is not convenient - there can be many adapters associated to single monitored object.
		</simpara>
		<simpara>
		    This "not owning" causes the problem that we cannot simply define monitored object via URI - adapter will not
		    be able to get not owned node.
		</simpara>
		<simpara>
		    Ref <xref linkend="ds_sn_aul"/> for details of generic problem and approaches of how to workaround the
			access restrictions.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_003"><title>[DS_ISS_003] 20211212 git:930bb4ea585ece. Incorrect IFR for sockets</title>
	    <sect3><title>Intro</title>
		<simpara> UT Ut_ifr::test_inval_sock_1() fails. This means that IFR works incorrectly in case of sockets connecting/disconnecting.  </simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>The current implementation of IFR tree update (ref <xref liknend="ds_irm_ut"/>) supports only vert connect/disconnect. The 
		    Vert::connect() just invalidates the vertexes IFR. But for sockets it doesn't work - the pins are not invalidated.</simpara>
	    </sect3>
	    <sect3><title>Fix proposal</title>
		<simpara>We need to redesing IFR:</simpara>
		<itemizedlist>
		    <listitem>
			IFR node validity sign shall indicate that node has to be updated
			<para>Currently the validity is set based on resolution result - node is considered as valid if the iface is resolved.
			    If not, then node is marked as invalid and is removed then.</para>
			<para>We don't need to mark node as invalid in case of iface is not resolved. The whole branch has to be marked as valid even
			    it is iface is not resolved. This branch cannot "provide" iface but shows us the path of resolution attempt.</para>
		    </listitem>
		    <listitem>
			Invalidated unit has to invalidate its own nodes and theirs owners (requestors, i.e clients). Owned nodes are to be removed.
			<para>The logic here is: the local node says to the requestors: "Im invalid, you are using me so you needs to be updated,
			    this means you are also invalid.</para>
			<para>The owned nodes don't need to be invalidated - these branches are created by the current nodes, so they needs to be
			    removed and re-created according to new environment.</para>
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_004"><title>[DS_ISS_004] Visualization error: sometimes CRP is not set hight requisizion</title>
	    <sect3><title>Intro</title>
		<simpara>The issue happens after introducing <xref linkend="gls_asr"/> solution, ref <xref linkend="ds_asr_cbs"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_005"><title>[DS_ISS_005] Chromo2 desing assumes the top is mut_create_chromo - it is inconvenient</title>
	    <sect3><title>Intro</title>
		<simpara>
		    The inconvenience is that very ofter we need just segment chromo without root. Currently we need to use
		    mutation operation option "TreatAsChromo". Ref for instance  desadp.cpp:AMnodeAdp::ApplyMut():
		</simpara>
		<programlisting>
		    mMag->mutate(chromo.Root(), false, mutctx, true);
		</programlisting>
		<simpara>So we need to redesign chromo to support pure "segment" chromo.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_006"><title>[DS_ISS_006] NodeAdp current sytem update-confirm scheme is wrong.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ds_dcs_ucs_cip"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_007"><title>[DS_ISS_007] State content change on creation phase blocks update notification</title>
	    <sect3><title>Intro</title>
		<simpara>Ver next to 3ebc09ad1022d85</simpara>
		<simpara>
		    Created fap3/modules/dutil.chs. Tested with test/ut_des.cpp:ut_des_utl_1.chs. Observed the problem that BChange DES doesn't confirm even Delay state updated from false to true.
		    Analyzed. The root-cause is that Delay state content is set on creation phase - state notifies thru incomplete owning chain (so didn't reach the launcher) but the flag 
		    mUpdated was set, that prevent complete owning chain notifying on the first update.
		</simpara>
		<simpara>Curren solution is Solution#2, ref below.</simpara>
	    </sect3>
	    <sect3><title>Solution#1: avoid setting state mPdata and mCdata on content change.</title>
		<simpara>With this solution State doesn't change its datas immediately on content change but just keeps content and change mPdata on update phase from content kept.</simpara>
		<simpara>This solution doesn't work properly. The reason is that in the first init the constant state are undefined. This causes to dependent states gets undefined that
		    in turn causes the whole DES stop. Shortly saying we don't have initial conditions set for DES actually.</simpara>
	    </sect3>
	    <sect3><title>Solution#2: activate owned on owned attached</title>
		<simpara> The idea is to force owned active when attaching it to owner. There are variations of this solution.  </simpara>
		<simpara> The Var#1 is rather "brutal" - just to activate the owner unconditionally.  </simpara>
		<simpara> The Var#2 is to activate only if the owned was already activated. We need to add methods "isActivated" and "isUpdated" to MDesSyncable in this case.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_008"><title>[<glossterm id="iss_008">DS_ISS_008</glossterm>] Parent located in second level module cannot be found.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    The problem reproduced in [fap3-vis:5734b4e935a] [fap3:8228680d62a] in test fap3-vis/test/ut_avr_node_drp.chs with the change AvrMdl to AvrMdl2:
		    <programlisting> ERR;;.testroot.Test.Window.Scene.Drp;Creating [Slot_Model_comp1] - parent [FHLayoutSlot] not found </programlisting>
		</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>System topology is as</simpara>
		<programlisting>
		    root
		    |
		    |---Modules
		    |       |
		    |       |---AvrMdl
		    |             |
		    |             |---Modules
		    |                     |
		    |                     |---ContainerMod
		    |                               |
		    ...                             ...
		    |                               |--- FHLayoutSlot
		    |                            
		    |  
		    |--- Slot (parent FHLayoutSlot)
		</programlisting>
		<simpara>
		    Current parent resolution mechanism doesn't work here. The mutation is as:
		    <programlisting>
			364		parent = getParent(prnturi);
			(gdb) p Uid()
			$12 = ".testroot.Test.Window.Scene.Drp%MOwned"
			(gdb) p mContext->Uid()
			$13 = ".testroot.Modules.AvrMdl2%MOwner"
		    </programlisting>
			The mechanism is pritty simple (func getParent):
		    <programlisting>
			- look up in local scope (mutation scope) using getNode()
			- redirect to owner's getParent()
			- look up in modules using modules->getNode()
		    </programlisting>
			note that mContext of ".testroot.Modules.AvrMdl2%MOwner" ecuals 0. So the look up trace is as:
		    <programlisting>
			.testroot.Test.Window.Scene.Drp
			.testroot.Modules.AvrMdl2
			.testroot.Modules (owenr of AvrMdl2 as AvrMdl2 doesn't have a context).
			.testroot.Test.Window.Scene
			...
			fail
		    </programlisting>
		</simpara>
		<simpara>Hmm, but such resolution works in modnav2. Right, in modnav2 the slot is created from </simpara>
		<programlisting>.testroot.Launcher.Window.Scene.VBox.ModelView.Drp</programlisting>
		<simpara>
		    So the look up trace is as:
		    <programlisting>
			.testroot.Launcher.Window.Scene.VBox.ModelView.Drp
			.testroot.Modules.AvrMdl2
			.testroot.Modules (owner of AvrMdl2 as AvrMdl2 doesn't have a context).
			.testroot.Launcher.Window.Scene.VBox.ModelView
			(context) Modules.ContainerMod
			...
			ok
		    </programlisting>
			The resolution is ok, but this result is just "accidental", because the "right" owner of Drp.
		</simpara>
		<simpara>
		    Real root-cause is that the ContainerMod module desing is wrong:
		    <programlisting>
			317     DHLayout : DLinearLayout
			318     {
			...
			325         SlotParent &lt; = "SS FHLayoutSlot";
		    </programlisting>
			SlotParent paremeter is set here incorrectly. It should be set from the real context where it is used, i.e. from the test system
			(fap3-vis/test/ut_avr_node_drp.chs):
		    <programlisting>
			39                 Drp : AvrMdl2.NodeDrp {
			40                     SlotParent &lt; = "SS ContainerMod.FHLayoutSlot";
			41                 }
		    </programlisting>
		</simpara>
	    </sect3>
	    <sect3><title>Solution</title>
		<simpara>To set SlotParent parameter from the real context where it is used.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_009"><title>[<glossterm id="iss_009">DS_ISS_009</glossterm>] 20220412 modnav2 stucks on creation phase.</title>
	    <sect2><title>Intro</title>
		<simpara>The app stucks on creation phase, just toolbar is layouted, but model view is not.</simpara>
	    </sect2>
	    <sect2><title>Analysis</title>
		<simpara>The problem's root-cause is that IRM creates a massive amount of routing pathes for MDesInpObserver iface. This makes the IRM data update very slow,
		    especially when the nodes invalidate its IRM nodes. Additional mechamisms like <xref linkend="gls_asr"/> exacerbates the problem.</simpara>
		<simpara>The trigger of emerging of this problem is the VIS container update to handle button press event. This update assumes adding
		    to the socket the transitions that sequentially (this is container socket philosophy) forms the right URI of pressed widget. But this new transition
		    creates very complex structure for IRM because the transition are not just chain but each node of the chain creates the nomber of IRM pathes. To
		    the overall number of IRM pathes grows dramatically (some thousands for instance).</simpara>
		<simpara>Simplifying of the new transitions and reducing the number of IRM pathes partially helps, but the app creating is still slow.</simpara>
	    </sect2>
	    <sect2><title>Solution</title>
		<simpara>We need to redesing IRM rouing for MDesInpObserver iface. Ref <xref linkend="ds_sor"/> for the desing change details.</simpara>
	    </sect2>
	</sect2>
	<sect2 id="ds_iss_010"><title>[<glossterm id="iss_010">DS_ISS_010</glossterm>] 20230114 Socket resolves iface even the iface is not provided by socket pins</title>
	    <simpara>There is still the redirection to the socket pair event if iface isn't resolved by pins. </simpara>
	    <sect3><title>Solution</title>
		<simpara>To disable redirecting to the socket pair if iface isn't resolved by pins.</simpara>
	    </sect3>
	    <sect3><title>Status</title>
		<simpara>Fixed 20230115</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_011"><title>[<glossterm id="iss_011">DS_ISS_011</glossterm>] 20230128 Cannot set invalid string Sdata field in tuple</title>
	    <sect3><title>Status</title>
		<simpara>20230130 Implemented, ref also dependent design item <xref linkend="ds_dsv"/> </simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_012"><title>[<glossterm id="iss_012">DS_ISS_012</glossterm>] 20230225 Exception when resolving iface in socket extd topology.</title>
	    <sect3><title>Intro</title>
		<simpara>Trying to create UT for <xref linkend="gls_ssp"/> but see the exception. Checked with socket UT, modified ut_syst_sock_3 - the problem
		    is reqproduced.</simpara>
		<simpara>Ref ut_syst_sock_3.chs tag ISS_012. The exception happens here: </simpara>
		<programlisting>
		    #7  0x00007ffff7c6fe53 in Socket::resolveIfc (this=0x55555563bc70, aName="MTIf1", aReq=0x55555563d158) at syst.cpp:315
		    315						assert(apair == reqn);

		    (gdb) p Uid()
		    $2 = ".MyRoot.S1.S1_2.Sck1%MSocket"
		</programlisting>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>The root-cause is wrong alogrithm of moving assosiated pair to extender, ref Socket::resolveIfc() tagged DS_ISS_012.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_013"><title>[<glossterm id="iss_013">DS_ISS_013</glossterm>] 20230315 ASdcInsert2 operates incorrectly in case of the number of list comps.</title>
	    <sect3><title>Status</title>
		<simpara>Fixed 20230316</simpara>
	    </sect3>
	    <sect3><title>Intro</title>
		<simpara>The problems discovered when adding EdgeCrp default vert segment slot insertion and tested with 2 edges, ref fap3-vis/modules/avr2.chs, SdcInsertVs.</simpara>
		<simpara>The root-cause of the problem is incorrect update of sdc status - ASdcInsert2 uses weak criteria checking if given comp is already inserted -
		    it check if comp.Prev is connected in Pname.Next. But this works only if comp is before Pname. So status gets false with other conditions and sdc tries to
		    insert the comp again.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_014"><title>[<glossterm id="iss_014">DS_ISS_014</glossterm>] 20230321 Transitions with multi-connecting inputs doesn't indicate invalid result properly.</title>
	    <sect3><title>Status</title>
		<simpara>In progress</simpara>
	    </sect3>
	    <sect3><title>Intro</title>
		<simpara>Lets lood at TrAddVar. If two outputs are connected to the transition input Inp but one of the output doesn't provide iface as expected then the tranistion
		    output will be still valid.</simpara>
	    </sect3>
	    <sect3><title>Solution</title>
		<simpara>To have specific transitions with one-connection inputs.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_015"><title>[<glossterm id="iss_015">DS_ISS_015</glossterm>] [Resolved] 20230403 SdoPairsCount doesn't observes the target existence</title>
	    <sect3><title>Status</title>
		<simpara>Resolved 20230404</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_016"><title>[<glossterm id="iss_016">DS_ISS_016</glossterm>] [Open] 20230403 SdoCompComp doesn't observes the target existence</title>
	    <sect3><title>Status</title>
		<simpara>Postponed ATM. CompComp seems to be unusable at all.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1><title>Tools</title>
	<sect2><title>chs formatting in VIM</title>
	    <sect3><title>Set-up .vimrc</title>
		<programlisting>
			"=====================================================
		    " vim-autoformat settings
			"=====================================================

			"let g:autoformat_verbosemode=1

		    let g:formatdef_yb_chs = '"/media/sf_vbx_shared/projects/fap/fap3/clm/fapm3 -f"'
		    let g:formatters_chs = ['yb_chs']

		    " Disable autoindenting, retab and removing trailing spaces
		    let g:autoformat_autoindent = 0
		    let g:autoformat_retab = 0
		    let g:autoformat_remove_trailing_spaces = 0

		    " map to &lt;Leader&gt;cf
			autocmd FileType chs nnoremap &lt;buffer&gt;&lt;Leader&gt;ff :&lt;C-u&gt;Autoformat&lt;CR&gt;

		    " vim-autoformat settings end
		</programlisting>
	    </sect3>
	</sect2>
    </sect1>

</article>

