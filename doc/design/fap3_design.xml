<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Discrete Events System framework (multiagents based) ver. 3. Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 05-Dec-2020</releaseinfo>

	<abstract>
	    <simpara>This document collects software desing for Discrete Events System (DES) framework ver 3.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>05-Mar-2020</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>

	<biblioentry id="ref_incr_mut"> <abbrev>INCR_MUT</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_incr_syst_creation/index.html "/></productname>
	    <title>Y.Borisov. Using incremental mutation process for systems modeling</title> </biblioentry>

	<biblioentry id="ref_rfc_3986"> <abbrev>RFC_3986_URI</abbrev>
	    <productname><ulink url="httpss://www.ietf.org/rfc/rfc3986.txt"/></productname>
	    <title>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</title> </biblioentry>

	<biblioentry id="ref_ss_cof"> <abbrev>SS_COF</abbrev>
	    <productname>Local copy <ulink url="files://home/yborisov/Documents/Compilators/Konstruirovanie_Kompilyatorov.pdf"/></productname>
	    <title>Sergey Swerdlov. Creating of compilators.</title> </biblioentry>
    </bibliolist>

    <glossary> <title>Glossary</title> 

	<glossentry id="gls_adp"><glossterm>ADP</glossterm> <acronym>ADP</acronym>
	    <glossdef> <para>
		Agents DES adaPtorThe agent dedicated to adapt target agent interfaces to DES. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_dmm_adp"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_asr"><glossterm>ASR</glossterm> <acronym>ASR</acronym>
	    <glossdef> <para>
		DES. Activation on system reconfiguration. The feature where DES is activated on the structure
			reconfiguration. Ref
		    <xref linkend="ds_asr"/> </para></glossdef>
	</glossentry>


	<glossentry id="gls_ascl"><glossterm>ASCL</glossterm>
	    <glossdef> <para>
		Agents specific chromo languge. The approach that allows specific mutations and even chromo syntax for some agents. Ref
		    <xref linkend="ds_ascl"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_cac"><glossterm>CAC</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Chromo but not mutation.  Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cam"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cam"><glossterm>CAM</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Mutation but not chromo. Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cac"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point. Element that is used as endpoint of connections between systems. </para></glossdef>
	</glossentry>

	<glossentry id="gls_chromo2"><glossterm>CHROMO2</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Enhanced version of chromo language. Uses specific syntac instead of xml-based in the initial version. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_chr2"/> for details. </para></glossdef>
	</glossentry>

	<glossentry id="gls_daa"><glossterm>DAA</glossterm> <acronym>DAA</acronym>
	    <glossdef> <para>
		Distributed Agents Approach.  Approach of multi-agent system that assumes that the modes is distributed among several environments that 
			can be running on undependent executable enviromnents. Ref
		    <xref linkend="ds_daa"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_dce"><glossterm>DCE</glossterm> <acronym>DCE</acronym>
	    <glossdef> <para>
			Dedicated Content Element of native hier.  Approach of content support based on dedicated elements of native hier. Ref
		    <xref linkend="ds_dce"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_dcs"><glossterm>DCS</glossterm> <acronym>DCS</acronym>
	    <glossdef> <para>
			DES Control of System, the mechanism of managing some subsystem by DES. 
		    <xref linkend="ds_dcs"/> for desing details </para></glossdef>
	</glossentry>


	<glossentry id="gls_deds"><glossterm>DEDS</glossterm> <acronym>DEDS</acronym>
	    <glossdef> <para>
		Discrete Event Dynamic System,  a discrete-state, event-driven system of which the state evolution depends entirely
		on the occurrence of asynchronous discrete events over time. Although similar to continuous-variable dynamic systems (CVDS),
			DEDS consists solely of discrete state spaces and event-driven state transition mechanisms.  Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete_event_dynamic_system"/></para>
		<glossseealso otherterm="gls_des"/> </glossdef>
	</glossentry>

	<glossentry id="gls_des"><glossterm>DES</glossterm> <acronym>DES</acronym>
	    <glossdef> <para>
		Discrete-Event Simulation - model of the operation of a system as a discrete sequence of events in time.
			Each event occurs at a particular instant in time and marks a change of state in the system. Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete-event_simulation"/></para> <glossseealso otherterm="gls_deds"/> </glossdef>
	</glossentry>

	<glossentry id="gls_dhc"><glossterm>DHC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Direct Hierarchical Chromosome</para> <para>
		Approach of multi-agent system definition that describes the model's structure directly. 
		Ref <xref linkend="ds_smc"/> for discussion regarding chromo desing approaches.
		    Ref <xref linkend="gls_osm"/> for anoter design approach.</para></glossdef> </glossentry>

	<glossentry id="gls_dmc"><glossterm>DMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Dependent Mutations Chromosome</para> <para>
		Chromo definition approach when the mutation can have other mutaions (of node type) as the operands.
		This approach helps defining the model with anonymous nodes that is especially effective for <xref linkend="gls_des"/> models.
		    Ref <ulink url="../../../grayb/doc/design/index.html#gls_dmc"/> for original glossary. </para></glossdef> </glossentry>

	<glossentry id="gls_ddmc"><glossterm>DDMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>
		Direct Dependent Mutations Chromosome structure.
		Chromo structure that directly aligned to
		    <xref linkend="gls_dmc"/>.
			This approach allows to have single unified chromo representation.  Ref
		    <ulink url="ds_ddmc"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_ccn"><glossterm>CCN</glossterm> <acronym>CCN</acronym>
	    <glossdef> <para>
		Compact (and customized) Chromo Notation, approach that focus on having compact notation of model chromo.
		This allows effectivelly creating the model via 'manually' creating chromo of it. Another solution
		is Native Chromo Notation, ref
		    <xref linkend="gls_ncn"/>. </para></glossdef> </glossentry>

	<glossentry id="gls_clm"><glossterm>CLM</glossterm> <acronym>CLM</acronym>
	    <glossdef> <para>Command Line Monitor application <ulink url="../../../grayb/doc/design/index.html#gls_clm"/> for original glossary </para></glossdef> </glossentry>

	<glossentry id="gls_cmt"><glossterm>CMT</glossterm> <acronym>CMT</acronym>
	    <glossdef> <para>Combined Mutation Target.  The approach of specifying target in mutation spec when mutation target and change targets are
		spedified separately. With this approach the target specified with two mutation attribute, ref also <xref linkend="gls_umt"/> for
		    alternative approach.</para></glossdef> </glossentry>

	<glossentry id="gls_cpa"><glossterm>CPA</glossterm> <acronym>CPA</acronym>
	    <glossdef> <para>Connecting Proxy Agent.
		The approach of agents design where dedicated embedded agents play the role of 
		connection points of agent, i.e. doing all connecting relative work instead of agent.
		In contrast of <xref linkend="gls_pia"/> connecting proxy agent provides interface
		    resolution mechanism for the client, so the mechanism is distributed between multiple
		    connecting agents in the model.  </para></glossdef> </glossentry>

	<glossentry id="gls_dmm"><glossterm>DMM</glossterm> <acronym>DMM</acronym>
	    <glossdef> <para>
		DES Managing of Model.  The approach of using DES to manage the generic multi-agent model.
		With this approach it is not needed to have some external native model managing entity, this managing entity
		is implemented as managing DES model, ref also
		    <xref linkend="ds_dmm"/> for details.</para></glossdef> </glossentry>

	<glossentry id="gls_eosm"><glossterm>EOSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		Extended Original Sequence of Mutations chromo language approach- 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase. This approach extends
		    <xref linkend="gls_osm"/> in that, enables segments in mutation output chromo. Initial
		    <xref linkend="gls_osm"/> solution just transormed hierarchical input chromo to flat structre (without segments) </para></glossdef>
	</glossentry>

	<glossentry id="gls_fap2"><glossterm>FAP2</glossterm> <acronym>FAP2</acronym>
	    <glossdef> <para>
		Discrete Events System (DES) framework ver. 2 aka "grayb". Ref
		    <ulink url="../../../grayb/doc/design/index.html"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_irm"><glossterm>IRM</glossterm>
	    <glossdef> <para>Interface resolution mechanism.  <ulink url="../../../grayb/doc/design/index.htmds_ifcache"/>
	</para></glossdef> </glossentry>

	<glossentry id="gls_irmc"><glossterm>IRMC</glossterm>
	    <glossdef> <para>
		nterface resolution mechanism with caching result. This solution reduces access to resolved ifaces, to increase
		the model performance.  Ref
		    <xref linkend="ds_irm_cr"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_ncn"><glossterm>NCN</glossterm> <acronym>NCN</acronym>
	    <glossdef> <para>
		Native Chromo Notation, approach that focus on very simple chromo notation, like
		assembler. It is 'universal', less readable and more suitable for creating model with IDE. Another solution
		is Compact Chromo Notation, ref
		    <xref linkend="gls_ccn"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_osm"><glossterm>OSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		riginal Sequence of Mutations - 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase, ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_mut_osm"/>. Ref
		    <xref linkend="gls_dhc"/> for another approach.  Ref also
		    <xref linkend="gls_eosm"/> for extended solutions.
	</para></glossdef> </glossentry>

	<glossentry id="gls_mae"><glossterm>MAE</glossterm>
	    <glossdef> <para>
		Using monodilic agent instead of embedded.  Optimization approach, where monolitic native agents instead of constructed agents.
		    <xref linkend="ds_mae"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_pia"><glossterm>PIA</glossterm> <acronym>PIA</acronym>
	    <glossdef> <para>
		Properties Instead of embedded auxiliary Agents
		The approach of agents design where properties are using instead of auxiliary agents
		in order to minimize the agents number, ref
		    <xref linkend="ds_pia"/>. Ref <xref linkend="gls_cpa"/> for another connecting solution. </para></glossdef>
	</glossentry>

	<glossentry id="gls_csl"><glossterm>CSL</glossterm> <acronym>CSL</acronym>
	    <glossdef> <para>
		Connecting Same Layer vertices -
		Model creation policy of binding vertexes. According to this policy the only same layer
		vertexes can be connected. The owner of the layer is respondible to verify the policy.
		    <xref linkend="ds_conn_cwdl"/>.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_scc"><glossterm>SCC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		State with Combined Chains. DES state design where data and observing chains are same.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_ssc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_sdc"><glossterm>SDC</glossterm> <acronym>SDC</acronym>
	    <glossdef> <para>
		System DES controller. The mechanism of system structure update controlled by DES where the controlling DES "accesses"
		to managed system structure via a number of specialized systems performing certain mutation. 
		     Ref <xref linkend="gls_adp"/> for another design solution.</para></glossdef>
	</glossentry>

	<glossentry id="gls_sdo"><glossterm>SDO</glossterm> <acronym>SDO</acronym>
	    <glossdef> <para>
		System DES observer. The mechanism of system structure observing compatible with DES.
		     Ref <xref linkend="ds_dcs_sdo"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_slc"><glossterm>SLC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		ockets Loopback Connections. Socket design approach when loopback connections are supported
		    <xref linkend="ds_ifcache_slc"/>. </para></glossdef>
	</glossentry>

	<glossentry id="gls_ssc"><glossterm>SSC</glossterm> <acronym>SSC</acronym>
	    <glossdef> <para>
		State with Separate Chains. DES state design where data and observing chains are separated.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_scc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_uac"><glossterm>UAC</glossterm> <acronym>UAC</acronym>
	    <glossdef> <para>
		Units for Auxiliary Components
		The approach of agents design where "passive" units are used instead of agnents as
		auxiliary components, ref
		    <xref linkend="ds_uac"/>. Ref <xref linkend="gls_cpa"/>, <xref linkend="gls_pia"/> for other connecting solutions. </para></glossdef>
	</glossentry>

	<glossentry id="gls_umt"><glossterm>UMT</glossterm> <acronym>UMT</acronym>
	    <glossdef> <para>
		Unified Mutation Target.  The approach of specifying target in mutation spec.
			With this approach the target specified with just one mutation attribute, ref
		    <xref linkend="ds_umt"/>.  Ref <xref linkend="gls_cmt"/> for alternative approach.</para></glossdef>
	</glossentry>

    </glossary>

    <sect1 id="ds_itr"><title>Intro</title>
	<sect2 id="ds_itr_sp"><title>The scope of the project</title>
	    <simpara>This project is focusing on re-desing of DES framework fap2, aka grayb, ref <ulink url="../../../grayb/doc/design/index.html"/> for
		the desing. Ref also <xref linkend="ds_ibc"/> for tracked list of the items to be addressed in FAP3. The main areas of improvement are:</simpara>
	    <itemizedlist>
		<listitem>
		    Unify of native level relations (connections), like owner-component, observer-observable, etc. Create common desing for the
		    relations.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_i_anr"/> for current desing weakness analysis.</simpara>
		</listitem>
		<listitem>Desing native connections iterating mechanism.</listitem>
		<listitem>
		    Base iface resolution on native level connections.
		    <simpara>Ref <xref linkend="ds_irm"/></simpara>
		</listitem>
		<listitem>
		    Desing content basing on native level connections tree of content units.
		    <simpara>Also look at <xref linkend="ds_cnh"/> for another content desing discussion.</simpara>
		</listitem>
		<listitem>Easy support of anonymous units.</listitem>
		<listitem>
		    System creation language (chromo) optimization.
		    <simpara>Ref <xref linkend="ds_cli"/></simpara>
		</listitem>
		<listitem>Notification mechainsm optimization. Ref <ulink url="../../../grayb/doc/design/index.html#ds_prfopt_ahn"/></listitem>
		<listitem>Fix the IRM problem <ulink url="../../../grayb/doc/design/index.html#ds_i_nrn"/>
		    <simpara>Ref <xref linkend="ds_irm_ut_inv_own"/></simpara> </listitem>
		<listitem>Redesign system navigation mechanism to restrict the access. <simpara>Ref <xref linkend="ds_sn"/></simpara></listitem>
		<listitem>
		    Improve chromo language: support mutations chain (<xref linkend="gls_dmc"/>), use strong parsing.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_mc"/> for FAP2 desing item. Ref <xref linkend="ds_cli"/> for the material.</simpara>
		    <simpara></simpara>
		</listitem>
		<listitem>Redesign import to avoid chromo analysis for selecting imported node. Ref <xref linkend="ds_imp"/> for details.</listitem>
		<listitem>
		    Redesign DES adapter referencing to managed agent.
		    <simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_dmm_irta"/> for details.</simpara>
		</listitem>
		<listitem>
		    Redesign chromo to make it really copyable.
		    <simpara>At least one related use-case is MElem <xref linkend="gls_adp"/> that can mutate managed agent basing on the input
			receiveing chromo. Current chromo desing potentially allows copy (ref DChr2 data based state) but in rather messy way.
			Ref <xref linkend="ds_mcrc"/>
		    </simpara>
		</listitem>
		<listitem>Redesign connpoint extender. Ref <ulink url="../../../grayb/doc/design/index.html#ds_di_wrcpe"/> for desing issue.</listitem>
		<listitem>
		    <glossterm id="ds_itr_sp_rnac">Redesing notification of agent change.</glossterm>
		    <simpara>
			Currently, the agent notifies of its updates to owner, embedded agents and observers. This is too comlicated. We need
			to remain only observer and implement proper native relation observer-observable. Also there should be some policy enabling
			establishing such relation. For instance is embedded agent can set itself as observer there should be acceptance from the embedding agent.
		    </simpara>
		</listitem>
		<listitem>
		    Redesing URI to make is simpler and convenient.
		    <simpara>Ref <xref linkend="ds_urd"/> for details.</simpara>
		</listitem>
		<listitem>
		    Avoid necessity of having dedicated chromo for mutation in inheritable agents. Ref <xref linkend="ds_adcm"/> for details.
		</listitem>
		<listitem>
		    Modify DES cycle to avoid polling the comps but keep the lists of active/updated in owner. Ref <xref linkend="ds_mdc"/> for details.
		</listitem>
		<listitem>Implement <xref linkend="gls_ddmc"/>, ref <xref linkend="ds_ddmc"/></listitem>
		<listitem>Improve means of debugging, ref <xref linkend="ds_dbg"/></listitem>
		<listitem>Keep consistent tree-ish chromo on run-time. Ref <xref linkend="ds_tch"/></listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_itr_dp"><title>Dependent projects</title>
	    <sect3 id="ds_itr_dp_grayb"><title>DES framework fap3, aka grayb, ref <ulink url="../../../grayb/doc/design/index.html"/></title>
	    </sect3>
	</sect2>
	<sect2><title>The philosophy of structured systems.</title>
	    <simpara>All FAP projects are about using structured system as the means of creating big models. Structured system philosophy is very simple:
		there are a number of agents that can be combined according to the topology. The topology connects the agents according to that required for the created model.</simpara>
	    <simpara>The structured sytem creates topology basing on system principles: the big model is separated to smaller parts,
		these parts are also separated etc. So the topology is "hidden" in the clear and well understandable structure.</simpara>
	    <simpara>So the model is created via the creation of proper topology of the given set of pre-defined compoments.</simpara>
	    <simpara>There are a number of models types suitable for such model creation apporach. One of the types is <xref linkend="gls_deds"/> that allows creating
		complex dynamic systems.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_nn"><title>Native net</title>
	<sect2><title>Intro</title>
	    <sect3><title>What is native net?</title>
		<simpara>Native net is the initial topology and environment that allows to create the systems using system (model) creation language.
		    So native net is the "sceleton" of the model. Native net allows to manage all units of the model.</simpara>
	    </sect3>
	    <sect3><title>Institutionalize all the relation on native layer.</title>
		<simpara>The main idea of native net is to support all relations on the native layer via common design approach, common mechanism. Saing "on
		    native layer" we mean the relations that are not seen from the top layer model, for instance the relations created via iface resoluion, 
		    notifications etc.. In fap2 different approaches are used for establishing such relations.</simpara>
	    </sect3>
	    <sect3><title>Distributed env support by native net.</title>
		<simpara>Native net supports interactions between units. Theas mean that these interactions shall correctly work in distributed env. So all
		    ifaces created relations in native net shall be MIface.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>What is difference between native and system level connections?</title>
	    <simpara>Native connection allows creating native net, the connection is like "owner-component", "iface_requetor-iface_provider". System level
		connection is just abstraction of system topology. In fap2 the only base mechanism of MVert-MVert binding is used.
		This connection is to utilize interactions between specialilzed units. The behaviour of such 
		connection is defined via this specifics of connected units.</simpara>
	    <simpara>Parameters of system level connectins are defined via system creaton spec (specifying in terms of system creation language).</simpara>
	</sect2>
	<sect2><title>Considering common desing for native net two-ways relations.</title>
	    <simpara>The serious problem in fap2 was that this desing principle was not supported completely. For instance owned-owner iface is not defined
		properly, huge MUnit is used instead.</simpara>
	</sect2>
	<sect2><title>Interface vs connections</title>
	    <sect3><title>Intro</title>
		<simpara>In fap2 the "atom" of C++ objects interactions is interface, that according to OOP philosophy. However as we see the most of interactions
		    are of 2-ways. The abstraction of 2-ways relation is connection, that covers two interacting interfaces and binding mechanism. Seems the connections
		    can play the role of "atom" when 2-ways interactions.</simpara>
		<simpara>This is also applicable for the interactions in the system layer over native net. Currently the ifaces are resolved over native net. Probably
		    it makes sense to resolve connection points instead.</simpara>
	    </sect3>
	    <sect3><title>Do we need "connecting" iface?</title>
		<simpara>The possible design solution is MIface is extended to introduce connection functions, ref MCIface or MCIface2 in 74ed7dd2. The rationale
		    of such design is that iface can be obtain using the current iface resolution  or local iface providing mechanisms,
		    so as iface supports connection we can connect it. The emotions promoting this desing was "What? Why we need now two abstractions to be taken care -
		    iface and connpoint. Let's have just one."</simpara>
		<simpara>This desing is not clear actually. The iface resolution itself involves connections. As for local iface providing, the specific API can 
		    be addd to access conn points.</simpara>
		<simpara>The idea is: connection is just means of accessing and managing iface. They are not same level abstractions.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>How to implement native connection?</title>
	    <sect3><title>Intro</title>
		<sect4><title>Native connection point vs 2-ways connection iface.</title>
		    <simpara>First idea was to define specific iface for 2-ways connection (allowes connect, disconnect, access to provided and required
			ifaces). That was like this:</simpara>
		    <programlisting>
			template &lt;class TPif, class TRif&gt; class MNcpp
			{
			public:
			    using TPair = MNcpp&lt;TRif, TPif&gt;;
			virtual TPif* provided() = 0;
			virtual bool connect(TPair* aPair) = 0;
			virtual bool disconnect(TPair* aPair) = 0;
			virtual bool attach(TPair* aPair) = 0;
			virtual bool deattach(TPair* aPair) = 0;
			virtual bool isConnected(TPair* aPair) const = 0;
			virtual bool getId(string&amp; aId) const = 0;
			};
		    </programlisting>
		    <simpara>but then trying to implements MVert with this and see that it is needed to use MNcpp&lt;MVert, MVert&gt; instead of just MVert when
			connecting. So the question was why cannot we just introduce iface "iface as part of 2-ways connection" and inherit MVert from it but
			not from MIface. These two solution differs in ifaces inheritance stack.</simpara>
		    <simpara>The "Native conn point" approach: MIface - &lt;provided iface&gt; - connection_iface</simpara>
		    <simpara>The "2-ways connection iface":  approach: MIface - connection_iface - &lt;provided iface&gt;</simpara>
		    <simpara>For "Native conn point" approach we can implement native connection point base class that implements connection_iface. Then from this
			class we can inherit custom connpoint implementing (delegating) provided iface. This isolates conn point functionality from 
			host (e.g Unit) implementation,that seems to be advantage. However intuitively this also seems superfluos. For instance MVert already includes the
			methods for 2-ways connection (connect, disconnect etc).</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_nn_tree"><title>How to implement tree?</title>
	    <sect3><title>Intro</title>
		<simpara>There is the initial implementation (4da8309df913) of the tree node, ref nconn.h:NTnnp or nconn.h:NTnip. But there are doubts regarding the
		    desing, it seems not proper. This is bacause of quite complicated scheme. Actually the "tree node" functionality is implemented on application
		    iface level but not in the tree node class itself.</simpara>
	    </sect3>
	    <sect3 id="ds_nn_tree_si"><title>Design approach: specific iface for tree node.</title>
		<simpara>Currently (4da8309df913) the tree node class is just combination of two connpoints. So it doesnt support upward navigation for instance.</simpara>
		<simpara>We can introduce specific iface for tree node that is both down connpoint&lt;Prov,Req&gt; and up connpoint&lt;Req,Prov&gt;</simpara>
		<sect4 id="ds_nn_tree_si_dtl"><title>How to distinguish tree node and tree leaf?</title>
		    <simpara>This is the problem that gets shown when implementing tree traversal: we need to know if the down connpoint is node or leaf. The one solution
			is to dynamic cast the connpoint to node. Another solution is to extend connpoit API with method getting up/down connpoint. To have ability of travarsal 
			both downwards and upwards we need both such solutions for both way.</simpara>
		</sect4>
		<sect4><title>Cons and pros</title>
		    <simpara>Cons: needs to have stub for one iface up or down</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_nn_tree_bc"><title>Design approach: extended cp api for binded cp, embedded up cp</title>
		<sect4><title>Intro</title>
		    <simpara>The idea is to extend cp api to get up/down  connpoint (<xref linkend="ds_nn_tree_si_dtl"/>) and implemend specific tree node embedded up connpoint
			so that it returns the host as down cp.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2><title>How to simplify the desing of native net.</title>
	    <sect3><title>Intro</title>
		<simpara>Current implementation of native net is quite complicated and not convenient in use. How can we simplify it. Look for instance
		    at firstLeafB().</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_uinn"><title>Units identification in native net.</title>
	<sect2><title>Intro</title>
	    <simpara>It is common practice to use anonymous units of any type (even native net units). For instance ifaces set obtained via iface resolution
		mechanism consists of anonymous units. However units identification is very important: it gives us essential information of unit that
		helps us in case of debug, analysis etc. Also identification is required to resolve the unit in native net, e.g.
		in case of distributed models. The question is what kind of identification shall be used?</simpara>
	    <simpara>In <xref linkend="gls_fap2"/> the only identificator of unit in native tree is the unit name. So anonymous unit is simply unit with
		hidden name.</simpara>
	</sect2>
	<sect2 id="ds_uinn_id"><title>What units in native net need to have identification.</title>
	    <sect3><title>Intro</title>
		<simpara>In <xref linkend="gls_fap2"/> the only ifaces have identification. The focus was to provide native hier creating iface (MUnit) with
		    safe identification mechanism. Other ifaces are identified via MUnit identification plus iface type - so the identifiation scheme is restricted,
		    there is no rule to identify given iface in case of MUnit node includes number of ifaces of same type.
		    Ref <xref linkend="ds_f2dw_isr"/> for the desing weakness description.</simpara>
		<simpara>
		    The question is if we really need to identify all ifaces? The identification require some additional resources.
		    This why in <xref linkend="gls_fap2"/> the exact identification is supported by MUnit only (it supports identification by name and is element of native
			hier, thus can be identified by URI). All other ifaces are "attached" to MUnit so identified via MUnit identification (ref MIface::Mid()).
		</simpara>
		<simpara>Actually identification of ifaces are supported in fap2, ifaces owned MUnit can overload MIface::Uid() to generate unique IDs for each
		    iface (even of same type) but there is mechanism of resolving the iface using this ID. So attempt to have full identification of iface is just
		    attempt of representing iface as unit. Do we really need it? Seems not, because iface is just ptr to virtual func table, so needs the 
		    "carrier" of the iface (i.e. owner of the table).</simpara>
	    </sect3>
	    <sect3><title>Do we need to identify the native units?</title>
		<simpara>Native units provides the means of creating native net. These are native connections, ifaces etc. I cannot see the necessity
		    of identifying these units. The matter is that any identifying is just the means of distinguish the unit within some topology, but we are not going
		    to have dedicatied subnative topology.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_irm"><title>Iface resoluion mechanism (<xref linkend="gls_irm"/>) redesign</title>
	<sect2><title>Intro</title>
	    <itemizedlist>
		<listitem>Ref <ulink url="../../../grayb/doc/design/index.html#ds_ifcache"/> for FAP2 design of iface resolution. </listitem>
		<listitem>In FAP2 the iface resolution cache was implemented as the reolutio mechanism. </listitem>
	    </itemizedlist>
	</sect2>
	<sect2><title>Proposals</title>
	    <simpara>The idea of redesign is to get rid of fap2 iface cache and use native tree of iface providers instead. Each iface request shall
		create specific native tree of providers, so the client can traverse via the tree to get all the ifaces provided.</simpara>
	</sect2>
	<sect2 id="ds_irm_ut"><title>How to update <xref linkend="gls_irm"/> tree?</title>
	    <sect3><title>Intro</title>
		<simpara>The tree created in result of iface request needs to be updated according to the system changes. For instance if system node provided
		    iface is removed then the tree corresponds branch needs to be removed too. How can we implement this updatae of IRM tree?</simpara>
		<simpara>In FAP3 the invalidation apporach was applied: the whole branch is marked as invalid on any provider update, this causes 
		    the cache update on the iface next request.</simpara>
		<simpara>Ref <xref linkend="ds_iss_003"/> for the problem with IFR update on sockets connect/disconnect.</simpara>
	    </sect3>
	    <sect3 id="ds_irm_ut_inv"><title>Solution: branch invalidation via setting invalid indication</title>
		<sect4><title>Intro</title>
		    <simpara>The generic approach is clear. But the questions remain what nodes to mark invalid and how to refresh resolution then.
			This is same approach as FAP2 applied ATM. Revised the approach. Implemented <xref linkend="ds_irm_ut_inv_cno"/> as most
			    safe.</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_ib"><title>Solution#1 Current one. Invalidata the whole branch.</title>
			<simpara>It is not enough that the current provider "passes" all potential providers and refresh the tree. It is also required to
			    go thru all up pairs after that and remove the pairs that are still invalid.</simpara>
			<simpara>Is this approach effective? It is implemented (I stay on ac6c810e11a16f1) but has sowe drowbacks - we need to apply quite complicated schema to 
			    refresh providers tree: when we resolve iface after invalidating current node we need to check if the potential provider already
			    exists in the tree (ref IfrNode::findOwner). This should be done in any resolution methods, so needs to be very carefull to not
			    avoid this checking, otherwise there will be duplicated branches in providers tree. Why don't just remove the whole providers tree in
			    case of invalidating (ref <xref linkend="ds_irm_ut_inv_rb"/>)? Probably the idea was that the valid branches to providers can be re-used.  </simpara>
			<simpara> Seems there is the problem in the current implementation:
			    When the invalidated node is refreshed, it is marked as valid, but when the invalidated providers node is checked on existence
			    then we just omit redirecting to it and it stays invalid. So with this approach we need to check if the node already exists in the path
			    and if the node is invalid then request it for resolving. There is obvious drawback: each resolution code needs to be created very
			    carefully to not avoid this checking of node existence.</simpara>
			<simpara>
			</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_inv_rb"><title>Solution#2: remove the branch</title>
			<simpara>This solution seems not effective. Indeed, what is the reason of removing owners of invalidated node? Actually the owners are not
			    invalid, the current node invalidation doesn't affect the owners validity. The only reason would be to initiate the chan of resolution.</simpara>
		    </sect4>
		    <sect4 id="ds_irm_ut_inv_cno"><title>Solution#3: invalidate only current node, remove owned tree, resolve invalid node in leafs tree-walk.</title>
			<simpara>With this approach we don't need to check existence of node in each resolving procedure, ref <xref linkend="ds_irm_ut_inv"/>
			    We just need to modify the leafs three-walk to check if the node is invalid so refresh resolution.
			</simpara>
		    </sect4>
		</sect3>
		<sect3 id="ds_irm_ut_inv_own"><title>Providers owner iface, notification of provider updated</title>
		    <sect4><title>Intro</title>
			<simpara>We need to support owning of iface providers nodes, the proper way for that is introducing specific iface for the owner.</simpara>
			<simpara>Also the owner iface shall support notification of provider update. This will solve the FAP2 IRM problem
			<ulink url="../../../grayb/doc/design/index.html#ds_i_nrn"/> </simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_irm_cr"><title><xref linkend="gls_irm"/> with caching result (<xref linkend="gls_irmc"/>) </title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to avoid traversing of IRM tree each time the slient requests the ifaces. Caching of ifaces resolved can significantly
		    reduce the time of access to ifaces.</simpara>
	    </sect3>
	    <sect3><title>How to minimize access to root (default) provider node?</title>
		<sect4><title>Intro</title>
		    <simpara>Currently the client requests the root node by the iface name. The Node owning the IRM node uses std::map to keep the nodes.
			So the access to root node also is quite time-consuming. How to simplify the access.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2><title>Proposal of <xref linkend="gls_irm"/> desing improvement</title>
	    <sect3><title>Intro</title>
		<simpara>The current desing (1641500c15) seems a bit overkill. IfrNode implements both provider and requester ifaces. IfrNode also
		    includes ref to the owning node as MIfProvOwner dedicated iface. Can we simplify the design utilizing NTnnp ifaces proxy feature so that the 
		    owning node acts as the provider and requestor.</simpara>
		<simpara>Do we really need MUnit iface? Why don't use directly MIfProv?</simpara>
	    </sect3>
	    <sect3><title>How to access IfrNode attributes, mValid for instance.</title>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_sn"><title>System navigation improvement. Access restrictions</title>
	<sect2><title>Intro</title>
	    <simpara>There is the gap in FAP2 desing: the access to system nodes is not restricted. So any node can access to any node. This can cause the models
		unreliability.</simpara>
	</sect2>
	<sect2><title>GUri improvement: avoid upward navigation</title>
	    <sect3><title>Intro</title>
		<simpara>In FAP2 GUri can specify upward navigation, for instance navigation thru owner to root, direct access root etc. This needs to
		    be disabled. So we don't need such navigation at all. Instead we can have "special nodes" that can be accessed via GUri. Special nodes need
		    to have named specifically, prefix '_' can be used for instance. Owner can be such special node also.
		    such special node.</simpara>
	    </sect3>
	    <sect3><title>Usecase: agents accesses neighbours in owning container.</title>
		<simpara>This is very common case when agent is placed in system so it needs access to other components of this system, e.g to system coppnoints.
		    The agents acs in this case as system's confidant so it is reasonable it has the access to system's internals. How this use-case can be
		    supported? </simpara>
		<simpara>The solution can be as: the agent uses URI with special node "owner", so the navigation goes thru the owner, the client acces the owner
		    via MOwner iface, passing self as the argument. Thus the owner can handle this request specifically - it can check if the requestor is 
		    an agent and event verify if such agent has rights for access to owner's components.</simpara>
	    </sect3>
	    <sect3><title>Use-case: fap2-vis VrController - unit adapter gets path to managed agent upward.</title>
		<simpara>So agent needs access upward its owner.</simpara>
	    </sect3>
	    <sect3><title>Use-case: creating node from parent located in arbitrary layer of hier.</title>
	    </sect3>
	    <sect3><title>Approach#1: node reference in owner.</title>
		<simpara>The idea is that sub-system needs to ask its owner to get required node - owner is the only sub-system "window to the world". The owner
		    prepares the reference to the node for it's components. What is the reference? This is the node that proxies some ifaces, MUnit in case of
		    ref to parent.</simpara>
		<simpara>It some "deep" located node requires access to much upper layer than all the owners have to create such references.</simpara>
		<simpara>With this approach the owners responsibility is to create "environment" for its compoments.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Namespaces support</title>
	    <sect3><title>Use-case: native units</title>
		<simpara>Native units is specific units category, they cannot be accessed via navigation thru native hier. Specific rule is used in FAP2 to
		    distinguish native units in URI: native units are identified by single name.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_sn_aul"><title>[DS_SN_AUL] Access for upper layer. Parents, modules etc.</title>
	    <sect3><title>Intro</title>
		<simpara>Even the generic rule of access restriction is to not allow access to upper layer of native hier, sometimes such access is
		    required. The example is creating "library" of systems and then use them to create heir in lower layer. Another example is 
		    the modules. Also the example is <xref linkend="gls_adp"/> where adapter has to has the access to "adapted" (or monitired) agent that
			is not in the scope of adapters node.</simpara>
	    </sect3>
	    <sect3><title>Approach#1: special nodes</title>
		<sect4><title>Intro</title>
		    <simpara>Special names (predefined?) are introduced, started let's say with underscore, _Import for instance. This names are handled by environment
			when getting access to the nodes named that names.</simpara>
		</sect4>
		<sect4><title>Criticism</title>
		    <simpara>It is unconvenient to use special name in case if we just have some system defined that needs to be used to create heir in
			lower layer.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Using implicit namespace for getting parent</title>
		<sect4><title>Intro</title>
		    <simpara>For getting the parent specific version of getNode() is used. This version gets implicit namespaces. We can utilize
			implicit namespace like "all owners" plus _Imports plus all owners _Modules etc. "All owners" namespace should be for name only whereas
			special names can resolve uri also.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_sn_aul_lnk"><title>Using links</title>
		<sect4 id="ds_sn_aul_lnk_itr"><title>Intro</title>
		    <simpara>Let's consider the problem with <xref linkend="gls_adp"/>
			: adapter agent needs the access to managed agent, the access can be defined with having content "Managed agent URI" but this works only
			if the managed agent takes place within adapter tree.
		    </simpara>
		    <simpara>
			The idea is to introduce "Link" agent that implements "MLink" interface and has content "Managed agent URI". The MLink interface
			gets pointer to given interface (MNode for instance) of Managed agent. Link agent also has connection point provided MLink interface.
			Upper node connects Link agent connection point to the corresponding connection point of adapter.
		    </simpara>
		    <simpara>
			Hmm, we again faicing same problem - to specify this "subject of link" we need to use content "Subject of link URI", so with navigation 
			    restrictions the "Subject of link" shall be in the tree of link that makes almost same inconvenience. Ref
			<xref linkend="ds_sn_aul_lnk_conn"/>
			    for discussing this issue.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_conn"><title>Using Link specific "Connect" mutation</title>
		    <simpara>
			This problem restricted access with content "Subject of link URI" can be solved by introducing Link specific "Connection" mutation.
			Or we can introduce another mutation - "Association". In that case the system thit mutation is applied to checks if Link and node
			with proper interface (MNode for instance) are "connecting" and invokes proper "connect" API of Link.
		    </simpara>
		    <simpara>
			This solution requires some redesign of fap3. Currently MVert iface is "connectable" (is inherited to base iface MCIface) but it assumes
			the connection is of "two-ways" - it also connects to MCIface. But in our case the connection is "asymmetric" - just one side is connectable.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_sma"><title>[DS_SN_AUL_LNK_SMA] Inconvenience when using links for specify managed agent for <xref linkend="gls_adp"/></title>
		    <simpara>
			Using link doesn't allow the adapter to simply swithching to another managed agent. Currently we can use simple switching utilizing adapter
			input InpMagUri - transitions can change managed agent URI quite simply.
		    </simpara>
		    <simpara>
			Actually this problem can be solved if we have the link to managed agents owner but not managed agent itself. In that case the content MagUri and
			input InpMagUri shall specify the managed agent URI from owning node specified by the link.
		    </simpara>
		</sect4>
		<sect4 id="ds_sn_aul_lnk_cohl"><title>Link another inconvenience: "connection" over hier levels</title>
		    <simpara>
			It's very often case where the link needs to be linked from one hier branch to another. The example is "modnav" application.
			In "modnav" Model detail representation view (that is located in Launcher.Window.Scene..ModelDrp) shall contain the link to the model but the model 
			is located in Launcher.Controller.ModelMnt. So we need to mutate Launcher to "connect" the link and the "connection" is established
			directly between different branch nodes crossing hier levels. This is bad system design.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_sn_aul_avcp"><title>Using Accessor agent giving access to manager agent via conn point.</title>
		<sect4><title>Intro</title>
		    <simpara>Using Link approach often leads to bad system desing, ref <xref linkend="ds_sn_aul_lnk_cohl"/>. Alternative solution can be using the 
			standard connections via connpoint. In that case the connection can be structured to keep subsystem isolation.</simpara>
		    <simpara>Indeed, the standard connection point mechanism can provide access to any interface including MNode for instance. What we need is 
			to introduce "managing" agent that includes the connpoint provideing the required iface (MNode for instance) and redirecting IFR request
			to managed agent. The desing can be simplified event more - we can just embed the connpoint into the managed agent, connpoint will
			redirect IFR request to the agent directly.</simpara>
		</sect4>
		<sect4><title>Criticism:</title>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_cli"><title>Chromo language improvement</title>
	<sect2><title>Intro</title>
	    <simpara><xref linkend="gls_dmc"/> chromo was prototyped in the scope of fap2, ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_dmc_proto"/> so
		it was decided that fap3 has to support <xref linkend="gls_dmc"/> chromo language.</simpara>
	</sect2>
	<sect2><title>Support of mutation chain</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_mc"/> for FAP2 desing discussion.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_syntax"><title>Syntax of chromo language.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../../../grayb/doc/design/index.html#ds_chr2_sns"/> for fap2 syntax draft.</simpara>
	    </sect3>
	    <sect3><title>Needs to updata syntax to avoid inproper semantic.</title>
		<sect4><title>Intro</title>
		    <simpara>Currently the <xref linkend="gls_dmc"/> syntax allows connection mutation operand to be node mutations and also segment with
			context (node in context is considering the operand). In this syntax the semantic of segment context as the operand is completely
			imporper. Even using node mutation as operand is not quite correct - the mutation is just the update of the current elem, thinking exactly
			it doesn't has the meaning "node created in result of the mutation".</simpara>
		</sect4>
		<sect4><title>Solution#1: Introduce the rule of operands interpretation.</title>
		    <simpara>The idea is to interpret node mutation  and segment context as the created node in the operand of connection mutation.
			For segment, we need to add some restriction: there should be just one context in the segment.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Get rid of combined node mut</title>
		<sect4><title>Intro</title>
		    <simpara>In chromo2 the obsolete type of mutation is still valid - combined node mutation. This was done for the purpose of 
			compatibility. But actually combined node mutation is same as segment with the node as target context.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_syntax_ss"><title>Sequence of segments</title>
		<sect4><title>Intro</title>
		    <simpara>Often (especially in case of dependent tree-like chromo) it is required to have not only namespace context segment but
			also target segment. For instance transition1 input connects to state, the state value is set, the state input connects to 
			transition2 output. </simpara>
		</sect4>
		<sect4><title>Solution.</title>
		    <simpara>We can allow number of segments with same node as context, for instance:</simpara>
		    <programlisting>
			Trans1/Inp ~ : AStatec { Value = "SI 2"; } @ { Inp ~ : ATrcAdd ... }
		    </programlisting>
		    <simpara>There are two segments here, first one uses anonymous state as target context, the second use same node as namespace.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Syntax definintion</title>
		<sect4><title>Do we need mutation_create_with_chromo?</title>
		    <simpara>This mutation is creation of model node and applying assosiated chromo, note this is single mutation.
			Currently this mutation is valid but same result can be achieved by using simple mutation_create (without chromo) plus
			segment with the created node as target. So the reasonable question is if we really need this mutation_create_with_chromo?</simpara>
		    <simpara>Yes, we do. One of the reasons is that syntax production for model_spec cannot be unabmigous in case of using segment. Indeed the
			full substitution of mutation_create_with_chromo is :</simpara>
		    <programlisting>
			Name : Unit &lt; {
			chromo
			}
		    </programlisting>
		    <simpara>But this also can be defined as (and this is what is real root chromo after model creation):</simpara>
		    <programlisting>
			Name : Unit;
			Name {   (or Name &lt; {)
			chromo
			}
		    </programlisting>
		    <simpara>This makes systax productions quite complicated.</simpara>
		</sect4>
		<sect4><title>Initial</title>
		    <programlisting>
			model_spec = mutation_create_chromo;
			chromo = chromo_node { node_separator, chromo_node };
			chromo_node = ctx_mutation | segment_target | segment_namespace | ctx_mutation_create_chromo;
			ctx_mutation = [context, separator ]  mutation;
			ctx_segment = segment_target | segment_namespace;
			ctx_mutation_create_chromo = [context, separator ] mutation_create_chromo;
			segment_namespace = context_namespace_ext, [separator], segment;
			segment_target = target_primary_segment, [ target_secondary_segment ];
			target_primary_segment = context_target_ext, [separator], segment;
			target_secondary_segment = impliclit_context_unit, [separator] segment;

			(*
			segment = '{', [separator], chromo, [separator], '}';
			*)

			segment = '{', [separator], chromo_node { node_separator, chromo_node }, [separator], '}';

			(* Mutation Create with assosiated chromo *)
			mutation_create_chromo = mutation_create, [separator], segment;

			(*
			context = context_unit { separator, context_unit };
			*)
			context = context_target, context_namespace | context_target | context_namespace;
			context_unit = context_target | context_namespace;
			context_target = (uri | special_name_nearest_namespace), separator, "&lt;";
			context_target_ext = (uri | special_name_nearest_namespace | mutation_create), separator, "&lt;";
			context_node = mutation_node;
			context_namespace = uri, separator, "@";
			context_namespace_ext = (uri | mutation_create), separator, "@";
			implicit_context_unit = context_type;
			context_source = mutation_node | node_uri;

			separator = white_space | end_of_line;
			white_space = ' ';
			end_of_line = ;

			mutation = (mutation_create | mutation_content| mutation_remove | mutation_import
			| mutation_connect | mutation_disconnect | mutation_rename | mutation_move | mutation_comment), ';';
			mutation_create = [name, separator] ":" separator, parent;
			parent = uri;

			#ifdef _DCE_
			mutation_content = [ node_uri, separator ] "=" separator, content_value;
			#else
			mutation_content = [ content_uri, separator ] "=" separator, content_value;
			#endif // _DCE_

			mutation_import = "+" separator, module_uri;
			node_uri = uri;
			module_uri = uri;
			content_uri = uri;
			node_name = name;
			mutation_remove = "!" separator, node_uri;
			(* There is alternative variant, where the target should be owner of node being removed:
			mutation_remove = "!" separator, node_name;
			*)
			mutation_comment = "#" separator, string
			mutation_connect = uri "~" (uri | mutation_create_chromo | mutation_create | segment_target | segment_namespace);
			mutation_connect = left_pair_spec, separator "~" separator, right_pair_spec;
			left_pair_spec = uri;
			right_pair_spec = pair_uri | right_pair_creation;
			right_pair_creation =  mutation_create | chromo_node_segment;
			# chromo_node_segment_with_context interprets in connection mutation as node specified as context source

			name = letter, { letter | digit | "_"};
			special_name = special_name_nearest_namespace;
			special_name_nearest_namespace = "_@";

			uri = [name], { "." , name }
			string = """ { symbol } """;
		    </programlisting>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_dsa"><title>Design of chromo language syntax analyzed and compiler.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ref_ss_cof"/> for studying of basics of syntactic analysis and compiling.</simpara>
		<simpara>Ref <ulink url="https://en.wikipedia.org/wiki/LL_parser"/> for LL(k) parser wiki.</simpara>
	    </sect3>
	    <sect3><title>Can recursive descent parser be used?</title>
		<simpara>As mentioned in <xref linkend="ref_ss_cof"/>:</simpara>
		<programlisting>
		          -
		      -,  LL(1)-.
		</programlisting>
		<simpara>But is the grammar of Cromo2 language LL(k)?</simpara>
	    </sect3>
	    <sect3><title>Syntactic analyiss based on recursive descent parser</title>
		<sect4><title>Intro</title>
		    <simpara>Ref <xref linkend="ref_ss_cof"/>, chapter "  -   " for the theory.</simpara>
		    <simpara>Ref <ulink url="https://en.wikipedia.org/wiki/Recursive_descent_parser"/> for wiki material.</simpara>
		</sect4>
		<sect4><title>Predictive parser vs table-based parser.</title>
		    <simpara>There are two variants of parsing: predictive parser ("  " in <xref linkend="ref_ss_cof"/>) and
			table-based parser (" "  in <xref linkend="ref_ss_cof"/>). </simpara>
		    <simpara>Let's protorype predictive parser first.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_cii_ascl"><title>Agent specific chromo-language (<xref linkend="gls_ascl"/>).</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the chromo is the language of mutation of base agent - Elem in FAP2. So it can be applied for any Elem derived agents.
		    In earlier implementation so called "custom mutations" were considered, for instance the mutation "connect". But later "connect" mutation
		    was included in the base mutations set.
		</simpara>
		<simpara>
		    The drawback of this approach is clear - it doesn't allow to utilize the advantage of core FAP desing prinicple "The model is created by
		    mutating agent." (initially root agent). With current approach it is not possible to have optimized mutation language for agent specific mutation.
		    The idea of the current approach was that there shouldn't be specific mutation and that all cases can be simply covered by mutating the base
		    agent (Elem).
		</simpara>
		<simpara>
		    The question is if there really can be some custom mutations? Seems so. For instance we can constider "transition" agent that 
		    uses compact notations for transition agents, like Add instead of ATrcAddVar.
		</simpara>
		<simpara>
		    Note that FAP2 already support this partially. Indeed, the base agent mutation APIs are virtual so base agent hier can overload
		    the mutation processing.
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_ascl_bdp"><title>Base desing principle of </title>
		<sect4 ><title>Any agents should allow mutating even if the agent can be not allowing derivation.</title>
		    <sect5><title>Intro</title>
			<simpara>
			    FAP2 intoduced two types of agents, mutable and not-mutable. Actually both types are updated via mutation, the only difference is
			    that "non-mutable" agent don't kept its own mutation, so are not derivable in some sense. Instead they are mutated by theirs owners.
			</simpara>
		    </sect5>
		</sect4>
		<sect4><title>Common chromo internal structure.</title>
		    <simpara>
			Chromo is just the data describing the mutations. This data can be represented in different forms. There should be internal chromo 
			representation that is kept in the model any agents. This is important because we can imagine the model where is agent A and its
			compoment B at that mutations of B is B-specific but B is not derivable. So agent A keeps the whole mutation. And even A cannot 
			"understand" B-specific mutation A shall be able to keep them.
		    </simpara>
		    <simpara>
			Also the <xref linkend="gls_osm"/> approach currently applied presumes that models any agent keeps the
			<emphasis>whole</emphasis> chromo, including chromo of it's componetns.
		    </simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2><title>Mutation of root content instead of specific content set mutation.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    FAP2 uses specific content set mutation syntax to define hierarhical content. So FAP2 implements specific parser for this syntax.
		    Probably we don't need this specific parser if we consider content as native hier node that can be mutated. In that case the mutation of 
		    root content node in content nodes hierarchy can be used instead.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_pi"><title>Proposal of <xref linkend="gls_chromo2"/> improvement</title>
	    <sect3><title>To make chromo end symbol (";") not required if there is EOL.</title>
	    </sect3>
	    <sect3 id="ds_cli_pi_pn"><title>To introduce special pseudo-names</title>
		<simpara>
		    "Special name" approach can help us to make chromo more compact. We already use symbol "$" as special name of "whatewer"
		    in mutation "Comment"
		</simpara>
		<simpara>In some cases it seems usefull to have pseudonames for some special nodes. For instance the pseudoname can be using
		    to explicitly designate namespace: this approach can simplify namespace node direct modifying within the section with namaspace context.</simpara>
		<simpara>Note that some pseudo-name cannot be used in URI in general. For istance nearedt name space is defined in mutation context but
		    not native hier one, so it cannot be used in URI.</simpara>
	    </sect3>
	    <sect3><title>To introduce "Inactivity" context to solve the problem with comments.</title>
		<simpara>
		    Ref <xref linkend="ds_cli_icc_cfc"/> for the FAP2 chromo language weakness. To solve this problem
			we can just introduce new context of type "Inactive". This context applied to the mut or segment just makes it inactive.
		</simpara>
	    </sect3>
	    <sect3><title>To introduce segment type depending on context.</title>
		<simpara>
		    For instance the segment type "target" is can have "{}" boundaries, but "namespace" segment - "()".
		</simpara>
	    </sect3>
	</sect2>
	<sect2><title>FAP2 chromo language analysis and criticism.</title>
	    <sect3><title>Do we really need namespace context?</title>
		<simpara>
		    Namespace helps to make transition notation compact with <xref linkend="gls_dmc"/>. But it is still not perfect, ref
		    <xref linkend="ds_cli_icc_uncs"/> for instance. What helps NS context to do in
		    <xref linkend="gls_dmc"/>? Just to compact (i.e. without full URI) specify the inputs in the connectins chain plus have a new segment
			(this is important to create hierarchical chromo structure that is more readeable that the flat structure).
			Can we specify it compact in another way?
		</simpara>
		<simpara>
		    Note that the context types actually are not independent. Indeed, the target context means also that target node is also namespace.
		</simpara>
	    </sect3>
	    <sect3><title>Is it OK to use segments for forming connections hierarchy?</title>
		<simpara>
		    FAP2 <xref linkend="gls_dmc"/> uses segments plus namespace context to form connections hierarhy represetation of 
			hierarchical stype. But is using segments really nesessary?
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_icc"><title>What seems inconvenient in the FAP2 current chromo (<xref linkend="gls_chromo2"/>, <xref linkend="gls_dmc"/>)</title>
	    <sect3 id="ds_cli_icc_uncs"><title>Using namespace context symbol in <xref linkend="gls_dmc"/> chromo.</title>
		<simpara>
		    It needs to be used wastely in case of complex transition.
		    It really seems messy to see a lot of "@" in chromo.
		</simpara>
	    </sect3>
	    <sect3><title>Cannot simply specify chromo of last-created anonymous agent.</title>
		<simpara>
		    It is common case when required to specify some mutation of newly-created anonymous agent in connection heirarchy with
		    <xref linkend="gls_dmc"/>. New chromo syntax (ref
		    <xref linkend="ds_cli_syntax_ss"/>) allows to do it having two subsequent
			namespace and target segments. However it is not convenient. The solution would be to use special name designating the
			top namespace agent, like that (compate to
		    <xref linkend="ds_cli_syntax_ss"/>):
		</simpara>
		<programlisting>
		    Trans1/Inp ~ : AStatec @ { _N &lt; Value = "SI 2"; Inp ~ : ATrcAdd ... }
		</programlisting>
	    </sect3>
	    <sect3><title>Comment syntax is too complicated.</title>
	    </sect3>
	    <sect3 id="ds_cli_icc_cfc"><title>Cannot to simply comment out some fragment of chromo.</title>
	    </sect3>
	    <sect3><title></title>
	    </sect3>
	</sect2>
	<sect2 id="ds_cli_sno"><title>Issue: cannot specify namespace in <xref linkend="gls_osm"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    This happens when namespace is specified for segment and some node is created within this segment and mutated then.
		    It's clear that the namespace will be propagated to all muts within the segment.
		    Let's look at what will be the root node chromo after <xref linkend="gls_osm"/> transformation.
			Mut of newly created node the namespace will be "upper" than the target (target is the newly created node). But specifying "upper" node cannot be
			done via regular URI (that is relative to the target) but via absolute URI only (absolute URI is also prohibited in chromo.)
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_sno_s1"><title>Solution#1 special mutations for segment start and end</title>
		<simpara>
		    <xref linkend="gls_osm"/> tranform hierarchical chromo to the flat chromo. This is the root-cause of the problem. With flat
			chromo we cannot keep the namespece in segment mutation (we just don't have segment in
		    <xref linkend="gls_osm"/>. The idea is to have segment mutation in <xref linkend="gls_osm"/> by introducing the mutation
			for segment start and end (like begin and end keywords
			in Pascal). Thus the namespace will be stated for segment begin mut but not propagated to segment's "internal" muts.
		</simpara>
	    </sect3>
	    <sect3 id="ds_cli_sno_s2"><title>Solution#2 Enable segments in <xref linkend="gls_osm"/></title>
		<sect4><title>Intro</title>
		    <simpara>
			Actually segments dont contradict to OSM. It is just the implementation of muts propagation that converts segments to 
			muts flat sequence. We can keep the serments and propagate them to owners. We need to modify procedure of propagation.
			We need to know that the mutation is propagated in scope of segment.
		    </simpara>
		</sect4>
		<sect4><title>What about propagation "below" segment?</title>
		    <simpara>
			Let's consider the case: node A is mutated with serment MS including namespace. There is A component B.
			Within the segment is mutation M targeted to B. How can we specify namespace of M in B? There is no segment MS in B chromo.
			So ne need to specify namespace explicitly, i.e. we still have provlem with namespace. So this solution doesn't work.
			Again, to correctly support of inheritability of B we need to keep mutation context in B mutations.
			Same problem with solution#1. Both solutions are based on the idea that we can specify context in segment only and
			propagate context implicitly to lower layers.
		    </simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_cli_sno_s3"><title>Solution#3 Enable namespace for only serments direct mutations. </title>
		<simpara>Seems this limitation solves the original problem. With the limitation  Solution#1 and Solution#2  also shell work.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Issue: weak design of namespace support in <xref linkend="gls_osm"/></title>
	    <sect3><title>Into</title>
		<simpara>The desing gaps is:</simpara>
		<itemizedlist>
		    <listitem>Curently only one namespace can be specified in mut. But if we specify namespaces for two nested node that the 
			"lower" mut will actually have two namespaces applied. How this mut can be represented in <xref linkend="gls_osm"/> form?
			    Both namespeces should be specified but just one is supported.</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_eosm"><title>Extended <xref linkend="gls_osm"/> - <xref linkend="gls_eosm"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    Current <xref linkend="gls_osm"/> implementation  generates "inconvenient" bad readeable output chromo. The question is if the approach 
			can be improved by enabling segments propagation to the output chromo.
			Ref <xref linkend="ds_cli_sno_s1"/> and <xref linkend="ds_cli_sno_s2"/> that introduce the possible approaches to this.
		</simpara>
		<simpara>Ref <xref linkend="ds_iss_001"/> for related issue.</simpara>
	    </sect3>
	    <sect3 id="ds_eosm_s1"><title>Solution#1 Checking of parent mutation from the mut context.</title>
		<sect4><title>Intro</title>
		    <simpara>The idea is to set the mutation to the chromo at the beginning of the mutation applying. Then
			apply the owned muatitions from the current node if the current node is the composite mutation. Mutation context of
			this owned mut applying needs to be modified - add the current composite mutation ref as "owning node". Propagation of owned mutation in
			onOwnedMutated also needs to be modified: to check if the mutation context "owning node" is alreasy in chormo, in that case
			deny the mut propagation.  </simpara>
		    <simpara>The provlem with this approach is that checking of mutation context is qute complicated. The direct way to do it is just
			search the context ("owning node") in the node chromo so the full traverse thru chromo is required.</simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>I tried to implement it but it didn't work for some reason. So focused on <xref linkend="ds_eosm_s2"/></simpara>
		    <simpara>The solution dev branch is yb_dce_eosm_s1.</simpara>
		</sect4>
	    </sect3>
	    <sect3 id="ds_eosm_s2"><title>Solution#2 Checking mutation originator node when propagaring mut</title>
		<sect4><title>Intro</title>
		    <simpara>
			This is similar to <xref linkend="ds_eosm_s1"/> but the mutation context checked on mut propagarion is not
			    a parent mutation but mut originator node. Actually this approach is already used in the current
			<xref linkend="gls_osm"/> solution, ref MutCtx::mNode.
		    </simpara>
		</sect4>
		<sect4><title>Status</title>
		    <simpara>Implemented over eed4231d23f6.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_ddmc"><title>Direct <xref linkend="gls_dmc"/> chromo structure - <xref linkend="gls_ddmc"/></title>
	    <sect3><title>Intro</title>
		<simpara>The main idea is that current chromo is actually a complex tree. For instance: Q arg of connection mut can be 
		    simple URI. Or it can be dependent creation mut (in that case the actual Q arg is P arg of this dependent creation mut). Or
		    it can depend on namespace segment, in that case conn mut Q arg is this namespace segment "namespace" context.</simpara>
		<simpara>So there actual relation between connection mut Q arg and another dependent mut parameter. However in the current
		    chromo2 implementation this relation doesn't exists explicitly. The relation is implemented via name (ID); the name is resolved
		    on chromo parsing phase and the relation is set.</simpara>
		<simpara>This approach is quite reasonable. In result of <xref linkend="gls_dmc"/> chromo parsing we get simple <xref linkend="gls_osm"/> chromo
		    where the dependencies are resolved via the names (ID) substitution and stated in form of name references in the model native hier.
		    So what is the problem here? The problem is that the original chromo and
		    parsed chromo has different structure. The ouput chromo can be "reused" but its representation is not convenient.
		    The possible solution is to convert it back to <xref linkend="gls_dmc"/> but this complicates the whole process.</simpara>
		<simpara>Is it possible to have chromo structure aligned with the structure of <xref linkend="gls_dmc"/> chromo syntax?</simpara>
	    </sect3>
	    <sect3><title>Solution#1 References of given type to depending mutation.</title>
		<sect4><title>Intro</title>
		    <simpara>Mut include args both as values and references to depending mutation. The reference is typed. The types
			means what depending mutation parameter the reference is to. Actually we can define default reference for each mutation type and
			use this default relation type. For instance mut of type "creation" has default relation to name of created node; mut
			of type "segment" has default relation the name of context (it is assumed that either the name of context is unambiguos,
			i.e eihter the context is single, or same value both for target and namespace).  </simpara>
		    <simpara>It is possible to have the chain of references. For instance connection attr Q references to namespace segment mut
			(i.e. to namespace context value). The namespace context value in turn references to mut of "creation" type (i.e to 
			name of created node).</simpara>
		</sect4>
		<sect4><title>How to apply the mutation with the reference.</title>
		    <simpara>If the mut being applied has the ref then the ref is applied first.</simpara>
		</sect4>
	    </sect3>
	    <sect3><title>Status</title>
		<simpara>20210417 Decided to postpone the feature. The reason is that the problem with generated chromo output in pure
		<xref linkend="gls_osm"/> flat format is still not solved, ref <xref linkend="ds_eosm"/>.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dce"><title>Dedicated content element of native hier (<xref linkend="gls_dce"/>)</title>
	<sect2><title>Intro</title>
	    <simpara>
		This section if for discussing specific content desing solution. In earlier FAP version the complex content was implemented as
		unit components, i.e. was the part of model native hier. In further FAP versions this was changed - the content was moved from native hier
		to Unit internals, so specific MUnit API was introduced. This idea was to simplify native hier thus to improve the model performance. 
	    </simpara>
	    <simpara>Current FAP3 content designg is not perfect obviously. </simpara>
	</sect2>
	<sect2 id="ds_dce_uc"><title>Use-cases</title>
	    <sect3 id="ds_dce_uc_01"><title>[DCE_UC_01] Function result as content.</title>
		<simpara>
		    There was such technic used to visualize function - dedicated content was created for the function result. This content was
		    observed from UI and visualized in a compact manner (even inside the function agent visial representation).
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_uc_02"><title>[DCE_UC_02] Model visualizatio: content is hidden.</title>
		<simpara>
		    The content is normally hidden when model is visualized. Oherwize the structure were very complex and hard upderstandable.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_uc_03"><title>[DCE_UC_03] Self content</title>
		<simpara>
		    To optimize the model some agents (state for instance) can support content by itself.
		</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Pros</title>
	    <sect3><title>Content language is no needed, chromo language is used instead.</title>
		<simpara>Current design - Conent language. Set content of conn point:</simpara>
		<programlisting>
		    |  Cp : ConnPoint {
		    |      $ = "{ Provided:'Iface1' Required:'Iface2;}";
		    |  } 
		</programlisting>
		<simpara>Embedded to native hier, content items to be created (Prop is the base Property agent):</simpara>
		<programlisting>
		    |  Cp : ConnPoint {
		    |      Provided : Prop = 'Iface1'; Required : Prop = 'Iface2;
		    |  } 
		</programlisting>
		<simpara>One more example of <xref linkend="gls_dce"/> - Debug property.</simpara>
		    |  Agt : AStatec {
		    |      Debug : Prop {
		    |          Update = "yes";
		    |          LogLevel = "20";
		    |      }
		    |  }
	    </sect3>
	</sect2>
	<sect2><title>Cons</title>
	    <sect3><title>Requires native hier node for each content.</title>
	    </sect3>
	    <sect3><title>Content owner needs to sign up for observing content nodes change.</title>
		<simpara>
		    In current FAP3 solution native CP of ContentOwner alredy has method of notification. With new approach we need to utilize
		    standart node notification mechanism.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dce_dso"><title>Desing outline</title>
	    <sect3><title>MCont iface and Content node</title>
		<simpara>
		    We need to introduce new elements of native hier - node. Node can just support owner-owned relation and have content.
		    Aslo dedicated iface "MCont" needs to be defined to support property (i.e. content). It makes sense that normal agents doesn't implement.
		    Agent Prop is implemented this iface. Prop can owns other Props only. 
		</simpara>
	    </sect3>
	    <sect3><title>Content nodes (properties) are distinguish from ohter nodes.</title>
		<simpara>
		    We need to means of distinguishing of MCont node from other. This is required to process properties in a separate manner, ref use-cases
		    <xref linkend="ds_dce_uc_01"/>,  <xref linkend="ds_dce_uc_02"/>
		</simpara>
	    </sect3>
	    <sect3><title>Content provider specific mutation - "set value"</title>
		<simpara>
		    Interesting but if keeping content is the ability just Content nodes then the mutation "Content" gets only MCont specific, ref
		    <xref linkend="ds_cii_ascl"/> for related desing item.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dce_dso_coi"><title>Do we need to have also iface for content owner?</title>
		<simpara>
		    This iface could be indented for nodes that owns content provider. The iface could contain FAP2-like content API -
		    to get content by name, URI etc. Potentially this will be simple wrappers over narive hier and MCont but potentially the iface
		    can make content desing more clear.
		</simpara>
	    </sect3>
	    <sect3><title>How to notify of content change.</title>
		<simpara>
		    <simpara>
			Current FAP Unit supports notification of content changed and agent changed. How this will be desingned in 
			<xref linkend="gls_dce"/>
		    </simpara>
		    <simpara>
			Ref <xref linkend="ds_itr_sp_rnac"/> regarding re-desing of notification scheme. There will not be dedicated notif of 
			    content change. Instead it is up Prop owner to observe the notif of Prop change and generate it's own "Changed" notif.
		    </simpara>
		    <simpara></simpara>
		</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_chmc"><title>Creating heir: using mutation context.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 the problem of mutating of "temporary" nodes (ref
		<ulink url="../../../grayb/doc/design/index.html#ds_daa_itn"/>) is solved with solution 
		<ulink url="../../../grayb/doc/design/index.html#kds_daa_itn_sfo"/> - mutation context is used. Is this solution suitable with FAP3 dsign?
	    </simpara>
	    <simpara>On FAP2 the problem initially was with distributed models - in such model Uid() is used as node ID so the regular ID based on native hier
		doesn't work for temp nodes not attached to hier yet.</simpara>
	</sect2>
	<sect2><title>Why dont't attach the heir to the parent.</title>
	    <simpara>From the first glance it is ok just to attach the hier to parent before mutating by parents chromo. However this straighforward
		approach has some drawbacks. Firt one is that attaching the hier shall cause the IRM tree invalidating. This can cause a big overhead especially
		if parents chain is quite long.</simpara>
	</sect2>
	<sect2><title>Keep current solution but have context as MOwner.</title>
	    <simpara>So we can use the current solution - using the context. The only change would be to have context as MOwner to restrict the access.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_urd"><title>URI re-desing</title>
	<sect2><title>Use-cases</title>
	    <sect3><title>URI can designates both absolute and relative path to node.</title>
	    </sect3>
	</sect2>
	<sect2><title>Design outline</title>
	    <sect3><title>Absolution vs relation.</title>
		<simpara>Absolute URI has mostleft relation symbol.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Do we need designation of the current node?</title>
	    <simpara>Currently the "current node" URI is just the empty URI. This is reasonable for URI is just the "path" to the node,
		empty path means "no need to go, you are already here".</simpara>
	</sect2>
	<sect2><title>Do we need designation of the root node?</title>
	</sect2>
    </sect1>

    <sect1><title>Chromo of element: Node or Segment?</title>
	<sect2><title>Intro</title>
	    <simpara>
		Originally the chromo of element is the mut of Node type. It contains name and parent. The idea was that the chromo should be
		the whole info to create this elem. But this logic is not quite reasonable - actually Node mut is the mut to create the node and add it
		to the owner as its comp. Node mut is the mut of the owner actually. What is the mut of element itself is the segment of this Node mut -
		it is the mut the has to be applied to elements parent to get the element.
		So the question is if we need elem chromo to be Node mut or segment?
	    </simpara>
	    <simpara>In other words: what is chromo of element: mut of adding the element to owner or mut the element parent? </simpara>
	    <simpara>The rationale of Node variant is that it tells "Get the given parent and mutate it via given segment".</simpara>
	</sect2>
    </sect1>

    <sect1 id="sec_att"><title>Is it possible to avoid using "attached" property.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 the
		<xref linkend="gls_osm"/> mutation solution uses agent "attached-to-chromo" property to decide if the agent mutation
		    needs to be propagated or not. However this property is rather trkcky calculated. The question is if this property
		    is fundamental part of
		<xref linkend="gls_osm"/> mutation process or can be replaced by simpler mechanism.
	    </simpara>
	</sect2>
	<sect2><title>Approach#1: using mutation context.</title>
	    <simpara>
		"Deattached" agents are the agents created by parent in the scope of parents creating its hier. So if we set mutation context as 
		the created hier then we can use the context to stop propagating the mutation.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_f2dw"><title>FAP2 design gaps and weaknesses</title>
	<sect2 id="ds_f2dw_isr"><title>Ifaces identification scheme is restricted.</title>
	    <simpara>In <xref linkend="gls_fap2"/> the only ifaces have identification. The focus was to provide native hier creating iface (MUnit) with
		safe identification mechanism. Other ifaces are identified via MUnit identification plus iface type - so the identifiation scheme is restricted,
		there is no rule to identify given iface in case of MUnit node includes number of ifaces of same type.
		Ref <xref linkend="ds_uinn_id"/> for the desing consideration.</simpara>
	</sect2>
	<sect2 id="ds_f2dw_ccnu"><title>Creating complex native unit is not supported safely</title>
	    <simpara>It is often required to create "complex" native unit, adding componentes, changing context etc. This is more effective that create
		the unit spec in module. But this direct creation of "complex" native unit is not supported properly.</simpara>
	</sect2>
    </sect1>

    <sect1><title>Giving "Changeable" ability to Node</title>
	<sect2><title>Intro</title>
	    <simpara>
		Currently the only MElem is truly mutable, even Unit also can be changed. It make sense to generalize mutable/changeable desing.
		We can give changeable ability to lower layer, havng method "Mutate" in it. The method actually will change but not mutate
		(the term "Change" designates here the ability to be changed but not propagate this change to childs).
	    </simpara>
	</sect2>
    </sect1>

    <sect1><title>Having pre-created Root node in the model.</title>
	<sect2><title>Intro</title>
	    <simpara>
		Currently the root is created via rather tricky procedure: env gets it's parent from chromo and creates it. More reasonable
		would be just pre-create "true Root" and then mutate it with given chromo.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_adcm"><title>Avoid necessity of having dedicated chromo for mutation in inheritable agents.</title>
	<sect2><title>Intro</title>
	    <simpara>
		In FAP2 base inheritable agent Elem contains two chromo: one for mutation and another for chromo of itslef. This creates overheads in
		design. 
	    </simpara>
	</sect2>
	<sect2><title>The reason why it was designed that way in FAP2</title>
	    <simpara>
		There is known dilemma in mutable agent - what is the change object - mutation (
		<xref linkend="gls_cam"/> approach) or chromo (list of mutations) (
		<xref linkend="gls_cac"/> approach). In FAP2 it was assumed
		    the the change object is chromo. So the design was corresponding: there was emvedded "mutation" member of Chromo type. Incoming
		    mutation went to this chromo and then the whole chromo was applied.
	    </simpara>
	</sect2>
	<sect2><title>Initial design considerations</title>
	    <sect3><title>Can be the dilemma solved in favor of "change is mutaion"?</title>
		<simpara>
		    Current desing of Chromo2 allows mutation containing chromo. Each mutaion node contains chromo segment. So let's
		    apply <xref linkend="gls_cam"/> for FAP3.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_adcm_pamcc"><title>Problem with applying mutation_create_chromo.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Wiht <xref linkend="gls_cam"/> in FAP3 the problem occurs whent we apply mutation_create_chromo. To apply
			this mutation we need to apply "create" mutation first and then the embedded chromo as segment. But for
			that we need to transform the given mut to segment. Current chromo design doesn't allow to do it properly till
		    <xref linkend="ds_mcrc"/> is not done. 
		</simpara>
		<simpara>There are two options: #1 to disable mutation_create_chromo at all, #2 to have <xref linkend="ds_mcrc"/> done and 
		    transform mut to segment in mutAddEem. Let's use workaround ATM, ref code Node::mutate() aTreatAsChromo param.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mdc"><title>Modify DES cycle to avoid polling the comps but keep the lists of active/updated in owner.</title>
    </sect1>

    <sect1 id="ds_mcrc"><title>[DS_MCRC] Redesign chromo to make it really copyable.</title>
	<sect2><title>Intro</title>
	    <simpara>Let's apply the simplest solution. We just need to update ChromoNode to be copiable - just replace ref to model by 
		ptr to model. Also a number of small updates of chromo2 is needed.</simpara>
	</sect2>
	<sect2><title>Status</title>
	    <simpara>Implemented in next of 0297b38cfca8.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_tch"><title>Keep consistent tree-ish chromo on run-time.</title>
	<sect2><title>Intro</title>
	    <simpara>Currently (0297b38cfca8) the chromo of created model differs from the original chromo - the resulted chromo
		is not same fully tree-ish as the original chromo. For instance the mutation. Ref ut_des_dmc_1.chs as example.
		Input chromo:</simpara>
	    <programlisting>
		|  St1.Inp ~ : TrAddVar @ {
		|      _@ &lt; Debug.LogLevel = "Dbg";
	    </programlisting>
	    <simpara>Resulted chromo (ut_des_dmc_1_saved.chs):</simpara>
	    <programlisting>
		|  TrAddVar_279 : TrAddVar;
		|  TrAddVar_279 @ {
		|      _@ &lt; Debug.LogLevel = "Dbg";
	    </programlisting>
	    <simpara>Actually there are two problems here:</simpara>
	    <itemizedlist>
		<listitem>
			#1 Input tree-ish chromo is parsed into non-treish chromo2. Chromo2 model is not tree-ish.
		    <para>Ref <xref linkend="ds_tch_c2nt"/> for analysis</para>
		</listitem>
		<listitem>#2 Tree-ish chromo is not suitable for simple <xref linkend="gls_osm"/> mutation scheme.</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_tch_c2nt"><title>Input tree-ish chromo is parsed into non-treish chromo2. Chromo2 model is not tree-ish.</title>
	    <sect3><title>In chromo2 the dependencies are resolved.</title>
		<simpara>The tree-ish structure of input chromo is caused by the dependencies within the chromo. The main
		    dependency is on the node that shall be created by some mutation. In the example above this node is
		    anonymous node TrAddVar_279.</simpara>
		<simpara>Currenly this dependency is resolved on chromo parsing phase, so the node creaton mutation is "extracted"
		    from the tree and node name is use for dependency resolution. This allows to keep the current "linear"
		    sequence of mutation: one by one.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_tch_c2t"><title>Approach: make chromo2 model fully tre-ish, remove ChromoNode wrapper and used chromo2 directly</title>
	</sect2>
    </sect1>

    <sect1 id="ds_ams"><title>Agents mechanism support</title>
	<sect2><title>Intro</title>
	    <simpara>We have <xref linkend="ds_sn"/> implemented in FAP3. So now the MOwner interface doesn't provide the MNode iface to 
		node components. How can we support embedded agents desing approach in that case? Agents normally requires full access to 
		agents manageable host.</simpara>
	</sect2>
	<sect2><title>Solution#1 Special connection point for agents.</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to have dedicated interfaces for agent and host (there is already iface MAgent defined for agents) and
		    dedicated connection point in system and agents to connect them. MOwner APIs needs to be extended by the method of
		    connecting agent or better to introduce interim iface to connect (it is not proper idea to add the method to MOwner iface
		    that doesn't know of agents at all). So the agents will request the owner to connect is as agent.</simpara>
	    </sect3>
	    <sect3><title>How restrictions policy can be applied.</title>
		<simpara>With this approach the system (host) can decide if it accepts connection request from agent or not. This mechanism can
		    be even extended - the system can ask some agents to accept connecting new agent. So we can simply customize the policies with 
		    special agents.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_imp"><title>Redesign import</title>
	<sect2><title>Intro</title>
	</sect2>
	<sect2><title>Parent's resolution mechanism.</title>
	    <sect3><title>Intro</title>
		<simpara>It is very important to simplify specifying parent in system chromo. The best way is to specify just parent's name. But in that case
		    we need to specific mechanism to resolve parent by its name.</simpara>
		<simpara>Refer issue <xref linkend="iss_008"/> for the related issue.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_asr"><title>State activation on input provided ifaces change - Activation on System Reconfiguration (<xref linkend="gls_asr"/>)</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <ulink url="../requirements/index.html#fap3_uc_ica"/> for use-case</simpara>
	</sect2>
	<sect2><title>Design solution: using <xref linkend="gls_irm"/></title>
	    <simpara>
		First idea was that corresponding "source" state has to notify the destination state of input updated. But the use-case is that
		the state has to be activated even in case of connection removing. So seems the most sutable design solution at the moment is to use
		<xref linkend="gls_irm"/>. We just need to add notification on IRM node invalidation event.
	    </simpara>
	    <simpara>Tried this approach, seems it is not working. The number of problems were discovered, <xref linkend="ds_asr_pnc"/> and more.</simpara>
	</sect2>
	<sect2><title>Desing solution: using DES input observer interface.</title>
	    <simpara>This solution seems simple. Actually what we need is to notify any DES change via this interface. But there are use-cases showing this 
		approach limitations, ref ut_des_asr_2.chs - connpoints here are not connected directly but via sockets. So this pure approach neither doesn't work.</simpara>
	</sect2>
	<sect2 id="ds_asr_cbs"><title>Desing solution: update detection via IRM and notification via DES inp observer.</title>
	    <simpara>We can use the "combined" solution: to get the event of unit change via IRM and then use DES inp observer net to activate DES.</simpara>
	</sect2>
	<sect2 id="ds_asr_pnc"><title>Issue: IFR MDesInpObserver path is not created from constant.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref test/ut_des_asr_1.chs. ASR doesn't work for this test. The root-cause is that MDesInpObserver path is not created for 
		    Const_1 because "confirm" doesn't try to notify, the constant state is not updated actually - both updated and confirmed values are equal.</simpara>
		<simpara>State (and const state also) notifies the inp observers on "value" content set, but the problem here is that at content set moment
		    the Const_1 is not connected so IFR path isn't formed.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dcs"><title>DES control of system (<xref linkend="gls_dcs"/>)</title>
	<sect2 id="ds_dcs_itr"><title>Intro</title>
	    <sect3 id="ds_dcs_itr_cs"><title>The current solution: mutation via DES adapter.</title>
		<simpara>Currently (ca30980a3dae3) the controlling of system is used in some tests and apps - some subsystems are mutated by another subsystem via DES.
		    The "naive" approach was used to implement such controlling: managed sybsystem is considered as DES (i.e. represents itself via "states" where the "states" are
		    even native elements of subsystem, for instance its components), managing DES just gives controling data (mutation) to managed subsystem.</simpara>
		<simpara>Even this schema looks reasonable it still causes the questions:</simpara>
		<itemizedlist>
		    <listitem><xref linkend="ds_dcs_itr_nrd"/></listitem>
		    <listitem><xref linkend="ds_dcs_itr_sna"/></listitem>
		    <listitem><xref linkend="ds_dcs_itr_sar"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_dcs_itr_nrd"><title> Mutation as "controlling data" is not a regular DES data but an action.  </title>
		<para>First of all its nature is impuls: controlling subsystem needs to remove the mutation data as soon as it is done. This is not something
		    wrong, there are the models where "impulse" data is used sometimes, especially for representing "events" - mouse button press for instance.
		    However this "events" approach causes a lot of inconvenieces. With it DES controlling looks like the typical computer program - just
		    the sequence of the "commands".</para>
		<para>Is this really the problem. From the first glance it is not. This seems almost same as simple incrementor - new incrementor status is the
		    current status plus delta. In case of mutation the new controlled subsystem status is the current status (current structure) and the changed defined by
		    the mutation.</para>
	    </sect3>
	    <sect3 id="ds_dcs_itr_sna"><title>Controlled subsystem is not activated on mutation</title>
		<simpara>It was analogy to incrementor discussed in <xref linkend="ds_dcs_itr_nrd"/>. But there is the difference: controlled subsystem is not
		    activated on the mutation.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_itr_sar"><title>Special adapter is required DES control a subsystem.</title>
		<simpara>Using the adapter isn't convenient. Morover it is possible to "attach" more than one adapter to the subsystem. There aren't any policies to
		   avoid the possible conflicts when some controlling subsustems try to control same controlled subsystem.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>DES controlling phiylosophy: objsect as data</title>
	    <sect3><title>Intro</title>
		<simpara>DES controlling needs to be considered in the scope of DES nature: updating the states data via transormation of the data of
		    dependencies. The only sepcific of DES controlling is that the data to be updating is the controlled object.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_ucs"><title>How to support update-confirm scheme when controlling system</title>
	    <sect3><title>Into</title>
		<simpara>
		    DES architecture is based on updata-confirm principle: current sytem state is updated (calculated new state value). Current DES
		    desing implements the current-new system state via update-confirm pattern. Confirmed data is the current state whereas updated data is new state.
		    This desing is compact and effective in case of updating regular data. But how this pattern can be apply to updating system structure?
		</simpara>
		<simpara>
		    Let's distinguish "system data" and "system structue data". "System data" is the data of system states. "System structure data" is the data
		    representation of system structure. There could be different representation. For instance system chromo is one of them.
		    Obviously it is wrong to update system structure on update phase - this would make the update process not deterministic because the system structure
		    can be changed at any time during update. This would be OK if we had the same solution for system structure data as for system data. System data is 
		    "double buffered" - on update phase updated not state value but buffered one. But this solution hardly possible for system structure data.
		    Updating system structure on confirmation phase is also wrong because the structure update depends on some system data but the data can be
		    change on confirm phase, the double buffering copy is not deterministic here.
		</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_ucs_cip"><title>Current implementation - a problem.</title>
		<sect4><title>Intro</title>
		    <simpara>
			How the problem with system structure update is solved at the moment (239ba130a63)? Node adapter is used for updating system structure - the update
			performs via system mutation. Adapter performs the mutation on confirmation phase. It is assumes that the mutation formed by DES depens on system data only
			but not system structure date. So on update phase the system structure is unchanged. But the problem is (!!) with system structure update on confirmation
			phase: the system data on what the mut depends can change during confirmation phase (it depends on the sequence of system states confirmation).
		    </simpara>
		    <simpara>The previous NodeAdp implementation perfored the system mutation on update phase. But is also was wrong because the change of system structure
			affects the system states so affects the process of update depending states.</simpara>
		</sect4>
	    </sect3>
	    <sect4><title>Solution : to buffer the mutation</title>
		<simpara>We can avoid the system mut dependency from system data by buffering the mut. With that approach NodeAdp updates and save mut on update phase and
		    apply the buffered mut on confirm phase.</simpara>
	    </sect4>
	</sect2>
	<sect2><title>Using special layer for controlling systems.</title>
	    <sect3><title>Intro</title>
		<simpara>On initial times of DES desing there was the idea of how such systems can be controlled. The idea was that specific layer needs to be used.
		    This layer represent underlying layer (controlled) as data. This means that controlling layer defines controlled layer via some data
		    (it should be structured data and complex enough). In fact this data is the static description of the structure of the controlled layer.
		    In contrast of chromosome this description doesn't specify the system in "dynamic" manner (i.e. via the chromo - spec of changes the sytem)
		    but statically, as existed structure. There shall be the transitions that can manipulate with such definitions, for instance delete one 
		    branch in sytem hierarchy etc.</simpara>
	    </sect3>
	    <sect3><title>This is just another form of the current solution</title>
		<simpara>At the first look this seems same as <xref linkend="ds_dcs_itr_cs"/> but different form. With special layer the controlling subsytem
		    updata is DES standard: the data (controlled system definition) is modifyed in the proper transition that the controlled system "apply" this
		    data to it controlled model (i.e. changes the model). In DES adapter there is no explicit transition. Instead, the adapter performs "the transition" via
		    direct changing (mutating) of the controlled system. The only diff is <xref linkend="ds_dcs_itr_sna"/> - this causes the different behaviour.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_cssd"><title>System update: chromo vs system structure data.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the mut is used to update system structure via Node DES adapter (NodeAdp). But this solution is not convenient - the mut is specific
		    data and we need to form this data via rather complicated transition. What is the alternative? It is the solution where system structure data
		    is represented as simple data, for instance boolean data that represened the sign of some component of the system. Updating this data to true
		    means that system shall create that compoment.
		</simpara>
	    </sect3>
	    <sect3><title>System structue data is just another representation of Node DES adapter.</title>
		<simpara>
		    Indeed, the structure data can be implemented in the scope of adapter with adding specific inputs, outputs and internal modules.
		    Morover the system structure update via structure data finally uses mutation - we just don't have another way to change system structure.
		</simpara>
		<simpara>
		    However these two approach differs from usage point of view. With NodeAdp we need to form the sequence of mutations with complex transitions. System structure
		    data potentially can be implemeted as separate DES. Let's call this DES "system data controller". In that case With system structure data we can create two
		    controllers. There is an argument that we could create two adapters with embedded system data controller feature, but this would be rather expensive. Another
		    way is to create controller in the adapter.
		</simpara>
		<simpara>
		    Actually forming mutation for adapter is not true DES approach - in most cases we form just the sequence of mutations. With DES approach we shouldn't use
		    the sequence by set mutation depending on some valuable data (not just sequence counter).
		</simpara>
	    </sect3>
	    <sect3><title>System DES controller</title>
		<simpara>Ref <xref linkend="ds_dcs_sdc"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_sdc"><title>System DES controller (<xref linkend="gls_sdc"/>).</title>
	    <sect3><title>Controller as controlling system agent.</title>
		<simpara>
		    It is the common case that controlling DES is implemented right in controlled DES. We can intoduce specific agents - 
		    <xref linkend="gls_sdc"/> to simplify the control. This agent input on one hand form "query" to managed system so the query provides
			boolean result (for instance, for "Comp" controller that creates new comp there are inputs "Name", "Parent" that forms the query
			"Is there component of type "Parent" and name "Name"). Let's call the query result as "output" of controller.
			On another hand the inputs forms control action - "Comp" controller creates the component.
			Controller also contains special boolean input "Enable" that enables the contolling action.
			Such controller scheme allows to create the controlling DES more convenient. One controller output connects to another controller
			"Enable" input so DES-stype dependencies are simply established.
		</simpara>
		<simpara>The main idea of this approach is "distributed" nature of controlling : there can be complex controlling scheme that includes
		    many controlling agents. The agents forms "standard" DES via connecting one to another.</simpara>
	    </sect3>
	    <sect3><title>How to control "remote" system.</title>
		<simpara>
		    Another case is when controlled system is not direct owner of controller. The solution here can be collect the controllers in
		    special host DES where we can provide controllers with "environmental" access to controlled system. This "environmental" access can
		    be implemented as the link to managed system that (this link is "known" to controllers). If we need to support more comples use-cases
		    (for instance the main case of modnav - select managed sub-system via navigation thru given system) then we can create custorm host DES that updates this 
		    link to managed system in same manner as DES adaptor does.
		</simpara>
	    </sect3>
	    <sect3><title>Controller can be implemented as non-native agent</title>
		<simpara>
		    Indeed, we can have controller as a system that includes adapter to managed system. The control action can be done via
		    the mutation thru the adapter, the controller output can be formed via specific functions getting data from the adapter.
		</simpara>
		<simpara>
		    The problem here is that the adapter performs the mutation on confirmation phase but the sequence of confirmation is not
		    detarministic: some inputs can be changed.
		</simpara>
	    </sect3>
	    <sect3><title>Controller native implementation.</title>
		<simpara>
		    Native implementation can help to avoid the problem with non-deterministic inputs update on confirmation phase, see the problem
		    description above.
		</simpara>
	    </sect3>
	    <sect3><title>"Multi-client" controlling.</title>
		<simpara>Major benefit of SDC solution is that the controlling of target system can be performed from many points of the model. It is
		    similar to "client-server" approach. However we can see the potential problems here. Let's look at fap3-vis DContainer. It embeds the 
		    controlling syb-system that allows to add widget. DController expose specific socket as an input to this subsystem. Also the controlling status
		    output is included into the socket.</simpara>
		<simpara>But what is we need that DContainer control performs from tho parts of the model? How to support this?  </simpara>
		<simpara> The firt approach is to 
		    pull out this controlling subsystem from DContainer. In that case we can create two controlling sybsystem for each controlling 
		    parts ("clients"). However we need to support such "remote" controlling providing the controlling system with access to managed system like it
		    is done for DES adapter. Also it is not nice solution. The controlling DES is specific for DContainer so it would be architecturally more
		    correct way to have controling system incapsulated into container.</simpara>
		<simpara>Another solution would be to keep controlling subsytem inside DContainer but provide the container with means of creating other such
		    controling subsystem (again via controloing of DContainer.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_sdc_uc"><title>Use-cases</title>
		<sect4><title>[<glossterm id="uc_sdc_01">UC_SDC_01</glossterm>] Loading the pipeline</title>
		    <simpara>The first data is loaded the pipeline (for container example it is that Name value is set for IoAddWidg.Enable input)
			- The controlling chain is completed (for container example it is that the widget was added and last SDCs in the chain sets outp Outp to true)
			- New Name is set to pipeline input - the controlling chain creates new widget successfully.</simpara>
		    <sect5><title>Discussion</title>
			<simpara>This UC seems not valid. Ref <xref linkend="uc_sdc_05"/> for another UC that seems more reasonable.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_02">UC_SDC_02</glossterm>] Controller doesn't change system in case of DES Inp notification comes but inputs are not changed actually</title>
		    <simpara>The first data is loaded the pipeline (for container example it is that Name value is set for IoAddWidg.Enable input)
			- The controlling chain is completed (for container example it is that the widget was added and last SDCs in the chain sets outp Outp to true)
			- Some controller input (for instance IoAddWidg.Name) gets DES inp notification comes but the input data is not changed actually (this can happed
			especially if the input connects to some function output and func input is changed but doesn't cause func outp change actually)
			- Controller doesn't change the system.</simpara>
		    <sect5><title>Discussion</title>
			<simpara>This means that controller is not sensitive to "fake" input change. In regular DES such feature is not needed - in case of 
			    "fake" change DES just recalculate it't states (they keep unchanged in result). But for SDC it is inportant because the controller DES data
			    is not simple dataThis means that controller is not sensitive to "fake" input change. In regular DES such feature is not needed - in case of 
			    "fake" change DES just recalculate it't states (they keep unchanged in result). But for SDC it is inportant because the controller DES data
			    is not simple data, controller changes the system structure incrementally. </simpara>
			<simpara>But do we really need this? Ponentially controller can avoid incorrect system update via checking if the system is updated already.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_03">UC_SDC_03</glossterm>] SDCs form right control trigger</title>
		    <simpara>
			There is the pipeline of SDCs: SDC_1 (creating node_1), SDC_2 (creating node_2), SDC_3 (removing node_1), SDC_4 (removing node_2).
			SDC_4 triggering condition is SDC_3 status (Outp). This mean SDC_4 is to remove node_2 only after node_1 is removed. 
			System starts, SDC_3 formal condition is met (because on this phase node_1 doesn't exitst). SDC_4 gets correct trigger only creating and then removeing node_1.
		    </simpara>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_04">UC_SDC_04</glossterm>] Creating/removing component in cycle</title>
		    <simpara>
			There is the pipeline of SDCs: SDC_1 (creating component "Comp"), SDC_2 (removing component "Comp").
			SDC_2 triggering condition is SDC_1 status (Outp). This mean SDC_2 is to remove component "Comp" only after SDC_1 has created the comp. 
			SDC_1 triggering condition is SDC_2 status (Outp). This mean SDC_1 is to create component "Comp" only after SDC_2 has removed the comp. 
			System starts and run N ticks - SDCs create and remove component "Comp" N times.
		    </simpara>
		    <sect5><title>Notes</title>
			<simpara>Ref ut_dessdc.cpp:test_Sdc_3 (ut_sdc_3.chs) for correspoiding unit test.</simpara>
			<simpara>Ref <xref linkend="ds_dcs_sdc_dsgn_os"/> for desing item.</simpara>
		    </sect5>
		</sect4>
		<sect4><title>[<glossterm id="uc_sdc_05">UC_SDC_05</glossterm>] Controller change system when being notified thru "Enable" inp event inp value is not changed</title>
		    <simpara>The direct specifying this case is rather exhausted. Ref fap3/test/ut_sdc_2.chs for the model. This UC contradicts to <xref linkend="uc_sdc_01"/></simpara>
		    <simpara>PRECONDITIONS</simpara>
		    <programlisting>
			There is the model that contains 3 SDCs: SDC_Comp - creation component - list node, SDC_Insert - inserting the node into the list,
			SDC_Extract - extracting the node from the list. The model insert/extract the node in the cycle. To do this SDC_Insert trigger ("Enable" inp)
			depends on the switch that initially is switched to SDC_Comp status and then, after insertion switches to extraction status.
		    </programlisting>
		    <simpara>STEPS</simpara>
		    <programlisting>
			#0 - link node is created
			#1 - insertion trigger is ok (switcher on status of creation). Node is inserted.
			#2 - insertion status is OK, i.e. extraction trigger is OK. Switcher is still on status of creation (OK). Extracted.
			#3 - Switcher on extraction status - OK, i.e insertion trigger is still 1. Expecting that insertion SDC performs the control.
		    </programlisting>
		    <sect5><title>Discussion.</title>
			<simpara>Acc to <xref linkend="uc_sdc_01"/> the insertion on #3 cannot happen because the trigger value is not change.</simpara>
		    </sect5>
		    <sect5><title>Desing</title>
			<simpara>Ref <xref linkend="ds_dcs_sdc_dsgn_oin"/> for the desing</simpara>
		    </sect5>
		</sect4>
	    </sect3>
	    <sect3 id="ds_dcs_sdc_dsgn"><title>Pipelined controlling. Design of native SDC</title>
		<sect4><title>Intro</title>
		    <simpara>The tipical system controlling consists of number of SDCs combining in a chain so that some controlling operation happens depending on
			"previous" operation gets completed. This structure actually creates controlling pipeline. The example is the adding the widget into vis container,
			refer to fap3-vis/modules/container.chs. Initial SDC design already contains support of such pipeline - there was input "Enable" and "Outp" output:
			The current SDC depends(inp Enable) on previous SDCs completion (out Outp).  Such structure however posesses its specific use-cases and design specifics.</simpara>
		    <simpara>Ref <xref linkend="ds_dcs_sdc_uc"/> for the pipeline specific use-cases.</simpara>
		</sect4>
		<sect4><title>Controlling phase</title>
		    <simpara>SDC changes the controlled system on Confirmation phase.</simpara>
		</sect4>
		<sect4><title>Inputs buffering</title>
		    <simpara>To support of controlling on confirmation phase the controller buffers all the inputs. Ref fap3 6db8376c3f3e:src/dessdc ASdc::Iap desing
			(mUdt, mCdt etc).</simpara>
		    <simpara>
			Is this really needed? Why not just get the inputs data on confirmation phase when controlling? This is the support of
			<xref linkend="uc_sdc_02"/>. But as stated in the UC discussion there are other desing solution for that.
		    </simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_idp"><title>Inputs data pipeline in SDC</title>
		    <simpara>
			<xref linkend="uc_sdc_01"/> assumes that next pipeline chain proceeds reacting the data from previous one. For instance for the container example SdcConnWdg
			    reacts on same IoAddWidg.Name that previous SDCs (CreateWdg, AddSlot) are reacting. But SdcConnWdg "V1" input cannot be connected directly to IoAddWidg.Name.
			    This is because this input can be changed after CreateWdg is done. So we need to have SdcConnWdg "V1" input same data that CreateWdg was reacting. 
			    The solution here is to pipeline the IoAddWidg.Name data also. For that we need to have IoAddWidg.Name corresponding output OutpName so input data is copyind
			    to output.
		    </simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_cc"><title>Forming status. Taking into account the completion of controlling.</title>
		    <simpara>Ref <xref linkend="uc_sdc_03"/> for the use-case.  </simpara>
		    <simpara>The desing supporting this use-case is that we need to form pipeline controllers status with taking into account that the sign of controlling completion.</simpara>
		    <sect5><title>Status</title>
			<simpara>This feature is disabled because of clear indication that the use-case is not valid. Alternative design Solution#2 is used - to check the status before 
			    performing the control.</simpara>
		    </sect5>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_os"><title>Controller observs controlled system status and notifies inputs of Outp (SDC status) changed.</title>
		    <simpara>Ref <xref linkend="uc_sdc_04"/> for the use-case.  </simpara>
		    <simpara>Controller needs to notify controlling status (Outp) change on controlled system change. For that controller needs to observe controlled system.</simpara>
		    <simpara>It is not obvious consideration but without this notification the cycle scheme described in use-case doesn't work. The root-cause of this problem is that for 
			instance SDC_1 doesn't notify SDC_2 on status update when SDC_2 removes the comp thus the controling system sticks.</simpara>
		</sect4>
		<sect4 id="ds_dcs_sdc_dsgn_oin"><title>Controller updating on inps notifications even input value not changed</title>
		    <simpara>Ref <xref linked="uc_sdc_05"/> for the UC</simpara>
		    <simpara>Main Solution#1 is simple - just enable control if inp was notified even its value is unchanged.  </simpara>
		    <simpara>Alternative Solution#2 is to set SDC as updated (i.e. enable performing control) if controlled system data observation
			(MagDobs) gets the event. The idea is that the event means the status can be changed, so we need to recalc the status and
			perform the control if status isn't met.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_sdo"><title>System DES oberving (<xref linkend="gls_sdo"/>) </title>
	    <sect3><title>Intro</title>
		<simpara>Very often we need to observe the controlled system when creating controlling DES. Sometimes status functions embedded to SDC is enough, but in many cases
		    we need separate functions to get controlled system status.</simpara>
	    </sect3>
	    <sect3 id="ds_dcs_aes"><title>Design: access to explorable system</title>
		<sect4><title>Intro</title>
		    <simpara>SDO needs the access to explorable system. By default any owned components don't have an access to their owners. Same problem is actual for DCS. Current DCS
			design utilized MAgent interface that allows DCS (i.e. agent) to have the acces to its owner. However this solution is not far from perfect. This is because MAgent interface
			was not introduced for such purpose as system controlling. Instead it is just to establish "trusted" relationship between agent owner and agent so the agent can play the
			role of owener "consiliary". Fro instance owener event redirects IRM requests to its agents.  So MAgent iface is too "heavy" for the purpose of observing.</simpara>
		</sect4>
		<sect4 id="ds_dcs_aes_acp"><title>Soution: Owner accessibility controlled by owner props</title>
		    <simpara>The idea is to utilize MOwner local iface resolution mechanism to provide an access depending on owner props. For instance if owner property "Explorable" equals "y"
			then MOwner provides owned with iface allowing exploring of the owner.</simpara>
		    <simpara>The potential problem here is that this access is given for all owned compoments that expose the vulnerability. We can solve this problem using IRM mechanism instead
			of local iface resolution. With IRM the requestor (owend) gets accessible to the owner so the owner can set some restriction. For instance the restriction can be that the owner
			request some iface (kimd of MExploring) from the requestor.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_cda"><title>Composite DES adapter as the context for controllers and observers.</title>
	    <sect3><title>Intro</title>
		<simpara>Currently [5734b4e935a0, 20220403] the initial desing of DES adapter is in usage - tha adapter is monolitic and iface specific
		    (MNode, MElem etc). This design has the number of cons: it makes overhead (not all CPs are used etc. So we consider another desing - 
		    comopsite adapter. With this desing the adapter itself provides the context for owning controllers and observers. The main part of the context
		    is the link to managed agent.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_ord"><title>DCS example/test - ordering of agents.</title>
	    <sect3><title>Intro</title>
		<simpara>We need to create numberer of examples to discover the weaknesses of the current DCS approach and find the proper solutions. The first
		    example is ordering of agents.</simpara>
		<simpara>The model is as "fap3/test/ut_adp_dcs_1.chs".</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Activating system via implicit dependencies.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    It is normal case in the system using controlling when the controlled system (i.e. system + adapter) depends on itlself implicitly. The example is
		    <xref linkend="ds_dcs_ord"/> - the system is mutated with transition that gets system itself (acually internal connections) as input.
		</simpara>
		<simpara>In contrast of typical DES there aren't explicit dependencies, e.g states that depends each other.</simpara>
		<simpara>
		    The question is how to understand if subsystem depends on another subsystem (or even on itself) if threre aren't explicit dependencies?
		    Let's look at the example
		    <xref linkend="ds_dcs_ord"/>: how to get known if controlled system (Root.Launcher) depends on itself via the mutating
			transition?
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dcs_trs"><title>DCS transaction</title>
	    <sect3><title>Intro</title>
		<simpara>Let's consider an example: DContainer adding widget. It is DCS SDC solution that includes 4 SDCs: CreateWdg, CreateSlot, ConnectSlot, InsertSlot.
		    What if some SDC fails, lets say InsertSlot. In that case we will have the managed system messed: there will be created widget, new slot but the widget
		    will not be shown. It is clear that we need to consider all these 4 SDCs as the single controlling DES. It looks like the transaction in database
		    solutions.  </simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_dbg"><title>Debugging</title>
	<sect2><title>Intro</title>
	    <simpara>The following improvements can be considered: </simpara>
	    <itemizedlist>
		<listitem>
		    Unify the usage of debugging level 
		    <para>
			Currently the debugging level is almost unusable. Also in parallel the property "Update" is used to
			specify the particular logging feature to log the state update whereas it is just specific logging level.
			So we need to get rid of using the Update property.
		    </para>
		</listitem>
		<listitem> Logging level forcing to owned, ref <xref linkend="ds_dbg_llf"/> </listitem>
		<listitem>Using symbolic values for logging level, lile "Dbg.1"</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_dbg_llf"><title>Logging level forcing to owned</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to provide the system developer the ability to quick set the logging level for the whole system or its part.
		    Currently the logging level is set locally for the particular node only and doesn't affect the other nodes, even the owneds.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dbg_sfll"><title>Symbolic form of logging level</title>
	    <sect3><title>Intro</title>
		<simpara>The idea is to set logging level in symbolic form like "Dbg.2" where "Dbg" is the name of level and "2" is the extension.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_iis"><title>Setting initial invalid status of State</title>
	<sect2><title>Intro</title>
	    <simpara>It is the common case when we need to set the initial "invalid" value to State. For instance quite often we need to define state signature, i.e SS but
		we don't want to set the value that can cause system movement, so currently we use something like "SS nil" assuming that the value "nil" has to be specifically handled
		(but actually it is not). It would be good if we have support setting of kind of "invalid" or "value-is-not-set" value. Current State desing doesn't allow doing that. </simpara>
	    <simpara>Not sure that currently supported by data "invalid" indication is suitable for such puproses. This indication currently interpreted as error.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_dee"><title>DES elements embedded</title>
	<sect2><title>Intro</title>
	    <simpara>Often it is required to create monolitic native DES specialized for the given usage. Such solution allows
		significantly inclrease the overall system desing effectiveness. There were already many local solutions for that, ref
		ASdc, AAdp etc. for instance. Having this local solution causes the code duplication and problems with support.
		So it is time to provide the proper framework for this solutions.  </simpara>
	    <simpara>The main idea of having DES embedded elements is to interfit native DES with DES agent's internal desing.</simpara>
	</sect2>
	<sect2 id="ds_dee_ssi"><title>Double buffered input</title>
	    <sect3><title>Intro</title>
		<simpara>The base DES desing states that we need to update the state value on Update phase and then actualize (confirm) it
		    on Confirm phase. But sometimes we can use another way for embedded solution. Let's consider tipical DES adapter (ref desadp.cpp):
		    the adapter embeds "Managed agent" (MAG) state. With standard desing we need to have adapter input "MagUri" that value points
		    to MAG relatively to MAG base and dedication state "MAG". Adaprer gets activated thru "MagUri" input notification (confirm phase)
		    and set "MAG" state as activated, then on Update phase form preliminary MAG value and then on next confirm phase actualize
		    the "MAG" value</simpara>
		<simpara>This scheme assumes two embedded entities (input and state) and native connections between them.</simpara>
		<simpara>Alternative option is to have double buffered input. In that case the "MagUri" input is fixed on confirmation phase.
		    On confirmation phase the adapter can just check if new MagUri is confirmed and apply it to MAG. The pros of this variant
		    is that state transition can be implemented in host that simplify the code.</simpara>
		<simpara>Note that local transition (ref <xref linkend="ds_dee_sac"/> is the alternative solution, probably more elegant (this
		    is questionable).</simpara>
	    </sect3>
	    <sect3 id="ds_dee_ssi_vgd"><title>Solution as the variant of DES generic desing</title>
		<simpara>Let's look at "Dedicated states ..." solution from DES generic desing point of view. Currently the DES cycle is based on
		    calculate new states values in Update phase (states freezed), confirm states and notify deps on Confirm phase - states are double-buffered,
		    states are freezed on Update.</simpara>
		<simpara>But there was alternative desing, that we considered on earlier fap2 (or even fap1) projects. This desing is to freeze transitions
		    inputs instead of states: calculate new states values in Update phase (inputs freezed), confirm inputs and notify deps on Confirm phase - inputs are
		    double buffered, states are freezed on conirm phase.</simpara>
		<simpara>This "Double buffered input" solution follows exactly such approach. The problem here is that for double buff inp solution DES cycle is
		    inverted the question is of how to align the parts working with contradicted phases. This problem can be simply solved in case of 
		    "embedded" states - DES just can control Confirmation phase: update the double buff inputs on early stage of confirm phase (so freeze them) and
		    then do the standart Confirm processing.</simpara>
	    </sect3>
	    <sect3><title>Solution as embedded state connected to host input</title>
		<simpara>The double buffered input above can be also intepreted as the embedded state connected to host input. Probably this intepretation is
		    simpler that <xref linken="ds_dee_ssi_vgd"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_dee_sac"><title>Sharing DES agent context to transitions.</title>
	    <sect3><title>Intro</title>
		<simpara>It is common case when we decide to move some part of DES functionality into "internal" native desing because the transitions depends on
		    internal agent context. The example is fap3-vis widget: requisition states depends of font size but the transition depends on C++ font instance created
		    in the scope of the agent. The idea of how to solve this is to keep fap3 DES style topology but give the agent context to the transition.</simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_ait"><title>Solution: Exposing agent interface to transition.</title>
		<simpara>This solution is base of IFR. Currently owner in fap3 native hier provides local MUnit iface. This allows a transition to request
		    some iface from the owner (actually in case of DES agent the owned system will route the request to the agent). So we can introduce the generic
		    MDestContext interface that a transition can use for access to agent's resources. This iface IFR can provide access to the agent specifically
		    defined iface, in case of fap3-vis widget example is can be MWidgetContext that resolves all the dependencies from the agent for the transition.</simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_asp"><title>Solution: creating binded transition via agent's specific provider.</title>
		<simpara>The idea is to pass the context to the transition on transition contstruction phase. This can be done with using agent specific provider.
		    Currently it is possible for the agent to register it's own provider via env addProvider(). Such provider can create the transition and pass the context
		    pointer to transition instance on creation phase. It that case the agent just implements MProvider interface.</simpara>
		<simpara>The potential problem here is that adding the provider affects global behaviour. Can we improve Env providers mechanism to have "local" provider?
		    Yes, ref <xref linkend="ds_lps"/> for the design. </simpara>
	    </sect3>
	    <sect3 id="ds_dee_sac_taee"><title>Node: Embedded transition as the alternative of other DES embedded elements.</title>
		<simpara>
		    Let's again consider the use-case: fap3-vis widget (widget.h) needs to update embedded font instance depending on font path state. Initial
		    solution was to utilize Buffered input DES embedded element, ref
		    <xref linkend="ds_dee_ssi"/>. With this solution we need to add embedded elements
			support to widget agent (this is quite a lot of code). Alternative solution would be using local scope transition: we have state FontPath, state
			FontApplied and local scope transition "ApplyFont" that containts the agent content and updates (re-creates) the embedded font instance.
		</simpara>
		<simpara>The question here if this scheme provides better understanding of the system. From my view embedded elems still makes system better undertstanding.
		    this is because the transistion "hides" the actual context so it is hard to see that the transition changes the context of agent.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_lps"><title>Improving provider iface to limit the provider's scope</title>
	<sect2><title>Intro</title>
	    <simpara>Curently MEnv iface allows any agent in native hier to register provider, ref MEnv::addProvider(). This creates the vulnarability: local agent can
		affect the whole system by creatng improper node. We need to close this hole.</simpara>
	    <simpara>Ref <xref linkend="ds_dee_sac_asp"/> for the use-case.</simpara>
	</sect2>
	<sect2><title>Solution: add the context indication to provider iface.</title>
	    <simpara>The idea is to extend MProvider API by adding getContext() method. This method will return the node of native hier in which scope the provider is actual.
		If the context is root then the provider is "global" for the system. Note that currently root is available from env but this needs to be disabled.
		Node mutation methods shall check this context when creating node. If the method see that provider tries to create node in the upper scope the method
		needs to deny the creation.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_ibc"><title>Desing items to be considered</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <xref linkend="ds_itr_sp"/> for the initial list of the problems need to be addressed in FAP3.</simpara>
	</sect2>
	<sect2 id="ds_ibc_roncc"><title>Root as the only node containing chromo</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Currently the model can contain many nodes that have theyrs own chromos - any Elem based nodes. This simplifies creating these nodes
		    heirs. But on another hand this causes chromo duplication. Actually any node chromo can be "calculated" from root chromo. This approach
		    was tried in some earlier version of FAP.
		    This approach potentially can improve the model performance. We need to consider such design.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_ibc_dgit"><title>[DS_IBC_DGIT] Do we need MDtGet iface as templated one?</title>
	    <simpara>Potentially we can have non-templated MDtGet that provides the access to base data iface MDtBase.</simpara>
	    <simpara>The indication of week desing is the problems with TrTuple: it is not possible to update the tuple components. The input of the 
		transition can get the access to data only via templated MDtGet but the type isn't explicitly known.</simpara>
	</sect2>
	<sect2><title>Intitial invalid status of State</title>
	    <simpara>Ref <xref linkend="ds_iis"/></simpara>
	</sect2>
	<sect2><title>Localize provider's scope</title>
	    <simpara>Ref <xref linkend="ds_lps"/></simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_iss"><title>Issues</title>
	<sect2 id="ds_iss_001"><title>[DS_ISS_001] Wrong chromo forming in case of namespace segment.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    Ref ut_elem.cpp:test_elem_inh_1() chromo ut_elem_inh_1.chs. The problem is that mutation 
		    <programlisting>About = "N1_1 new";</programlisting>
			will be included into E1 chormo twice: first entry is in the scope of namespace segment
		    <programlisting>
			N1_1 @ {
			About = "N1_1 new";
			}
		    </programlisting>
			and the second - in E1 chromo directly
		</simpara>
		<simpara>
		    Ref <xref linkend="ds_eosm"/> for the details of <xref linkend="gls_eosm"/> current solution. The reported problem is
			caused by this solution bad design.
		</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>
		    The root-cause is that the algorithm of E1 chromo forming is wrong: mutation and "About = ..." will be included even 
		    the namespace segment is alredy included.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_002"><title>[DS_ISS_002] Cannot define monitored agent for <xref linkend="gls_adp"/></title>
	    <sect3><title>Intro</title>
		<simpara>
		    It is very common case that the adapter is not owner of monitored agent. Potentially we can put monitored
		    agent to adaper owneds but it is not convenient - there can be many adapters associated to single monitored object.
		</simpara>
		<simpara>
		    This "not owning" causes the problem that we cannot simply define monitored object via URI - adapter will not
		    be able to get not owned node.
		</simpara>
		<simpara>
		    Ref <xref linkend="ds_sn_aul"/> for details of generic problem and approaches of how to workaround the
			access restrictions.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_003"><title>[DS_ISS_003] 20211212 git:930bb4ea585ece. Incorrect IFR for sockets</title>
	    <sect3><title>Intro</title>
		<simpara> UT Ut_ifr::test_inval_sock_1() fails. This means that IFR works incorrectly in case of sockets connecting/disconnecting.  </simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>The current implementation of IFR tree update (ref <xref liknend="ds_irm_ut"/>) supports only vert connect/disconnect. The 
		    Vert::connect() just invalidates the vertexes IFR. But for sockets it doesn't work - the pins are not invalidated.</simpara>
	    </sect3>
	    <sect3><title>Fix proposal</title>
		<simpara>We need to redesing IFR:</simpara>
		<itemizedlist>
		    <listitem>
			IFR node validity sign shall indicate that node has to be updated
			<para>Currently the validity is set based on resolution result - node is considered as valid if the iface is resolved.
			    If not, then node is marked as invalid and is removed then.</para>
			<para>We don't need to mark node as invalid in case of iface is not resolved. The whole branch has to be marked as valid even
			    it is iface is not resolved. This branch cannot "provide" iface but shows us the path of resolution attempt.</para>
		    </listitem>
		    <listitem>
			Invalidated unit has to invalidate its own nodes and theirs owners (requestors, i.e clients). Owned nodes are to be removed.
			<para>The logic here is: the local node says to the requestors: "Im invalid, you are using me so you needs to be updated,
			    this means you are also invalid.</para>
			<para>The owned nodes don't need to be invalidated - these branches are created by the current nodes, so they needs to be
			    removed and re-created according to new environment.</para>
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_004"><title>[DS_ISS_004] Visualization error: sometimes CRP is not set hight requisizion</title>
	    <sect3><title>Intro</title>
		<simpara>The issue happens after introducing <xref linkend="gls_asr"/> solution, ref <xref linkend="ds_asr_cbs"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_005"><title>[DS_ISS_005] Chromo2 desing assumes the top is mut_create_chromo - it is inconvenient</title>
	    <sect3><title>Intro</title>
		<simpara>
		    The inconvenience is that very ofter we need just segment chromo without root. Currently we need to use
		    mutation operation option "TreatAsChromo". Ref for instance  desadp.cpp:AMnodeAdp::ApplyMut():
		</simpara>
		<programlisting>
		    mMag->mutate(chromo.Root(), false, mutctx, true);
		</programlisting>
		<simpara>So we need to redesign chromo to support pure "segment" chromo.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_006"><title>[DS_ISS_006] NodeAdp current sytem update-confirm scheme is wrong.</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ds_dcs_ucs_cip"/></simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_007"><title>[DS_ISS_007] State content change on creation phase blocks update notification</title>
	    <sect3><title>Intro</title>
		<simpara>Ver next to 3ebc09ad1022d85</simpara>
		<simpara>
		    Created fap3/modules/dutil.chs. Tested with test/ut_des.cpp:ut_des_utl_1.chs. Observed the problem that BChange DES doesn't confirm even Delay state updated from false to true.
		    Analyzed. The root-cause is that Delay state content is set on creation phase - state notifies thru incomplete owning chain (so didn't reach the launcher) but the flag 
		    mUpdated was set, that prevent complete owning chain notifying on the first update.
		</simpara>
		<simpara>Curren solution is Solution#2, ref below.</simpara>
	    </sect3>
	    <sect3><title>Solution#1: avoid setting state mPdata and mCdata on content change.</title>
		<simpara>With this solution State doesn't change its datas immediately on content change but just keeps content and change mPdata on update phase from content kept.</simpara>
		<simpara>This solution doesn't work properly. The reason is that in the first init the constant state are undefined. This causes to dependent states gets undefined that
		    in turn causes the whole DES stop. Shortly saying we don't have initial conditions set for DES actually.</simpara>
	    </sect3>
	    <sect3><title>Solution#2: activate owned on owned attached</title>
		<simpara> The idea is to force owned active when attaching it to owner. There are variations of this solution.  </simpara>
		<simpara> The Var#1 is rather "brutal" - just to activate the owner unconditionally.  </simpara>
		<simpara> The Var#2 is to activate only if the owned was already activated. We need to add methods "isActivated" and "isUpdated" to MDesSyncable in this case.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_iss_008"><title>[<glossterm id="iss_008">DS_ISS_008</glossterm>] Parent located in second level module cannot be found.</title>
	    <sect3><title>Intro</title>
		<simpara>
		    The problem reproduced in [fap3-vis:5734b4e935a] [fap3:8228680d62a] in test fap3-vis/test/ut_avr_node_drp.chs with the change AvrMdl to AvrMdl2:
		    <programlisting> ERR;;.testroot.Test.Window.Scene.Drp;Creating [Slot_Model_comp1] - parent [FHLayoutSlot] not found </programlisting>
		</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>System topology is as</simpara>
		<programlisting>
		    root
		    |
		    |---Modules
		    |       |
		    |       |---AvrMdl
		    |             |
		    |             |---Modules
		    |                     |
		    |                     |---ContainerMod
		    |                               |
		    ...                             ...
		    |                               |--- FHLayoutSlot
		    |                            
		    |  
		    |--- Slot (parent FHLayoutSlot)
		</programlisting>
		<simpara>
		    Current parent resolution mechanism doesn't work here. The mutation is as:
		    <programlisting>
			364		parent = getParent(prnturi);
			(gdb) p Uid()
			$12 = ".testroot.Test.Window.Scene.Drp%MOwned"
			(gdb) p mContext->Uid()
			$13 = ".testroot.Modules.AvrMdl2%MOwner"
		    </programlisting>
			The mechanism is pritty simple (func getParent):
		    <programlisting>
			- look up in local scope (mutation scope) using getNode()
			- redirect to owner's getParent()
			- look up in modules using modules->getNode()
		    </programlisting>
			note that mContext of ".testroot.Modules.AvrMdl2%MOwner" ecuals 0. So the look up trace is as:
		    <programlisting>
			.testroot.Test.Window.Scene.Drp
			  .testroot.Modules.AvrMdl2
			    .testroot.Modules (owenr of AvrMdl2 as AvrMdl2 doesn't have a context).
			.testroot.Test.Window.Scene
			...
			fail
		    </programlisting>
		</simpara>
		<simpara>Hmm, but such resolution works in modnav2. Right, in modnav2 the slot is created from </simpara>
		<programlisting>.testroot.Launcher.Window.Scene.VBox.ModelView.Drp</programlisting>
		<simpara>
			So the look up trace is as:
		    <programlisting>
			.testroot.Launcher.Window.Scene.VBox.ModelView.Drp
			  .testroot.Modules.AvrMdl2
			   .testroot.Modules (owner of AvrMdl2 as AvrMdl2 doesn't have a context).
			.testroot.Launcher.Window.Scene.VBox.ModelView
			  (context) Modules.ContainerMod
			   ...
			   ok
		    </programlisting>
		    The resolution is ok, but this result is just "accidental", because the "right" owner of Drp.
		</simpara>
		<simpara>
		    Real root-cause is that the ContainerMod module desing is wrong:
		    <programlisting>
			317     DHLayout : DLinearLayout
			318     {
			...
			325         SlotParent &lt; = "SS FHLayoutSlot";
		    </programlisting>
			SlotParent paremeter is set here incorrectly. It should be set from the real context where it is used, i.e. from the test system
			(fap3-vis/test/ut_avr_node_drp.chs):
		    <programlisting>
			39                 Drp : AvrMdl2.NodeDrp {
			40                     SlotParent &lt; = "SS ContainerMod.FHLayoutSlot";
			41                 }
		    </programlisting>
		</simpara>
	    </sect3>
	    <sect3><title>Solution</title>
		<simpara>To set SlotParent parameter from the real context where it is used.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1></sect1>


</article>

